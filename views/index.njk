<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title | default("AI RPG Chat") }}</title>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/map.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI RPG Chat Interface ü§ñ</h1>
            {% include "_navigation.njk" %}
        </div>
        
        <div class="main-content">
            <div class="tab-bar" role="tablist">
                <button class="tab-button active" id="tab-adventure-tab" data-tab="adventure" role="tab" aria-selected="true" aria-controls="tab-adventure">Adventure</button>
                <button class="tab-button" id="tab-map-tab" data-tab="map" role="tab" aria-selected="false" aria-controls="tab-map">Map</button>
                <button class="tab-button" id="tab-character-tab" data-tab="character" role="tab" aria-selected="false" aria-controls="tab-character">Character</button>
                <button class="tab-button" id="tab-party-tab" data-tab="party" role="tab" aria-selected="false" aria-controls="tab-party">Party</button>
            </div>

            <div class="tab-panels">
                <section class="tab-panel active" id="tab-adventure" role="tabpanel" aria-labelledby="tab-adventure-tab">
                    <div class="adventure-background" id="adventureBackground" aria-hidden="true"></div>
                    <div class="adventure-content">
                        <div class="location-block">
                            <div class="container">
                                <div class="location-header">
                                    <h4>üìç <span class="location-name" id="locationName">Unknown Location</span></h4>
                                </div>
                                <div class="location-content" id="locationContent">
                                    <div class="location-image-wrapper" id="locationImageWrapper">
                                        <div class="location-image" id="locationImage">
                                            <div class="location-placeholder">
                                                <!-- Nothing in here on initial load -->
                                            </div>
                                            <div class="location-tooltip" id="locationTooltip">Your current location will appear here when you start exploring.</div>
                                        </div>
                                        <button type="button" class="location-image-menu-button" id="locationImageMenuButton" aria-haspopup="true" aria-expanded="false" aria-label="Location options">‚Ä¢‚Ä¢‚Ä¢</button>
                                        <div class="location-image-menu" id="locationImageMenu" hidden>
                                            <button type="button" class="location-image-menu-item" id="locationImageEditButton">Edit Location</button>
                                            <button type="button" class="location-image-menu-item" id="locationRegionEditButton">Edit Region</button>
                                            <button type="button" class="location-image-menu-item" id="locationSummonNpcButton">Summon NPC</button>
                                            <button type="button" class="location-image-menu-item" id="locationSummonThingButton">Summon Item/Scenery</button>
                                            <button type="button" class="location-image-menu-item" id="locationImageRegenerateButton">Regenerate Image</button>
                                        </div>
                                    </div>
                                    <div class="location-info" id="locationInfo">
                                        <div class="location-details" id="locationDetails">
                                            <span class="location-level" id="locationLevel">Level: ?</span>
                                        </div>
                                        <div class="location-hint" id="locationHint">Hover over the location image for a description.</div>
                                        <details class="location-section location-exits" open>
                                            <summary>Exits</summary>
                                            <div class="location-exits-content" id="locationExits">
                                                <div class="location-exits-list" id="locationExitsList">
                                                    <div class="no-exits">No exits discovered yet.</div>
                                                </div>
                                                <button type="button" class="location-exit-add-button" id="newExitButton" disabled>New Exit</button>
                                            </div>
                                        </details>
                                        <details class="location-section location-npcs" open>
                                            <summary>NPCs</summary>
                                            <div class="location-npc-content">
                                                <div class="location-entity-grid" id="locationNPCs">
                                                    <div class="location-npc-empty">No notable NPCs present.</div>
                                                </div>
                                                <button type="button" class="location-npc-add-button" id="addNpcButton" disabled>Add NPC</button>
                                            </div>
                                        </details>
                                        <details class="location-section location-things" open>
                                            <summary>Items &amp; Scenery</summary>
                                            <div class="location-thing-content">
                                                <div class="location-thing-category">
                                                    <h5 class="location-thing-heading">Scenery</h5>
                                                    <div class="location-entity-grid" id="locationScenery">
                                                        <div class="location-thing-empty">No notable scenery present.</div>
                                                    </div>
                                                </div>
                                                <div class="location-thing-category">
                                                    <h5 class="location-thing-heading">Items</h5>
                                                    <div class="location-entity-grid" id="locationItems">
                                                        <div class="location-thing-empty">No notable items present.</div>
                                                    </div>
                                                </div>
                                                <button type="button" class="location-npc-add-button location-thing-add-button" id="addThingButton" disabled>New Item</button>
                                            </div>
                                        </details>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="chat-wrapper">
                            <div class="chat-container">
                                <div class="chat-log" id="chatLog">
                                    {% if chatHistory and chatHistory.length > 0 %}
                                        {% for message in chatHistory %}
                                            {% if message.type == 'event-summary' %}
                                                {% set summaryTitle = message.summaryTitle or (message.content.split('\n')[0]) %}
                                                {% set summaryItems = message.summaryItems or [] %}
                                                <div class="message event-summary-batch">
                                                    <div class="message-sender">{{ summaryTitle }}</div>
                                                    <div>
                                                        <ul class="event-summary-list">
                                                            {% if summaryItems | length %}
                                                                {% for item in summaryItems %}
                                                                    {% if item.text %}
                                                                        <li>
                                                                            <span class="event-summary-icon">{{ item.icon or '‚Ä¢' }}</span>
                                                                            {{ item.text }}
                                                                        </li>
                                                                    {% endif %}
                                                                {% endfor %}
                                                            {% else %}
                                                                {% set lines = message.content.split('\n') %}
                                                                {% for line in lines %}
                                                                    {% if not loop.first %}
                                                                        {% set trimmed = line | trim %}
                                                                        {% if trimmed %}
                                                                            <li>{{ trimmed }}</li>
                                                                        {% endif %}
                                                                    {% endif %}
                                                                {% endfor %}
                                                            {% endif %}
                                                        </ul>
                                                    </div>
                                                    <div class="message-timestamp">{{ (message.timestamp or '') | replace('T', ' ') | replace('Z', '') }}</div>
                                                </div>
                                            {% else %}
                                                <div class="message {{ 'user-message' if message.role == 'user' else 'ai-message' }}">
                                                    <div class="message-sender">
                                                        {% if message.role == 'user' %}
                                                            üë§ You
                                                        {% else %}
                                                            ü§ñ AI Game Master
                                                        {% endif %}
                                                    </div>
                                                    <div>{{ message.content }}</div>
                                                    <div class="message-timestamp">{{ message.timestamp | replace('T', ' ') | replace('Z', '') }}</div>
                                                </div>
                                            {% endif %}
                                        {% endfor %}
                                    {% else %}
                                        <div class="message ai-message">
                                            <div class="message-sender">ü§ñ AI Game Master</div>
                                            <div>Welcome to the AI RPG! I'm your Game Master. Configure your AI settings above and then click the <strong>New Game</strong> link in the upper right.</div>
                                        </div>
                                    {% endif %}
                                </div>

                                <div class="input-area">
                                    <textarea class="message-input" id="messageInput" placeholder="Type your message here..." rows="2"></textarea>
                                    <button class="send-button" id="sendButton">Send</button>
                                </div>
                            </div>

                            <aside class="chat-sidebar" aria-label="Player and party overview">
                                <section class="chat-player-section">
                                    <h3 class="chat-sidebar-heading" id="chatPlayerName">Player</h3>
                                    <div class="chat-player-card" id="chatPlayerCard">
                                        <div class="chat-player-portrait" id="chatPlayerPortrait">
                                            <div class="chat-player-portrait-image" id="chatPlayerPortraitImage">
                                                <div class="chat-player-placeholder" aria-hidden="true">üßô</div>
                                            </div>
                                            <div class="health-bar chat-health-bar" id="chatPlayerHealthBar" aria-hidden="true">
                                                <div class="health-bar-fill chat-health-bar-fill" id="chatPlayerHealthBarFill"></div>
                                            </div>
                                        </div>
                                        <div class="player-need-bars need-bars" id="chatPlayerNeedBars" hidden></div>
                                        <div class="chat-player-actions" id="chatPlayerActions">
                                            <button type="button" class="chat-player-action-button" id="chatPlayerViewButton" disabled>
                                                <span class="chat-player-action-icon" aria-hidden="true">üëÅÔ∏è</span>
                                                <span class="chat-player-action-label">View</span>
                                            </button>
                                            <button type="button" class="chat-player-action-button" id="chatPlayerInventoryButton" disabled>
                                                <span class="chat-player-action-icon" aria-hidden="true">üéí</span>
                                                <span class="chat-player-action-label">Inventory</span>
                                            </button>
                                        </div>
                                        <div class="chat-player-details">
                                            <div class="chat-player-meta">
                                                <span class="chat-player-level" id="chatPlayerLevel">Level ?</span>
                                                <span class="chat-player-archetype" id="chatPlayerArchetype">Class ¬∑ Race</span>
                                            </div>
                                            <div class="chat-player-health" id="chatPlayerHealth">HP: ? / ?</div>
                                            <div class="chat-player-health" id="chatPlayerExperience">Exp: ? / 100</div>
                                            <div class="chat-player-health" id="chatPlayerCurrency">Coins: ?</div>
                                            <p class="chat-player-description" id="chatPlayerDescription">No description available.</p>
                                        </div>
                                    </div>
                                </section>

                                <section class="chat-party-section">
                                    <div class="chat-party-header">
                                        <h3 class="chat-sidebar-heading">Party</h3>
                                        <span class="chat-party-count" id="chatPartyCount">0</span>
                                    </div>
                                    <div class="chat-party-empty" id="chatPartyEmpty">No companions are currently travelling with you.</div>
                                    <div class="location-entity-grid chat-party-grid" id="chatPartyMembers"></div>
                                </section>
                            </aside>
                        </div>
                    </div>
                </section>

                <section class="tab-panel" id="tab-map" role="tabpanel" aria-labelledby="tab-map-tab" hidden>
                    <div class="map-panel">
                        <div class="map-header">
                            <h2 id="mapTitle" class="map-title">Region Map</h2>
                        </div>
                        <div id="mapContainer" class="map-placeholder" aria-live="polite"></div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-character" role="tabpanel" aria-labelledby="tab-character-tab" hidden>
                    <div class="config-content character-panel">
                        <div class="config-section">
                            <h2>Basic Information</h2>
                            <form id="player-stats-form" class="player-stats-form">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label for="player-name">Character Name</label>
                                        <input type="text"
                                               id="player-name"
                                               name="name"
                                               value="{{ player.name if player else '' }}"
                                               placeholder="Enter character name"
                                               required>
                                        <span class="help-text">Your character's name as it appears in the game</span>
                                    </div>

                                    <div class="form-group">
                                        <label for="player-level">Level</label>
                                        <input type="number"
                                               id="player-level"
                                               name="level"
                                               value="{{ player.level if player else 1 }}"
                                               min="1"
                                               required>
                                        <span class="help-text">Character level (1-20)</span>
                                    </div>

                                    <div class="form-group full-width">
                                        <label for="player-description">Description</label>
                                        <textarea id="player-description"
                                                  name="description"
                                                  rows="3"
                                                  placeholder="Describe your character's appearance, personality, and background">{{ player.description if player else '' }}</textarea>
                                        <span class="help-text">A detailed description of your character</span>
                                    </div>
                                </div>
                            </form>
                        </div>

                        <div class="config-section">
                            <h2>Health &amp; Vitality</h2>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label for="player-health">Current Health</label>
                                    <input type="number"
                                           id="player-health"
                                           name="health"
                                           value="{{ player.health if player else 25 }}"
                                           min="0"
                                           max="999"
                                           form="player-stats-form">
                                    <span class="help-text">Current hit points</span>
                                </div>

                                <div class="form-group">
                                    <label>Maximum Health</label>
                                    <div id="player-max-health-display" class="form-static-value">{{ player.maxHealth if player else 'Automatically calculated' }}</div>
                                    <span class="help-text">Calculated automatically from level and health attribute.</span>
                                </div>
                            </div>
                        </div>

                        <div class="config-section">
                            <h2>Primary Attributes</h2>
                            <div class="attributes-grid">
                                {% set attributes = player.attributeInfo if player else {} %}
                                {% set defaultAttributes = [
                                    { key: 'strength', label: 'Strength', abbr: 'STR', description: 'Physical power and muscle' },
                                    { key: 'dexterity', label: 'Dexterity', abbr: 'DEX', description: 'Agility and reflexes' },
                                    { key: 'constitution', label: 'Constitution', abbr: 'CON', description: 'Health and stamina' },
                                    { key: 'intelligence', label: 'Intelligence', abbr: 'INT', description: 'Mental acuity and reasoning' },
                                    { key: 'wisdom', label: 'Wisdom', abbr: 'WIS', description: 'Insight and perception' },
                                    { key: 'charisma', label: 'Charisma', abbr: 'CHA', description: 'Charm and influence' }
                                ] %}

                                {% for attr in defaultAttributes %}
                                <div class="attribute-group">
                                    <div class="attribute-header">
                                        <label for="attr-{{ attr.key }}">{{ attr.label }}</label>
                                        <span class="attribute-abbr">{{ attr.abbr }}</span>
                                    </div>
                                    <div class="attribute-input-group">
                                        <input type="number"
                                               id="attr-{{ attr.key }}"
                                               name="attributes.{{ attr.key }}"
                                               value="{{ attributes[attr.key].value if attributes[attr.key] else 10 }}"
                                               min="3"
                                               max="18"
                                               form="player-stats-form"
                                               class="attribute-input">
                                        <span class="attribute-modifier" data-attr="{{ attr.key }}">
                                            +{{ ((attributes[attr.key].value if attributes[attr.key] else 10) - 10) // 2 }}
                                        </span>
                                    </div>
                                    <span class="help-text">{{ attr.description }}</span>
                                </div>
                                {% endfor %}
                        </div>
                    </div>

                        {% if availableSkills and availableSkills|length %}
                        <div class="config-section">
                            <h2>Skills</h2>
                            <div class="skill-pool-display">
                                <span class="status-label">Unspent Skill Points:</span>
                                <span class="status-value" id="unspentSkillPointsDisplay">{{ player.unspentSkillPoints if player else 0 }}</span>
                            </div>
                            <div class="skills-grid readonly">
                                {% for skill in availableSkills %}
                                {% set skillValue = player.skills[skill.name] if player and player.skills and skill.name in player.skills else 1 %}
                                <div class="skill-card readonly">
                                    <div class="skill-header">
                                        <span class="skill-name">{{ skill.name }}</span>
                                        {% if skill.attribute %}<span class="skill-attribute">{{ skill.attribute }}</span>{% endif %}
                                    </div>
                                    <div class="skill-value">
                                        Rank: <span class="skill-rank" data-skill-name="{{ skill.name }}">{{ skillValue }}</span>
                                        {% if player %}
                                        <button type="button"
                                                class="btn btn-secondary small skill-increase-btn"
                                                data-skill-name="{{ skill.name }}"
                                                aria-label="Increase {{ skill.name }}">
                                            ‚ûï
                                        </button>
                                        {% endif %}
                                    </div>
                                    {% if skill.description %}
                                    <div class="skill-description">{{ skill.description }}</div>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}

                        <div class="config-section" id="abilitiesSection">
                            <h2>Abilities</h2>
                            <div class="abilities-grid" id="abilitiesList">
                                {% if player and player.abilities %}
                                    {% for ability in player.abilities %}
                                        <div class="ability-card ability-type-{{ ability.type | default('Passive') | lower }}">
                                            <div class="ability-header">
                                                <span class="ability-name">{{ ability.name }}</span>
                                                <span class="ability-meta">{{ ability.type | default('Passive') }}{% if ability.level %} ‚Ä¢ Level {{ ability.level }}{% endif %}</span>
                                            </div>
                                            {% if ability.description %}
                                            <div class="ability-description">{{ ability.description }}</div>
                                            {% endif %}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                            <div class="abilities-empty" id="abilitiesEmpty" {% if player and player.abilities and player.abilities|length %}hidden{% endif %}>
                                No special abilities unlocked yet.
                            </div>
                        </div>

                        {% if player %}
                        <div class="config-section">
                            <h2>Current Status</h2>
                            <div class="status-display">
                                <div class="status-item">
                                    <span class="status-label">Alive:</span>
                                    <span class="status-value {{ 'alive' if player.alive else 'dead' }}">
                                        {{ 'Yes' if player.alive else 'No' }}
                                    </span>
                                </div>
                                {% set playerLocationId = player.locationId or player.currentLocation %}
                                {% if playerLocationId %}
                                <div class="status-item">
                                    <span class="status-label">Location:</span>
                                    <span class="status-value">{{ playerLocationId }}</span>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                        {% endif %}

                        <div class="form-actions">
                            <button type="submit" form="player-stats-form" class="btn btn-primary">
                                <span>üíæ</span> Save Character
                            </button>
                            {% if player %}
                            <button type="button" id="reset-stats" class="btn btn-secondary">
                                <span>üîÑ</span> Reset to Defaults
                            </button>
                            {% endif %}
                        </div>

                        <div id="status-message" class="status-message" style="display: none;"></div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-party" role="tabpanel" aria-labelledby="tab-party-tab" hidden>
                    <div class="party-panel">
                        <div class="party-header">
                            <h2>Party Members</h2>
                            <span class="party-count" id="partyCount">0 members</span>
                        </div>
                        <div class="party-grid" id="partyMembers"></div>
                        <div class="party-empty" id="partyEmpty">No companions are currently travelling with you.</div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <div id="locationOverlay" class="overlay-backdrop" aria-live="polite" aria-busy="false" aria-label="Loading location">
        <div class="overlay-content">
            <div class="spinner" role="status" aria-hidden="true"></div>
            <div class="overlay-text" id="locationOverlayText">Exploring...</div>
        </div>
    </div>

    <div id="npcModalBackdrop" class="modal-backdrop" hidden></div>
    <div id="npcInventoryModal" class="modal npc-inventory-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcInventoryModalTitle">Character Inventory</h2>
                <button type="button" class="modal__close" id="npcInventoryCloseBtn" aria-label="Close NPC inventory">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-inventory-body">
                <div class="npc-inventory-header">
                    <h3 id="npcInventoryName">Character</h3>
                    <span class="inventory-count" id="npcInventoryCount">0 items</span>
                </div>
                <div class="npc-inventory-filters">
                    <div class="npc-inventory-filter-top-row">
                        <div class="npc-selection-filter npc-inventory-filter-input-wrapper">
                            <label class="sr-only" for="npcInventoryFilterInput">Filter items</label>
                            <input type="search" id="npcInventoryFilterInput" class="npc-selection-filter-input" placeholder="Filter items" aria-label="Filter items">
                        </div>
                        <div class="npc-inventory-filter-slot-wrapper">
                            <label class="sr-only" for="npcInventorySlotFilter">Filter by slot</label>
                            <select id="npcInventorySlotFilter" class="npc-inventory-slot-filter" aria-label="Filter by slot">
                                <option value="">All slots</option>
                            </select>
                        </div>
                    </div>
                    <div class="npc-inventory-filter-radios">
                        <label class="npc-inventory-filter-radio" for="npcInventoryShowAll">
                            <input type="radio" id="npcInventoryShowAll" name="npcInventoryItemFilter" value="all" checked>
                            <span>Show all</span>
                        </label>
                        <label class="npc-inventory-filter-radio" for="npcInventoryEquippedOnly">
                            <input type="radio" id="npcInventoryEquippedOnly" name="npcInventoryItemFilter" value="equipped">
                            <span>Equipped only</span>
                        </label>
                        <label class="npc-inventory-filter-radio" for="npcInventoryEquippableOnly">
                            <input type="radio" id="npcInventoryEquippableOnly" name="npcInventoryItemFilter" value="equippable">
                            <span>Equippable only</span>
                        </label>
                        <label class="npc-inventory-filter-radio" for="npcInventoryNonEquippableOnly">
                            <input type="radio" id="npcInventoryNonEquippableOnly" name="npcInventoryItemFilter" value="non-equippable">
                            <span>Non-equippable only</span>
                        </label>
                    </div>
                </div>
                <div class="npc-inventory-scroll">
                    <div class="inventory-grid" id="npcInventoryGrid"></div>
                </div>
                <div class="inventory-empty" id="npcInventoryEmpty">Inventory is empty.</div>
            </div>
        </div>
    </div>
    <div id="npcViewModal" class="modal npc-view-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcViewModalTitle">Character Overview</h2>
                <button type="button" class="modal__close" id="npcViewCloseBtn" aria-label="Close character overview">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-view-body">
                <div class="npc-view-summary">
                    <div class="npc-view-image" id="npcViewImage"></div>
                    <div class="npc-view-summary-text">
                        <h3 id="npcViewName">Unknown Character</h3>
                        <p id="npcViewDescription" class="npc-view-description">No description available.</p>
                        <div class="npc-view-tags" id="npcViewTags">
                            <span class="npc-view-tag" id="npcViewClass"></span>
                            <span class="npc-view-tag" id="npcViewRace"></span>
                            <span class="npc-view-tag" id="npcViewLevel"></span>
                        </div>
                        <div class="npc-view-health" id="npcViewHealth"></div>
                        <div class="npc-view-meta" id="npcViewCurrency" hidden></div>
                        <div class="npc-view-meta" id="npcViewExperience" hidden></div>
                    </div>
                </div>
                <div class="npc-view-sections">
                    <section class="npc-view-section" id="npcViewAttributesSection">
                        <h4>Attributes</h4>
                        <dl class="npc-view-attributes" id="npcViewAttributes"></dl>
                        <div class="npc-view-empty" id="npcViewAttributesEmpty">No attribute data available.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewEquipmentSection">
                        <h4>Equipment</h4>
                        <dl class="npc-view-equipment" id="npcViewEquipment"></dl>
                        <div class="npc-view-empty" id="npcViewEquipmentEmpty">No equipment equipped.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewSkillsSection">
                        <h4>Skills</h4>
                        <div class="npc-view-skills" id="npcViewSkills"></div>
                        <div class="npc-view-empty" id="npcViewSkillsEmpty">No skill data available.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewAbilitiesSection">
                        <h4>Abilities</h4>
                        <ul class="npc-view-list" id="npcViewAbilities"></ul>
                        <div class="npc-view-empty" id="npcViewAbilitiesEmpty">No abilities listed.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewStatusSection">
                        <h4>Status Effects</h4>
                        <ul class="npc-view-list" id="npcViewStatuses"></ul>
                        <div class="npc-view-empty" id="npcViewStatusesEmpty">No active status effects.</div>
                    </section>
                </div>
                <details class="npc-view-dispositions" id="npcViewDispositions" hidden>
                    <summary>Dispositions</summary>
                    <div class="npc-view-disposition-list" id="npcViewDispositionsList"></div>
                </details>
            </div>
        </div>
    </div>
    <div id="npcDispositionModal" class="modal npc-disposition-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcDispositionModalTitle">Adjust Dispositions</h2>
                <button type="button" class="modal__close" id="npcDispositionCloseBtn" aria-label="Close disposition editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="npcDispositionForm" class="modal__body npc-disposition-body" novalidate>
                <div class="npc-disposition-summary" id="npcDispositionSummary"></div>
                <div class="npc-disposition-loading" id="npcDispositionLoading" hidden>Loading dispositions‚Ä¶</div>
                <div class="npc-disposition-list" id="npcDispositionList">
                    <div class="npc-disposition-empty" id="npcDispositionEmpty">No disposition data available.</div>
                </div>
                <footer class="npc-disposition-footer">
                    <div class="npc-disposition-status" id="npcDispositionStatus" role="status" aria-live="polite"></div>
                    <div class="npc-disposition-actions">
                        <button type="button" class="npc-disposition-cancel" id="npcDispositionCancelBtn">Cancel</button>
                        <button type="submit" class="npc-disposition-save-btn" id="npcDispositionSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>
    <div id="npcNeedsModal" class="modal npc-needs-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcNeedsModalTitle">Adjust Needs</h2>
                <button type="button" class="modal__close" id="npcNeedsCloseBtn" aria-label="Close needs editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="npcNeedsForm" class="modal__body npc-needs-body" novalidate>
                <div class="npc-needs-summary" id="npcNeedsSummary"></div>
                <div class="npc-needs-loading" id="npcNeedsLoading" hidden>Loading needs‚Ä¶</div>
                <div class="npc-needs-list" id="npcNeedsList">
                    <div class="npc-needs-empty" id="npcNeedsEmpty">No need bars available.</div>
                </div>
                <footer class="npc-needs-footer">
                    <div class="npc-needs-status" id="npcNeedsStatus" role="status" aria-live="polite"></div>
                    <div class="npc-needs-actions">
                        <button type="button" class="npc-needs-cancel" id="npcNeedsCancelBtn">Cancel</button>
                        <button type="submit" class="npc-needs-save-btn" id="npcNeedsSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>
    <div id="npcMemoriesModal" class="modal npc-memories-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcMemoriesModalTitle">Edit Memories</h2>
                <button type="button" class="modal__close" id="npcMemoriesCloseBtn" aria-label="Close memories editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-memories-body">
                <p class="npc-memories-help">Update the character's important memories. Drag the handle to reorder entries.</p>
                <div id="npcMemoriesList" class="npc-memories-list" role="list"></div>
                <button type="button" class="npc-memories-add" id="npcMemoriesAddBtn">Add Memory</button>
            </div>
            <footer class="modal__footer npc-memories-footer">
                <div id="npcMemoriesStatus" class="npc-memories-status" role="status" aria-live="polite"></div>
                <div class="npc-memories-actions">
                    <button type="button" class="npc-memories-cancel" id="npcMemoriesCancelBtn">Cancel</button>
                    <button type="button" class="npc-memories-save" id="npcMemoriesSaveBtn">Save</button>
                </div>
            </footer>
        </div>
    </div>
    <div id="npcGoalsModal" class="modal npc-goals-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcGoalsModalTitle">Edit Goals</h2>
                <button type="button" class="modal__close" id="npcGoalsCloseBtn" aria-label="Close goals editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-goals-body">
                <p class="npc-goals-help">Update the character's active goals. Drag the handle to reorder entries.</p>
                <div id="npcGoalsList" class="npc-goals-list" role="list"></div>
                <button type="button" class="npc-goals-add" id="npcGoalsAddBtn">Add Goal</button>
            </div>
            <footer class="modal__footer npc-goals-footer">
                <div id="npcGoalsStatus" class="npc-goals-status" role="status" aria-live="polite"></div>
                <div class="npc-goals-actions">
                    <button type="button" class="npc-goals-cancel" id="npcGoalsCancelBtn">Cancel</button>
                    <button type="button" class="npc-goals-save" id="npcGoalsSaveBtn">Save</button>
                </div>
            </footer>
        </div>
    </div>
    <div id="addNpcModal" class="modal add-npc-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="addNpcModalTitle">Add NPC</h2>
                <button type="button" class="modal__close" id="addNpcCloseBtn" aria-label="Close new NPC dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="addNpcForm" class="modal__body npc-edit-form add-npc-body" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="addNpcName">Name</label>
                        <input type="text" id="addNpcName" name="name" maxlength="120" autocomplete="off">
                    </div>
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="addNpcShortDescription">Short Description</label>
                        <input type="text" id="addNpcShortDescription" name="shortDescription" maxlength="140" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcRole">Role</label>
                        <input type="text" id="addNpcRole" name="role" maxlength="80" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcClass">Class</label>
                        <input type="text" id="addNpcClass" name="class" maxlength="80" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcRace">Race</label>
                        <input type="text" id="addNpcRace" name="race" maxlength="80" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcLevel">Level</label>
                        <input type="number" id="addNpcLevel" name="level" min="1" max="100" step="1" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcCurrency">Currency</label>
                        <input type="number" id="addNpcCurrency" name="currency" min="0" step="1" autocomplete="off">
                    </div>
                </div>
                <div class="npc-edit-section">
                    <label for="addNpcDescription">Description</label>
                    <textarea id="addNpcDescription" name="description" rows="4" placeholder="Optional: Describe appearance, personality, goals..."></textarea>
                </div>
                <footer class="npc-edit-footer">
                    <div class="npc-edit-status" id="addNpcStatus" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="addNpcCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="addNpcSaveBtn">Generate NPC</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="loadGameModal" class="modal load-game-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="loadGameModalTitle">Load Game</h2>
                <button type="button" class="modal__close" id="loadGameCloseBtn" aria-label="Close load game dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body load-game-body">
                <div class="load-game-source-control">
                    <label for="loadGameSourceSelect" class="load-game-label">Save type</label>
                    <select id="loadGameSourceSelect" class="load-game-source-select" aria-label="Select save list">
                        <option value="saves">Manual saves</option>
                        <option value="autosaves">Autosaves</option>
                    </select>
                </div>
                <label for="loadGameSelect" class="load-game-label">Choose a game</label>
                <select id="loadGameSelect" class="load-game-select" size="6" aria-describedby="loadGameStatus"></select>
                <div id="loadGameStatus" class="load-game-status" role="status" aria-live="polite"></div>
            </div>
            <div class="modal__actions load-game-actions">
                <button type="button" class="button button-secondary" id="loadGameCancelBtn">Cancel</button>
                <button type="button" class="button button-primary" id="loadGameConfirmBtn">Load Game</button>
            </div>
        </div>
    </div>
    <div id="newExitModal" class="modal new-exit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="newExitModalTitle">Add New Exit</h2>
                <button type="button" class="modal__close" id="newExitCloseBtn" aria-label="Close new exit dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="newExitForm" class="modal__body new-exit-body" novalidate>
                <div class="new-exit-field">
                    <label for="newExitRegion">Region</label>
                    <select id="newExitRegion" name="regionId">
                        <option value="">Create new region</option>
                    </select>
                </div>
                <div class="new-exit-field" id="newExitLocationGroup" hidden>
                    <label for="newExitLocation">Location</label>
                    <select id="newExitLocation" name="locationId">
                        <option value="">Create new location</option>
                    </select>
                </div>
                <div class="new-exit-field" id="newExitNameGroup">
                    <label for="newExitName">Exit Name</label>
                    <input type="text" id="newExitName" name="name" maxlength="120">
                </div>
                <div class="new-exit-field" id="newExitDescriptionGroup">
                    <label for="newExitDescription">Description</label>
                    <textarea id="newExitDescription" name="description" rows="3" placeholder="Optional: Describe what lies beyond this exit..."></textarea>
                </div>
                <div class="new-exit-field" id="newExitVehicleGroup">
                    <label for="newExitVehicle">Vehicle</label>
                    <input type="text" id="newExitVehicle" name="vehicle" placeholder="Optional: e.g. shuttle, portal, elevator">
                </div>
                <div class="new-exit-field new-exit-field--checkbox" id="newExitChildRegionGroup" hidden>
                    <label class="modal-checkbox" for="newExitChildRegion">
                        <input type="checkbox" id="newExitChildRegion" name="childRegion">
                        <span>This region should inherit from the current region</span>
                    </label>
                    <p class="modal-checkbox-hint">When enabled, the new region stub is created as a child of your current region.</p>
                </div>
                <footer class="new-exit-footer">
                    <div class="new-exit-status" id="newExitStatus" role="status" aria-live="polite"></div>
                    <div class="new-exit-actions">
                        <button type="button" class="new-exit-cancel" id="newExitCancelBtn">Cancel</button>
                        <button type="submit" class="new-exit-save" id="newExitSaveBtn">Create Exit</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>
    <div id="npcEditModal" class="modal npc-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcEditModalTitle">Edit NPC</h2>
                <button type="button" class="modal__close" id="npcEditCloseBtn" aria-label="Close NPC editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="npcEditForm" class="modal__body" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field">
                        <label for="npcEditId">Character ID</label>
                        <input id="npcEditId" type="text" readonly>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditName">Name</label>
                        <input id="npcEditName" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="npcEditShortDescription">Short Description</label>
                        <input id="npcEditShortDescription" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditRace">Race</label>
                        <input id="npcEditRace" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditClass">Class</label>
                        <input id="npcEditClass" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditLevel">Level</label>
                        <input id="npcEditLevel" type="number" min="1" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditHealth">Health</label>
                        <input id="npcEditHealth" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditHealthAttribute">Health Bonus Attribute</label>
                        <select id="npcEditHealthAttribute"></select>
                    </div>
                    <div class="npc-edit-field npc-edit-field--readonly">
                        <label for="npcEditMaxHealth">Max Health</label>
                        <div id="npcEditMaxHealth" class="npc-edit-readonly-value">‚Äî</div>
                        <span class="npc-edit-help-text">Calculated automatically</span>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditUnspent">Unspent Skill Points</label>
                        <input id="npcEditUnspent" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditCurrency">Currency</label>
                        <input id="npcEditCurrency" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditExperience">Experience</label>
                        <input id="npcEditExperience" type="number" min="0" step="1">
                    </div>
                </div>

                <div class="npc-edit-section">
                    <label for="npcEditDescription">Description</label>
                    <textarea id="npcEditDescription" rows="4"></textarea>
                </div>

                <div class="npc-edit-section">
                    <h3>Personality</h3>
                    <div class="npc-edit-grid">
                        <div class="npc-edit-field">
                            <label for="npcEditPersonalityType">Type</label>
                            <input id="npcEditPersonalityType" type="text" autocomplete="off">
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="npcEditPersonalityTraits">Traits</label>
                            <textarea id="npcEditPersonalityTraits" rows="2"></textarea>
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="npcEditPersonalityNotes">Notes</label>
                            <textarea id="npcEditPersonalityNotes" rows="3"></textarea>
                        </div>
                    </div>
                </div>

                <div class="npc-edit-section">
                    <h3>Attributes</h3>
                    <div id="npcEditAttributes" class="npc-attribute-grid"></div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Skills</h3>
                        <button type="button" class="npc-edit-add-btn" id="npcAddSkillBtn">Add Skill</button>
                    </div>
                    <div id="npcEditSkills" class="npc-skill-list"></div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Abilities</h3>
                        <button type="button" class="npc-edit-add-btn" id="npcAddAbilityBtn">Add Ability</button>
                    </div>
                    <div id="npcEditAbilities" class="npc-ability-list"></div>
                </div>

                <div class="npc-edit-footer">
                    <div id="npcEditStatus" class="npc-edit-status" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="npcEditCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="npcEditSaveBtn">Save Changes</button>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <div id="thingEditModal" class="modal thing-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="thingEditModalTitle">Edit Item</h2>
                <button type="button" class="modal__close" id="thingEditCloseBtn" aria-label="Close item editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="thingEditForm" class="modal__body npc-edit-form" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field">
                        <label for="thingEditId">Item ID</label>
                        <input id="thingEditId" type="text" readonly>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditName">Name</label>
                        <input id="thingEditName" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditType">Type</label>
                        <select id="thingEditType">
                            <option value="item">Item</option>
                            <option value="scenery">Scenery</option>
                        </select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditRarity">Rarity</label>
                        <select id="thingEditRarity"></select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditItemDetail">Item Detail</label>
                        <input id="thingEditItemDetail" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditSlot">Slot</label>
                        <select id="thingEditSlot"></select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditLevel">Level</label>
                        <input id="thingEditLevel" type="number" min="1" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditImageId">Image ID</label>
                        <input id="thingEditImageId" type="text" autocomplete="off">
                    </div>
                </div>

                <div class="npc-edit-section">
                    <label for="thingEditDescription">Description</label>
                    <textarea id="thingEditDescription" rows="4"></textarea>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Metadata</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingMetadataAddBtn">Add Entry</button>
                    </div>
                    <div id="thingEditMetadataList" class="thing-edit-metadata-list"></div>
                    <p class="npc-edit-hint">Use metadata for additional properties like value, weight, or lore tags.</p>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Attribute Bonuses</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingAttributeBonusAddBtn">Add Bonus</button>
                    </div>
                    <div id="thingEditAttributeBonusesList" class="thing-edit-bonus-list"></div>
                </div>

                <div class="npc-edit-section">
                    <h3>On-Hit Status Effect</h3>
                    <div class="thing-edit-cause-effect">
                        <div class="npc-edit-field">
                            <label for="thingEditCauseStatusEffectName">Name</label>
                            <input id="thingEditCauseStatusEffectName" type="text" autocomplete="off">
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="thingEditCauseStatusEffectDescription">Description</label>
                            <textarea id="thingEditCauseStatusEffectDescription" rows="2"></textarea>
                        </div>
                        <div class="npc-edit-field">
                            <label for="thingEditCauseStatusEffectDuration">Duration</label>
                            <input id="thingEditCauseStatusEffectDuration" type="text" autocomplete="off" placeholder="e.g. 3 or permanent">
                        </div>
                    </div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Status Effects</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingStatusEffectAddBtn">Add Effect</button>
                    </div>
                    <div id="thingEditStatusEffectsList" class="thing-edit-status-effects"></div>
                </div>

                <div class="npc-edit-footer">
                    <div id="thingEditStatus" class="npc-edit-status" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="thingEditCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="thingEditSaveBtn">Save Changes</button>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <div id="inventoryTooltip" class="inventory-floating-tooltip" hidden></div>
    <div id="partyTooltip" class="inventory-floating-tooltip party-floating-tooltip" hidden></div>

    <div id="locationEditModal" class="modal location-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="locationEditModalTitle">Edit Location</h2>
                <button type="button" class="modal__close" id="locationEditCloseBtn" aria-label="Close location editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="locationEditForm" class="modal__body location-edit-form" novalidate>
                <div class="location-edit-field">
                    <label for="locationEditName">Location Name</label>
                    <input type="text" id="locationEditName" name="name" maxlength="160" autocomplete="off">
                </div>
                <div class="location-edit-field">
                    <label for="locationEditDescription">Description</label>
                    <textarea id="locationEditDescription" name="description" rows="6" required></textarea>
                </div>
                <div class="location-edit-field">
                    <label for="locationEditLevel">Level</label>
                    <input type="number" id="locationEditLevel" name="level" min="1" max="99" step="1" required>
                </div>
                <div class="location-edit-field location-edit-field--static">
                    <span class="location-edit-label">Absolute Level</span>
                    <span id="locationEditAbsoluteLevel" class="location-edit-value">‚Äî</span>
                </div>
                <footer class="location-edit-footer">
                    <div class="location-edit-status" id="locationEditStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel" id="locationEditCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save" id="locationEditSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="regionEditModal" class="modal region-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="regionEditModalTitle">Edit Region</h2>
                <button type="button" class="modal__close" id="regionEditCloseBtn" aria-label="Close region editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="regionEditForm" class="modal__body location-edit-form region-edit-form" novalidate>
                <div class="location-edit-field">
                    <label for="regionEditName">Region Name</label>
                    <input type="text" id="regionEditName" name="name" maxlength="160" required>
                </div>
                <div class="location-edit-field">
                    <label for="regionEditDescription">Description</label>
                    <textarea id="regionEditDescription" name="description" rows="6" required></textarea>
                </div>
                <div class="location-edit-field">
                    <label for="regionEditParent">Parent Region</label>
                    <select id="regionEditParent" name="parentRegionId">
                        <option value="">None</option>
                    </select>
                </div>
                <div class="location-edit-field">
                    <label for="regionEditAverageLevel">Average Level</label>
                    <input type="number" id="regionEditAverageLevel" name="averageLevel" min="1" step="1" required>
                </div>
                <footer class="location-edit-footer region-edit-footer">
                    <div class="location-edit-status region-edit-status" id="regionEditStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel region-edit-cancel" id="regionEditCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save region-edit-save" id="regionEditSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="summonNpcModal" class="modal summon-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="summonNpcModalTitle">Summon NPC</h2>
                <button type="button" class="modal__close" id="summonNpcCloseBtn" aria-label="Close summon NPC dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="summonNpcForm" class="modal__body location-edit-form summon-modal-form" novalidate>
                <div class="location-edit-field">
                    <label for="summonNpcSelect">Select NPC</label>
                    <select id="summonNpcSelect" name="npcId" required disabled>
                        <option value="" disabled selected hidden>Select an NPC</option>
                    </select>
                </div>
                <footer class="location-edit-footer">
                    <div class="location-edit-status" id="summonNpcStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel" id="summonNpcCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save" id="summonNpcConfirmBtn" disabled>Summon</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="summonThingModal" class="modal summon-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="summonThingModalTitle">Summon Item or Scenery</h2>
                <button type="button" class="modal__close" id="summonThingCloseBtn" aria-label="Close summon item dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="summonThingForm" class="modal__body location-edit-form summon-modal-form" novalidate>
                <div class="location-edit-field">
                    <label for="summonThingSelect">Select Item or Scenery</label>
                    <select id="summonThingSelect" name="thingId" required disabled>
                        <option value="" disabled selected hidden>Select an item</option>
                    </select>
                </div>
                <footer class="location-edit-footer">
                    <div class="location-edit-status" id="summonThingStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel" id="summonThingCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save" id="summonThingConfirmBtn" disabled>Summon</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="imageLightbox" class="image-lightbox" hidden aria-hidden="true" tabindex="-1">
        <div class="image-lightbox__inner" role="dialog" aria-modal="true" aria-labelledby="imageLightboxCaption">
            <img id="imageLightboxImage" class="image-lightbox__image" alt="" src="" loading="lazy">
            <div id="imageLightboxCaption" class="image-lightbox__caption" hidden></div>
        </div>
    </div>

    <script src="/vendor/fitty.min.js"></script>
    <script src="/js/fitty-init.js"></script>
    <script src="/vendor/cytoscape.min.js"></script>
    <script src="/vendor/layout-base.js"></script>
    <script src="/vendor/cose-base.js"></script>
    <script src="/vendor/cytoscape-fcose.js"></script>
    <script src="/js/lightbox.js"></script>
    <script src="/js/image-manager.js"></script>
    <script src="/js/currency-utils.js"></script>
    <script src="/vendor/nunjucks.js"></script>
    <script src="/vendor/markdown-it.min.js"></script>
    <script src="/js/chat.js"></script>
    <script defer src="/js/map.js"></script>
    <script defer src="/js/player-stats.js"></script>
    <script>
        window.currentSetting = {{ (currentSetting or {}) | dump | safe }};
        window.rarityDefinitions = {{ (rarityDefinitions or []) | dump | safe }};
        window.CHECK_MOVE_PLAUSIBILITY = {{ (checkMovePlausibility or 'never') | dump | safe }};
        window.availableSkillsList = {{ (availableSkills or []) | dump | safe }};
        const __knownSkillNameSet = new Set(
            (Array.isArray(window.availableSkillsList) ? window.availableSkillsList : [])
                .map(skill => {
                    if (!skill || typeof skill.name !== 'string') {
                        return null;
                    }
                    const trimmed = skill.name.trim();
                    return trimmed ? trimmed.toLowerCase() : null;
                })
                .filter(Boolean)
        );
        window.getKnownSkillNameSet = function () {
            return __knownSkillNameSet;
        };
        // Initialize with system prompt from server
        async function fetchLocationImageGenerationFlag() {
            try {
                const response = await fetch('/api/features/location-image-generation', { cache: 'no-store' });
                if (!response.ok) {
                    return;
                }
                const data = await response.json().catch(() => null);
                if (data && typeof data.enabled === 'boolean') {
                    locationImageGenerationEnabled = data.enabled;
                    window.locationImageGenerationEnabled = locationImageGenerationEnabled;
                }
            } catch (error) {
                console.warn('Failed to load location image generation flag:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            //window.systemPrompt = {{ systemPrompt | dump | safe }};
            window.locationImageGenerationEnabled = locationImageGenerationEnabled;
            await fetchLocationImageGenerationFlag();

            new AIRPGChat();
            
            // Add save/load functionality
            initSaveLoadButtons();
            
            // Initialize tabs
            initTabs();

            initFloatingTooltipController();
            // Initialize location display
            initLocationDisplay();
            initPlayerOverviewSync();
            initPartyDisplay();
        });

        function bindLightboxElement(element, dataProvider) {
            if (!element || !window.lightboxController) {
                return;
            }

            try {
                window.lightboxController.bind(element, dataProvider);
            } catch (error) {
                console.warn('Failed to bind lightbox:', error);
            }
        }

        const escapeHtml = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        };

        const tokenizeForMatch = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            const normalized = String(value)
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, ' ')
                .replace(/\s+/g, ' ');
            return normalized ? ` ${normalized} ` : '';
        };

        const runtimeConfig = (() => {
            if (window.__AIRPG_CONFIG__ && typeof window.__AIRPG_CONFIG__ === 'object') {
                return window.__AIRPG_CONFIG__;
            }
            if (window.AIRPG_CONFIG && typeof window.AIRPG_CONFIG === 'object') {
                return window.AIRPG_CONFIG;
            }
            if (window.AIRPG && typeof window.AIRPG.config === 'object') {
                return window.AIRPG.config;
            }
            if (window.config && typeof window.config === 'object') {
                return window.config;
            }
            return {};
        })();

        function renderEntityImage({
            element,
            entityType,
            entityId,
            imageId,
            altText,
            placeholderIcon = 'üñºÔ∏è',
            placeholderClass = 'image-placeholder',
            placeholderMarkup = null,
            enableLightbox = true,
            force = false
        }) {
            if (!element) {
                return Promise.resolve(null);
            }

            const safeAltText = escapeHtml(altText || '');
            const computedPlaceholderMarkup = placeholderMarkup !== null
                ? placeholderMarkup
                : `<div class="${placeholderClass}">${placeholderIcon}</div>`;

            const applyImageMarkup = (url) => {
                if (!url) {
                    element.innerHTML = computedPlaceholderMarkup;
                    return;
                }

                element.innerHTML = `<img src="${url}" alt="${safeAltText}" loading="lazy" onerror="this.parentElement.innerHTML='<div class=\\'${placeholderClass}\\' role=\\'img\\'>${placeholderIcon}</div>'">`;
                const img = element.querySelector('img');
                if (img && enableLightbox) {
                    img.dataset.lightboxImage = img.src;
                    img.dataset.lightboxAlt = altText || safeAltText || 'Image';
                    img.dataset.lightboxCaption = altText || '';
                    bindLightboxElement(img);
                }
            };

            const setPlaceholder = () => {
                element.innerHTML = computedPlaceholderMarkup;
            };

            element.dataset.imageEntityType = entityType || '';
            element.dataset.imageEntityId = entityId || '';
            element.dataset.imagePlaceholder = placeholderIcon || 'üñºÔ∏è';
            element.dataset.imagePlaceholderClass = placeholderClass || 'image-placeholder';
            if (placeholderMarkup !== null && placeholderMarkup !== undefined) {
                element.dataset.imagePlaceholderMarkup = placeholderMarkup;
            } else {
                delete element.dataset.imagePlaceholderMarkup;
            }
            element.dataset.imageAlt = altText || '';
            element.dataset.imageLightbox = enableLightbox ? 'true' : 'false';
            element.dataset.imageAuto = 'true';
            if (force) {
                element.dataset.imageForce = 'true';
            } else {
                delete element.dataset.imageForce;
            }

            element.dataset.imageProcessing = 'true';

            if (imageId) {
                element.dataset.imageId = imageId;
                applyImageMarkup(`/generated-images/${imageId}.png`);
            } else {
                delete element.dataset.imageId;
                setPlaceholder();
            }

            const finalize = (result) => {
                delete element.dataset.imageProcessing;
                element.dataset.imageInitialized = 'true';
                return result;
            };

            const manager = window.AIRPG?.imageManager;
            if (!manager || !entityType || !entityId) {
                return Promise.resolve(finalize(null));
            }

            return manager.ensureImage({
                entityType,
                entityId,
                existingImageId: imageId || null,
                force: Boolean(force)
            }).then(result => {
                if (result?.imageId) {
                    element.dataset.imageId = result.imageId;
                }

                const imageUrl = result?.imageUrl || (result?.imageId ? `/generated-images/${result.imageId}.png` : null);
                if (imageUrl) {
                    applyImageMarkup(imageUrl);
                } else if (!result?.skipped) {
                    setPlaceholder();
                }

                return finalize(result || null);
            }).catch(error => {
                console.warn(`Image generation failed for ${entityType} ${entityId}:`, error?.message || error);
                element.innerHTML = `<div class="${placeholderClass} error">${placeholderIcon}</div>`;
                return finalize(null);
            });
        }

        window.renderEntityImage = renderEntityImage;

        function getEntityImageElements(entityType, entityId) {
            const targetType = typeof entityType === 'string' ? entityType.trim() : '';
            const targetId = typeof entityId === 'string' ? entityId.trim() : '';
            if (!targetType || !targetId) {
                return [];
            }
            const all = Array.from(document.querySelectorAll('[data-image-entity-type]'));
            return all.filter(element => {
                const dataset = element?.dataset || {};
                return dataset.imageEntityType === targetType && dataset.imageEntityId === targetId;
            });
        }

        function setEntityImagePlaceholder(element) {
            if (!element) {
                return;
            }
            const dataset = element.dataset || {};
            const placeholderMarkup = dataset.imagePlaceholderMarkup;
            if (placeholderMarkup) {
                element.innerHTML = placeholderMarkup;
            } else {
                const placeholderIcon = dataset.imagePlaceholder || 'üñºÔ∏è';
                const placeholderClass = dataset.imagePlaceholderClass || 'image-placeholder';
                element.innerHTML = `<div class="${placeholderClass}">${placeholderIcon}</div>`;
            }
            element.dataset.imageId = '';
            element.dataset.imageProcessing = 'true';
        }

        function applyEntityImagePlaceholder(entityType, entityId) {
            const elements = getEntityImageElements(entityType, String(entityId || ''));
            elements.forEach(setEntityImagePlaceholder);
            return elements;
        }

        function renderEntityImages(entityType, entityId, options = {}) {
            const elements = getEntityImageElements(entityType, String(entityId || ''));
            return elements.map(element => {
                const dataset = element.dataset || {};
                const altText = options.altText ?? dataset.imageAlt ?? '';
                const placeholderIcon = options.placeholderIcon ?? dataset.imagePlaceholder ?? 'üñºÔ∏è';
                const placeholderClass = options.placeholderClass ?? dataset.imagePlaceholderClass ?? 'image-placeholder';
                const hasPlaceholderOption = Object.prototype.hasOwnProperty.call(options, 'placeholderMarkup');
                const placeholderMarkup = hasPlaceholderOption
                    ? options.placeholderMarkup
                    : (dataset.imagePlaceholderMarkup ? dataset.imagePlaceholderMarkup : null);
                const enableLightbox = options.enableLightbox ?? (dataset.imageLightbox !== 'false');
                const force = options.force ?? false;
                const hasImageIdOption = Object.prototype.hasOwnProperty.call(options, 'imageId');
                const imageId = hasImageIdOption ? options.imageId : (dataset.imageId || null);

                return renderEntityImage({
                    element,
                    entityType,
                    entityId,
                    imageId: imageId || null,
                    altText,
                    placeholderIcon,
                    placeholderClass,
                    placeholderMarkup,
                    enableLightbox,
                    force
                });
            });
        }

        const adventureBackgroundElement = document.getElementById('adventureBackground');
        function updateAdventureBackground(imageUrl) {
            if (!adventureBackgroundElement) {
                return;
            }
            if (imageUrl) {
                adventureBackgroundElement.style.setProperty('--adventure-bg-image', `url("${imageUrl}")`);
                adventureBackgroundElement.classList.add('has-image');
            } else {
                adventureBackgroundElement.style.removeProperty('--adventure-bg-image');
                adventureBackgroundElement.classList.remove('has-image');
            }
        }

        function createHealthBar(additionalClassNames = '') {
            const bar = document.createElement('div');
            bar.className = ['health-bar', additionalClassNames].filter(Boolean).join(' ');
            bar.setAttribute('aria-hidden', 'true');

            const fill = document.createElement('div');
            fill.className = 'health-bar-fill';
            bar.appendChild(fill);

            return { bar, fill };
        }

        function applyNpcDeathStyling(card, portrait, npc) {
            if (!card || !portrait) {
                return;
            }

            const existingIndicator = portrait.querySelector('.npc-death-indicator');
            existingIndicator?.remove();

            const isDead = Boolean(npc?.isDead);
            card.classList.toggle('is-dead', isDead);

            if (!isDead) {
                return;
            }

            const indicator = document.createElement('div');
            indicator.className = 'npc-death-indicator';

            const icon = document.createElement('span');
            icon.className = 'npc-death-indicator__icon';
            icon.textContent = 'üíÄ';
            indicator.appendChild(icon);

            if (Number.isFinite(npc?.corpseCountdown)) {
                const countdown = document.createElement('span');
                countdown.className = 'npc-death-indicator__countdown';
                countdown.textContent = String(Math.max(0, npc.corpseCountdown));
                indicator.appendChild(countdown);
            }

            portrait.appendChild(indicator);
        }

        function escapeForSelector(value) {
            if (value === null || value === undefined) {
                return '';
            }
            if (window.CSS && typeof window.CSS.escape === 'function') {
                return window.CSS.escape(String(value));
            }
            return String(value).replace(/(["'\\])/g, '\\$1');
        }

        function updateNpcCorpseVisuals(updates = []) {
            if (!Array.isArray(updates) || !updates.length) {
                return;
            }

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            updates.forEach(entry => {
                if (!entry || !entry.npcId) {
                    return;
                }
                const npcId = entry.npcId;
                const countdown = Number.isFinite(entry.corpseCountdown) ? entry.corpseCountdown : entry.corpseCountdown ?? null;

                const cached = npcDataCache.get(npcId) || { id: npcId };
                cached.corpseCountdown = countdown;
                if (countdown !== null) {
                    cached.isDead = true;
                }
                npcDataCache.set(npcId, cached);

                const selector = `[data-npc-id="${escapeForSelector(npcId)}"]`;
                document.querySelectorAll(`.location-entity-card.is-npc${selector}`).forEach(card => {
                    const portrait = card.querySelector('.location-entity-icon');
                    applyNpcDeathStyling(card, portrait, cached);
                });
                document.querySelectorAll(`.party-card${selector}`).forEach(card => {
                    const portrait = card.querySelector('.location-entity-icon');
                    applyNpcDeathStyling(card, portrait, cached);
                });
            });
        }

        function removeNpcCards(removals = []) {
            if (!Array.isArray(removals) || !removals.length) {
                return;
            }

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            removals.forEach(entry => {
                if (!entry || !entry.npcId) {
                    return;
                }
                const npcId = entry.npcId;
                npcDataCache.delete(npcId);

                const selector = `[data-npc-id="${escapeForSelector(npcId)}"]`;
                document.querySelectorAll(`.location-entity-card.is-npc${selector}`).forEach(card => card.remove());
                document.querySelectorAll(`.party-card${selector}`).forEach(card => card.remove());
            });
        }

        function updateHealthBar(barElement, fillElement, currentValue, maxValue) {
            if (!barElement || !fillElement) {
                return;
            }

            if (!barElement.hasAttribute('role')) {
                barElement.setAttribute('role', 'progressbar');
                barElement.setAttribute('aria-valuemin', '0');
            }

            const current = Number.isFinite(Number(currentValue))
                ? Math.max(0, Number(currentValue))
                : null;
            const maxRaw = Number.isFinite(Number(maxValue))
                ? Math.max(0, Number(maxValue))
                : null;
            const max = maxRaw && maxRaw > 0 ? maxRaw : null;

            if (current === null) {
                fillElement.style.width = '0%';
                barElement.setAttribute('aria-hidden', 'true');
                barElement.removeAttribute('aria-valuenow');
                barElement.removeAttribute('aria-valuemax');
                barElement.removeAttribute('title');
                return;
            }

            const ratio = max ? current / max : (current > 0 ? 1 : 0);
            const clampedRatio = Math.max(0, Math.min(1, ratio));
            fillElement.style.width = `${(clampedRatio * 100).toFixed(1)}%`;

            barElement.setAttribute('aria-hidden', 'false');
            barElement.setAttribute('aria-valuenow', String(current));
            barElement.setAttribute('aria-valuemax', String(max || Math.max(current, 1)));
            barElement.setAttribute('title', max ? `Health: ${current} / ${max}` : `Health: ${current}`);
        }

        function renderNeedBars(container, bars = [], options = {}) {
            if (!container) {
                return;
            }

            const {
                showIcon = false,
                includePlayerOnly = false,
                variant = 'default',
                compact = false,
                iconFallback = ''
            } = options;

            const barsArray = Array.isArray(bars) ? bars : [];
            const filtered = includePlayerOnly ? barsArray : barsArray.filter(bar => !bar?.playerOnly);

            container.innerHTML = '';

            if (!filtered.length) {
                container.setAttribute('hidden', '');
                container.style.display = 'none';
                return;
            }

            container.removeAttribute('hidden');
            container.style.display = '';

            filtered.forEach(bar => {
                if (!bar) {
                    return;
                }

                const wrapper = document.createElement('div');
                wrapper.className = 'need-bar';
                if (variant) {
                    wrapper.classList.add(`need-bar--${variant}`);
                }
                if (compact) {
                    wrapper.classList.add('need-bar--compact');
                }
                wrapper.dataset.barId = bar.id || '';

                const min = Number.isFinite(Number(bar.min)) ? Number(bar.min) : 0;
                const max = Number.isFinite(Number(bar.max)) ? Number(bar.max) : 100;
                const value = Number.isFinite(Number(bar.value)) ? Number(bar.value) : min;
                const clamped = Math.max(min, Math.min(max, value));
                const denominator = max > min ? max - min : 1;
                const ratio = denominator ? (clamped - min) / denominator : 1;

                wrapper.setAttribute('role', 'progressbar');
                wrapper.setAttribute('aria-valuemin', String(min));
                wrapper.setAttribute('aria-valuemax', String(max));
                wrapper.setAttribute('aria-valuenow', String(Math.round(clamped)));
                wrapper.setAttribute('title', `${bar.name || bar.id || 'Need'}: ${Math.round(clamped)} / ${Math.round(max)}`);

                if (showIcon) {
                    const iconChar = (typeof bar.icon === 'string' && bar.icon.trim()) ? bar.icon.trim() : iconFallback;
                    if (iconChar) {
                        const iconSpan = document.createElement('span');
                        iconSpan.className = 'need-bar-icon';
                        iconSpan.textContent = iconChar;
                        iconSpan.setAttribute('aria-hidden', 'true');
                        wrapper.appendChild(iconSpan);
                    }
                }

                const track = document.createElement('div');
                track.className = 'need-bar-track';

                const fill = document.createElement('div');
                fill.className = 'need-bar-fill';
                const color = typeof bar.color === 'string' && bar.color.trim() ? bar.color.trim() : '';
                if (color) {
                    fill.style.setProperty('--need-bar-color', color);
                    fill.style.backgroundColor = color;
                }
                fill.style.width = `${(Math.max(0, Math.min(1, ratio)) * 100).toFixed(1)}%`;

                track.appendChild(fill);
                wrapper.appendChild(track);
                container.appendChild(wrapper);
            });
        }

        function cloneActorRecord(actor) {
            if (!actor || typeof actor !== 'object') {
                return null;
            }
            const clone = { ...actor };
            if (Array.isArray(actor.needBars)) {
                clone.needBars = actor.needBars.map(bar => ({ ...bar }));
            }
            if (Array.isArray(actor.importantMemories)) {
                clone.importantMemories = actor.importantMemories.slice(0);
            }
            return clone;
        }

        function computeHealthDelta(previousActor, currentActor) {
            const previousHealth = Number(previousActor?.health);
            const currentHealth = Number(currentActor?.health);
            if (!Number.isFinite(previousHealth) || !Number.isFinite(currentHealth)) {
                return 0;
            }
            return currentHealth - previousHealth;
        }

        function triggerHealthChangeEffect(target, previousActor, currentActor) {
            if (!target) {
                return;
            }
            const delta = computeHealthDelta(previousActor, currentActor);
            if (!delta) {
                return;
            }
            spawnHealthChangeFloat(target, delta);
        }

        function spawnHealthChangeFloat(target, delta) {
            if (!target || !Number.isFinite(delta) || delta === 0) {
                return;
            }

            if (typeof console !== 'undefined') {
                try {
                    const actorCard = target.closest('[data-npc-id]');
                    const actorId = actorCard?.dataset?.npcId || window.currentPlayerData?.id || null;
                    const actorName = actorCard?.querySelector('.location-entity-name')?.textContent
                        || window.currentPlayerData?.name
                        || null;
                    console.debug('[HPChange]', {
                        delta,
                        actorId,
                        actorName,
                        timestamp: new Date().toISOString()
                    });
                } catch (_) {
                    console.debug('[HPChange]', { delta, timestamp: new Date().toISOString() });
                }
            }

            const indicator = document.createElement('div');
            indicator.className = 'health-change-float';
            indicator.classList.add(delta > 0 ? 'health-change--gain' : 'health-change--loss');
            indicator.textContent = `${delta > 0 ? '+' : ''}${Math.round(delta)}`;
            indicator.setAttribute('aria-hidden', 'true');

            const computedStyle = window.getComputedStyle(target);
            if (computedStyle.position === 'static') {
                target.style.position = 'relative';
            }

            const rect = target.getBoundingClientRect();
            const width = rect.width || target.offsetWidth || 0;
            const height = rect.height || target.offsetHeight || 0;

            const horizontalPadding = Math.min(width * 0.25, 40);
            const verticalPadding = Math.min(height * 0.25, 32);
            const availableWidth = Math.max(width - horizontalPadding * 2, 0);
            const availableHeight = Math.max(height - verticalPadding * 2, 0);

            const randomX = horizontalPadding + (availableWidth ? Math.random() * availableWidth : 0);
            const randomY = verticalPadding + (availableHeight ? Math.random() * availableHeight : 0);

            indicator.style.left = `${randomX}px`;
            indicator.style.top = `${randomY}px`;

            const horizontalDrift = (Math.random() * 28) - 14;
            const verticalDrift = -(Math.random() * 24 + 24);
            indicator.style.setProperty('--float-x', `${horizontalDrift}px`);
            indicator.style.setProperty('--float-y', `${verticalDrift}px`);

            target.appendChild(indicator);

            indicator.addEventListener('animationend', () => {
                indicator.remove();
            }, { once: true });

            window.setTimeout(() => {
                if (indicator.isConnected) {
                    indicator.remove();
                }
            }, 15000);
        }

        function resolveCurrencyLabel({ capitalize = false } = {}) {
            const setting = window.currentSetting || {};
            const raw = typeof setting.currencyNamePlural === 'string' ? setting.currencyNamePlural.trim() : '';
            const label = raw || 'coins';
            if (!capitalize) {
                return label;
            }
            if (!label) {
                return label;
            }
            return label.charAt(0).toUpperCase() + label.slice(1);
        }

        const chatSidebarElements = {
            card: document.getElementById('chatPlayerCard'),
            portrait: document.getElementById('chatPlayerPortrait'),
            portraitImage: document.getElementById('chatPlayerPortraitImage'),
            healthBar: document.getElementById('chatPlayerHealthBar'),
            healthBarFill: document.getElementById('chatPlayerHealthBarFill'),
            needBars: document.getElementById('chatPlayerNeedBars'),
            viewButton: document.getElementById('chatPlayerViewButton'),
            inventoryButton: document.getElementById('chatPlayerInventoryButton'),
            name: document.getElementById('chatPlayerName'),
            level: document.getElementById('chatPlayerLevel'),
            archetype: document.getElementById('chatPlayerArchetype'),
            health: document.getElementById('chatPlayerHealth'),
            experience: document.getElementById('chatPlayerExperience'),
            currency: document.getElementById('chatPlayerCurrency'),
            description: document.getElementById('chatPlayerDescription'),
            partyGrid: document.getElementById('chatPartyMembers'),
            partyEmpty: document.getElementById('chatPartyEmpty'),
            partyCount: document.getElementById('chatPartyCount')
        };

        function getLatestPlayerData() {
            const baseData = (window.currentPlayerData && typeof window.currentPlayerData === 'object')
                ? window.currentPlayerData
                : null;
            if (!baseData || !baseData.id) {
                return baseData;
            }
            if (window.currentNpcData instanceof Map) {
                return window.currentNpcData.get(baseData.id) || baseData;
            }
            return baseData;
        }

        if (chatSidebarElements.viewButton) {
            chatSidebarElements.viewButton.addEventListener('click', () => {
                const playerData = getLatestPlayerData();
                if (!playerData || typeof showNpcViewModal !== 'function') {
                    return;
                }
                try {
                    showNpcViewModal(playerData);
                } catch (error) {
                    console.warn('Failed to open player view modal:', error);
                }
            });
        }

        if (chatSidebarElements.inventoryButton) {
            chatSidebarElements.inventoryButton.addEventListener('click', () => {
                const playerData = getLatestPlayerData();
                if (!playerData || typeof showNpcInventoryModal !== 'function') {
                    return;
                }
                try {
                    showNpcInventoryModal(playerData);
                } catch (error) {
                    console.warn('Failed to open player inventory modal:', error);
                }
            });
        }

        function updateChatPlayerPanel(player = {}) {
            if (!chatSidebarElements.card) {
                return;
            }

            const source = (player && typeof player === 'object') ? player : {};
            const previousSnapshot = (window.currentPlayerData && window.currentPlayerData.id === source.id)
                ? window.currentPlayerData
                : null;

            const cloned = cloneActorRecord(source) || { ...source };
            if (cloned) {
                cloned.isPlayer = true;
                cloned.isNPC = false;
            }
            const data = cloned;
            window.currentPlayerData = data;

            const resolvedLocationId = data?.locationId || data?.currentLocation || null;
            if (resolvedLocationId) {
                data.locationId = resolvedLocationId;
                if (!data.currentLocation) {
                    data.currentLocation = resolvedLocationId;
                }
            }

            const name = data?.name || 'Unnamed Adventurer';
            if (chatSidebarElements.name) {
                chatSidebarElements.name.textContent = name;
            }

            const levelLabel = Number.isFinite(data?.level) ? `Level ${data.level}` : 'Level ?';
            if (chatSidebarElements.level) {
                chatSidebarElements.level.textContent = levelLabel;
            }

            const archetypeParts = [];
            if (data?.class) {
                archetypeParts.push(data.class);
            }
            if (data?.race) {
                archetypeParts.push(data.race);
            }
            const archetypeLabel = archetypeParts.length ? archetypeParts.join(' ¬∑ ') : 'Unknown origin';
            if (chatSidebarElements.archetype) {
                chatSidebarElements.archetype.textContent = archetypeLabel;
            }

            const healthCurrent = Number.isFinite(data?.health) ? data.health : '?';
            const healthMaximum = Number.isFinite(data?.maxHealth) ? data.maxHealth : '?';
            if (chatSidebarElements.health) {
                chatSidebarElements.health.textContent = `HP: ${healthCurrent} / ${healthMaximum}`;
            }

            const experienceValue = Number.isFinite(data?.experience) ? data.experience : '?';
            if (chatSidebarElements.experience) {
                chatSidebarElements.experience.textContent = `Exp: ${experienceValue} / 100`;
            }

            const currencyValue = Number.isFinite(data?.currency) ? data.currency : null;
            if (chatSidebarElements.currency) {
                const currencyLabel = resolveCurrencyLabel({ capitalize: true });
                chatSidebarElements.currency.textContent = `${currencyLabel}: ${currencyValue !== null ? currencyValue : '?'}`;
            }

            const description = (data?.shortDescription || data?.description || 'No description available.').trim();
            if (chatSidebarElements.description) {
                chatSidebarElements.description.textContent = description;
            }

            const portraitElement = chatSidebarElements.portraitImage || chatSidebarElements.portrait;
            if (portraitElement) {
                renderEntityImage({
                    element: portraitElement,
                    entityType: 'player',
                    entityId: data?.id || null,
                    imageId: data?.imageId || null,
                    altText: `${name} portrait`,
                    placeholderIcon: 'üßô',
                    placeholderClass: 'chat-player-placeholder',
                    enableLightbox: true
                });
            }

            if (chatSidebarElements.healthBar) {
                if (name) {
                    chatSidebarElements.healthBar.setAttribute('aria-label', `${name} health`);
                } else {
                    chatSidebarElements.healthBar.removeAttribute('aria-label');
                }
            }

            updateHealthBar(
                chatSidebarElements.healthBar,
                chatSidebarElements.healthBarFill,
                data?.health,
                data?.maxHealth
            );

            if (chatSidebarElements.needBars) {
                renderNeedBars(
                    chatSidebarElements.needBars,
                    Array.isArray(data?.needBars) ? data.needBars : [],
                    {
                        showIcon: true,
                        includePlayerOnly: true,
                        variant: 'player'
                    }
                );
            }

            if (data?.id) {
                if (window.currentNpcData instanceof Map) {
                    window.currentNpcData.set(data.id, cloneActorRecord(data) || { ...data });
                }
                if (typeof window.registerNpcContextMenu === 'function' && chatSidebarElements.card) {
                    window.registerNpcContextMenu(chatSidebarElements.card, { ...data, isNPC: false });
                }
            }

            if (chatSidebarElements.portrait) {
                triggerHealthChangeEffect(chatSidebarElements.portrait, previousSnapshot, data);
            }

            if (chatSidebarElements.viewButton) {
                chatSidebarElements.viewButton.disabled = !data || !data.id;
            }
            if (chatSidebarElements.inventoryButton) {
                chatSidebarElements.inventoryButton.disabled = !data || !data.id;
            }
        }

        function renderChatPartyPanel(members = []) {
            const container = chatSidebarElements.partyGrid;
            const emptyState = chatSidebarElements.partyEmpty;
            const countLabel = chatSidebarElements.partyCount;
            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            if (!container) {
                if (countLabel) {
                    countLabel.textContent = '0';
                }
                return;
            }

            const safeMembers = Array.isArray(members)
                ? members.filter(member => member && typeof member === 'object')
                : [];
            container.innerHTML = '';

            if (countLabel) {
                countLabel.textContent = String(safeMembers.length);
            }

            if (emptyState) {
                emptyState.style.display = safeMembers.length ? 'none' : 'block';
            }

            container.style.display = safeMembers.length ? 'flex' : 'none';

            const tooltipController = window.floatingTooltipController;

            safeMembers.forEach(member => {
                if (!member) {
                    return;
                }

                const previous = member?.id ? npcDataCache.get(member.id) : null;

                const card = document.createElement('div');
                card.className = 'location-entity-card is-npc';
                if (member?.id) {
                    card.dataset.npcId = member.id;
                }

                const portrait = document.createElement('div');
                portrait.className = 'location-entity-icon';
                const portraitImage = document.createElement('div');
                portraitImage.className = 'location-entity-image';
                portrait.appendChild(portraitImage);

                const { bar: npcHealthBar, fill: npcHealthFill } = createHealthBar('npc-health-bar');
                npcHealthFill.classList.add('npc-health-bar-fill');
                portrait.appendChild(npcHealthBar);

                const npcNeedBars = document.createElement('div');
                npcNeedBars.className = 'npc-need-bars need-bars';
                portrait.appendChild(npcNeedBars);

                renderEntityImage({
                    element: portraitImage,
                    entityType: member.isNPC ? 'npc' : 'player',
                    entityId: member.id || null,
                    imageId: member.imageId || null,
                    altText: member.name || 'Party member portrait',
                    placeholderIcon: 'üé≠',
                    placeholderClass: 'location-entity-placeholder'
                });

                if (npcHealthBar) {
                    if (member?.name) {
                        npcHealthBar.setAttribute('aria-label', `${member.name} health`);
                    } else {
                        npcHealthBar.removeAttribute('aria-label');
                    }
                }

                updateHealthBar(npcHealthBar, npcHealthFill, member?.health, member?.maxHealth);

                renderNeedBars(
                    npcNeedBars,
                    Array.isArray(member?.needBars) ? member.needBars : [],
                    {
                        includePlayerOnly: false,
                        variant: 'npc',
                        compact: true
                    }
                );

                applyNpcDeathStyling(card, portrait, member);

                const nameEl = document.createElement('div');
                nameEl.className = 'location-entity-name';
                nameEl.textContent = member.name || 'Unknown';
                card.appendChild(portrait);
                card.appendChild(nameEl);

                const rawDescription = member?.description || member?.shortDescription || '';
                const normalizedDescription = rawDescription
                    .replace(/<[^>]+>/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                const tooltipText = normalizedDescription || 'No description provided.';

                if (tooltipText) {
                    card.setAttribute('aria-label', tooltipText);
                }

                if (tooltipController && typeof tooltipController.show === 'function') {
                    card.addEventListener('mouseenter', (event) => {
                        tooltipController.show(tooltipText, event);
                    });
                    card.addEventListener('mousemove', (event) => {
                        tooltipController.move?.(event);
                    });
                    card.addEventListener('mouseleave', () => {
                        tooltipController.hide?.();
                    });
                }

                container.appendChild(card);

                if (member?.id) {
                    if (typeof registerNpcContextMenu === 'function') {
                        registerNpcContextMenu(card, member);
                    }
                    triggerHealthChangeEffect(portrait, previous, member);
                    npcDataCache.set(member.id, cloneActorRecord(member) || { ...member });
                }
            });
        }


        window.updateChatPlayerPanel = updateChatPlayerPanel;
        window.renderChatPartyPanel = renderChatPartyPanel;

        function processAutoImageElement(element) {
            if (!(element instanceof HTMLElement)) {
                return;
            }

            const entityType = element.dataset.imageEntityType;
            const entityId = element.dataset.imageEntityId;
            if (!entityType || !entityId) {
                return;
            }

            if (element.dataset.imageProcessing === 'true') {
                return;
            }

            const force = element.dataset.imageForce === 'true';
            renderEntityImage({
                element,
                entityType,
                entityId,
                imageId: element.dataset.imageId || null,
                altText: element.dataset.imageAlt || '',
                placeholderIcon: element.dataset.imagePlaceholder || 'üñºÔ∏è',
                placeholderClass: element.dataset.imagePlaceholderClass || 'image-placeholder',
                placeholderMarkup: element.dataset.imagePlaceholderMarkup || null,
                enableLightbox: element.dataset.imageLightbox !== 'false',
                force
            }).finally(() => {
                element.dataset.imageObserved = 'true';
                if (force) {
                    delete element.dataset.imageForce;
                }
            });
        }

        function initializeAutoImagePlaceholders(root = document) {
            if (!root || typeof root.querySelectorAll !== 'function') {
                return;
            }

            const elements = root.querySelectorAll('[data-image-entity-type][data-image-entity-id]');
            elements.forEach(processAutoImageElement);
        }

        initializeAutoImagePlaceholders();

        const autoImageObserver = new MutationObserver(mutations => {
            for (const mutation of mutations) {
                mutation.addedNodes.forEach(node => {
                    if (!(node instanceof HTMLElement)) {
                        return;
                    }

                    if (node.dataset && node.dataset.imageEntityType && node.dataset.imageEntityId) {
                        processAutoImageElement(node);
                    }

                    initializeAutoImagePlaceholders(node);
                });
            }
        });

        try {
            autoImageObserver.observe(document.body, { childList: true, subtree: true });
        } catch (observerError) {
            console.warn('Auto image observer unavailable:', observerError);
        }

        const capitalize = (value) => {
            if (!value) return '';
            const str = String(value).trim();
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        const normalizeThingType = (thing = {}) => {
            const rawType = (thing.thingType || thing.type || thing.category || '').toLowerCase();
            if (!rawType) {
                return 'item';
            }
            if (rawType.includes('scenery')) {
                return 'scenery';
            }
            if (rawType.includes('item')) {
                return 'item';
            }
            return rawType;
        };

        const formatDetailValue = (value) => {
            if (Array.isArray(value)) {
                return value.map(item => escapeHtml(item)).join(', ');
            }
            if (value && typeof value === 'object') {
                try {
                    return escapeHtml(JSON.stringify(value));
                } catch (_) {
                    return escapeHtml(String(value));
                }
            }
            return escapeHtml(value);
        };

        const getAttributeBonuses = (thing = {}) => {
            if (Array.isArray(thing?.attributeBonuses)) {
                return thing.attributeBonuses;
            }
            if (Array.isArray(thing?.metadata?.attributeBonuses)) {
                return thing.metadata.attributeBonuses;
            }
            return [];
        };

        const titleCase = (value) => {
            if (!value) {
                return '';
            }
            return String(value)
                .split(/[\s_-]+/)
                .filter(Boolean)
                .map(part => {
                    const lowered = part.toLowerCase();
                    return lowered.charAt(0).toUpperCase() + lowered.slice(1);
                })
                .join(' ');
        };

        const formatAttributeName = (name = '') => titleCase(name);

        const rarityDefinitions = Array.isArray(window.rarityDefinitions) ? window.rarityDefinitions : [];
        const rarityInfoByKey = new Map();
        const rarityClassLookup = [];

        const normalizeRarityKey = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value).trim().toLowerCase();
        };

        const raritySlug = (value) => {
            const normalized = normalizeRarityKey(value);
            const slug = normalized.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
            return slug || 'unknown';
        };

        const rarityStyleRules = [];
        rarityDefinitions.forEach((definition) => {
            if (!definition) {
                return;
            }
            const normalizedKey = normalizeRarityKey(definition.key || definition.label);
            if (!normalizedKey || rarityInfoByKey.has(normalizedKey)) {
                return;
            }
            const className = `rarity-${raritySlug(normalizedKey)}`;
            const label = definition.label || titleCase(normalizedKey);
            const color = typeof definition.color === 'string' && definition.color.trim() ? definition.color.trim() : null;
            const info = { key: normalizedKey, className, label, color };

            rarityInfoByKey.set(normalizedKey, info);
            rarityClassLookup.push(info);

            if (color) {
                rarityStyleRules.push(`.${className} { color: ${color}; }`);
                rarityStyleRules.push(`#thingEditRarity option.${className} { color: ${color}; }`);
            }
        });

        if (rarityStyleRules.length) {
            const styleElementId = 'dynamic-rarity-styles';
            let styleElement = document.getElementById(styleElementId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleElementId;
                document.head.appendChild(styleElement);
            }
            styleElement.textContent = rarityStyleRules.join('\n');
        }

        const availableSlotTypes = window.availableSlotTypes instanceof Set ? window.availableSlotTypes : new Set();
        window.availableSlotTypes = availableSlotTypes;

        const attributeOptions = Array.isArray(window.availableAttributes) ? window.availableAttributes : [];
        window.availableAttributes = attributeOptions;
        let attributeDefinitionsCache = typeof window.attributeDefinitionsMap === 'object' && window.attributeDefinitionsMap
            ? window.attributeDefinitionsMap
            : {};
        window.attributeDefinitionsMap = attributeDefinitionsCache;

        const getRarityLabel = (key) => {
            const normalized = normalizeRarityKey(key);
            if (!normalized) {
                return '';
            }
            const info = rarityInfoByKey.get(normalized);
            if (info && info.label) {
                return info.label;
            }
            return titleCase(normalized);
        };

        const normalizeSlotType = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value).trim().toLowerCase();
        };

        const formatSlotTypeLabel = (slotType) => titleCase(slotType);

        const addAvailableSlotType = (value) => {
            const normalized = normalizeSlotType(value);
            if (!normalized || normalized === 'n/a' || normalized === 'none') {
                return;
            }
            availableSlotTypes.add(normalized);
        };

        const trackSlotTypeFromThing = (thing = {}) => {
            if (!thing) {
                return;
            }
            const directSlot = typeof thing.slot === 'string' ? thing.slot : null;
            const metadataSlot = typeof thing.metadata?.slot === 'string' ? thing.metadata.slot : null;
            if (directSlot) {
                addAvailableSlotType(directSlot);
            } else if (metadataSlot) {
                addAvailableSlotType(metadataSlot);
            }
        };

        const updateAvailableSlotTypesFromPlayer = (player = {}) => {
            const gearSlotsByType = player && typeof player.gearSlotsByType === 'object' ? player.gearSlotsByType : null;
            if (gearSlotsByType) {
                Object.keys(gearSlotsByType).forEach(addAvailableSlotType);
            }

            const gear = player && typeof player.gear === 'object' ? player.gear : null;
            if (gear) {
                Object.values(gear).forEach(slot => {
                    if (slot && slot.slotType) {
                        addAvailableSlotType(slot.slotType);
                    }
                });
            }

            const inventory = Array.isArray(player.inventory) ? player.inventory : [];
            inventory.forEach(trackSlotTypeFromThing);
        };

        let attributeOptionsLoaded = attributeOptions.length > 0;
        let attributeFetchPromise = null;

        function refreshAllAttributeSelects() {
            if (!thingEditForm) {
                return;
            }
            const selects = thingEditForm.querySelectorAll('.thing-edit-bonus-attribute');
            selects.forEach(select => {
                const currentValue = select?.value || '';
                populateAttributeSelect(select, currentValue);
            });
        }

        function ensureAttributeDefinitions() {
            if (attributeOptionsLoaded) {
                return Promise.resolve(attributeOptions);
            }
            if (attributeFetchPromise) {
                return attributeFetchPromise;
            }

            attributeFetchPromise = (async () => {
                try {
                    const response = await fetch('/api/attributes');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    if (!data?.success || !Array.isArray(data.attributes)) {
                        if (!data?.success || !data.attributes) {
                            throw new Error(data?.error || 'Failed to load attribute definitions');
                        }
                        if (data.attributes && typeof data.attributes === 'object') {
                            data.attributes = Object.entries(data.attributes).map(([key, def]) => ({
                                key,
                                label: def?.label || titleCase(key),
                                description: def?.description || '',
                                abbreviation: def?.abbreviation || ''
                            }));
                        }
                        if (!Array.isArray(data.attributes)) {
                            throw new Error(data?.error || 'Failed to load attribute definitions');
                        }
                    }

                    attributeOptions.length = 0;
                    attributeDefinitionsCache = {};
                    window.attributeDefinitionsMap = attributeDefinitionsCache;

                    data.attributes.forEach(attr => {
                        if (!attr || !attr.key) {
                            return;
                        }
                        const key = String(attr.key).trim();
                        if (!key) {
                            return;
                        }
                        const entry = {
                            key,
                            keyLower: key.toLowerCase(),
                            label: attr.label || titleCase(key),
                            description: attr.description || '',
                            abbreviation: attr.abbreviation || ''
                        };
                        attributeOptions.push(entry);
                        attributeDefinitionsCache[key] = entry;
                    });

                    attributeOptionsLoaded = attributeOptions.length > 0;
                    refreshAllAttributeSelects();
                    return attributeOptions;
                } catch (error) {
                    console.warn('Failed to fetch attribute definitions:', error);
                    return [];
                } finally {
                    attributeFetchPromise = null;
                }
            })();

            return attributeFetchPromise;
        }

        let gearSlotTypesLoaded = availableSlotTypes.size > 0;
        let gearSlotTypesPromise = null;
        let loadGameSaves = [];
        let loadGameFetchToken = 0;
        let currentLoadGameSource = 'saves';
        let loadGameTriggerButton = null;

        function ensureGearSlotTypes() {
            if (gearSlotTypesLoaded) {
                return Promise.resolve(availableSlotTypes);
            }
            if (gearSlotTypesPromise) {
                return gearSlotTypesPromise;
            }
            gearSlotTypesPromise = (async () => {
                try {
                    const response = await fetch('/api/gear-slots');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    if (!data?.success) {
                        throw new Error(data?.error || 'Failed to load gear slot definitions');
                    }

                    if (Array.isArray(data.slotTypes)) {
                        data.slotTypes.forEach(addAvailableSlotType);
                    }

                    gearSlotTypesLoaded = availableSlotTypes.size > 0;
                    return data;
                } catch (error) {
                    console.warn('Failed to fetch gear slot definitions:', error);
                    return null;
                } finally {
                    gearSlotTypesPromise = null;
                }
            })();
            return gearSlotTypesPromise;
        }

        ensureGearSlotTypes();
        ensureAttributeDefinitions();

        const getRarityClass = (rarity) => {
            if (!rarity && rarity !== 0) {
                return '';
            }
            const normalized = normalizeRarityKey(rarity);
            if (!normalized) {
                return '';
            }
            for (const entry of rarityClassLookup) {
                if (normalized === entry.key) {
                    return entry.className;
                }
            }

            const normalizedTokens = tokenizeForMatch(normalized);
            if (!normalizedTokens) {
                return '';
            }

            for (const entry of rarityClassLookup) {
                if (!entry.key) {
                    continue;
                }
                const entryTokens = tokenizeForMatch(entry.key);
                if (entryTokens && normalizedTokens.includes(entryTokens)) {
                    return entry.className;
                }
            }
            return '';
        };

        const applyRarityClass = (element, rarity) => {
            if (!element) {
                return;
            }
            const rarityClass = getRarityClass(rarity);
            if (rarityClass) {
                element.classList.add(rarityClass);
            }
        };

        const thingDataCache = window.currentThingData instanceof Map ? window.currentThingData : new Map();
        window.currentThingData = thingDataCache;
        const pendingThingRequests = new Map();

        async function fetchThingDetails(thingId) {
            if (!thingId) {
                return null;
            }

            if (thingDataCache.has(thingId)) {
                return thingDataCache.get(thingId);
            }

            if (pendingThingRequests.has(thingId)) {
                return pendingThingRequests.get(thingId);
            }

            const request = fetch(`/api/things/${encodeURIComponent(thingId)}`, {
                cache: 'no-store'
            }).then(async response => {
                try {
                    const data = await response.json();
                    if (data?.success && data.thing) {
                        cacheThingData(data.thing);
                        return data.thing;
                    }
                } catch (error) {
                    console.warn('Failed to parse thing details:', error);
                }
                return null;
            }).catch(error => {
                console.warn(`Failed to load thing ${thingId}:`, error);
                return null;
            }).finally(() => {
                pendingThingRequests.delete(thingId);
            });

            pendingThingRequests.set(thingId, request);
            return request;
        }

        const thingMenuState = { openMenu: null, trigger: null, card: null };
        let thingMenuListenersAttached = false;

        function attachThingMenuListeners() {
            if (thingMenuListenersAttached) {
                return;
            }
            document.addEventListener('click', () => {
                if (thingMenuState.openMenu) {
                    closeThingContextMenu();
                }
            });
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeThingContextMenu();
                }
            });
            thingMenuListenersAttached = true;
        }

        function cacheThingData(thing) {
            if (!thing || !thing.id) {
                return;
            }
            thingDataCache.set(thing.id, { ...thing });
            trackSlotTypeFromThing(thing);
        }

        function closeThingContextMenu() {
            if (thingMenuState.openMenu) {
                thingMenuState.openMenu.classList.remove('is-open');
            }
            if (thingMenuState.trigger) {
                thingMenuState.trigger.setAttribute('aria-expanded', 'false');
            }
            if (thingMenuState.card) {
                thingMenuState.card.classList.remove('context-menu-open');
            }
            thingMenuState.openMenu = null;
            thingMenuState.trigger = null;
            thingMenuState.card = null;
        }

        function updateLocationThingReference(thingId, updater) {
            if (!lastRenderedLocation || typeof updater !== 'function') {
                return;
            }
            const collection = Array.isArray(lastRenderedLocation.things)
                ? lastRenderedLocation.things
                : [];
            const target = collection.find(entry => entry && entry.id === thingId);
            if (target) {
                try {
                    updater(target);
                } catch (error) {
                    console.warn('Failed to update location thing reference:', error);
                }
            }
        }

        async function dropThingToCurrentLocation(thing, options = {}) {
            if (!thing || !thing.id) {
                throw new Error('Missing item information.');
            }

            const playerId = window.currentPlayerData?.id || null;
            const ownerIdCandidate = options.npcId || null;
            let ownerId = ownerIdCandidate || null;
            let ownerType = null;

            if (ownerId && playerId && ownerId === playerId) {
                ownerType = 'player';
            } else if (ownerId) {
                ownerType = 'npc';
            } else if (playerId) {
                ownerType = 'player';
                ownerId = playerId;
            }

            const normalizeId = (value) => {
                if (typeof value !== 'string') {
                    return null;
                }
                const trimmed = value.trim();
                return trimmed || null;
            };

            let locationId = options.locationId || null;
            const ownerData = ownerId && window.currentNpcData instanceof Map
                ? window.currentNpcData.get(ownerId)
                : null;
            if (!locationId && ownerData) {
                locationId = ownerData.currentLocation || ownerData.locationId || null;
            }
            if (!locationId && window.lastRenderedLocation?.id) {
                locationId = window.lastRenderedLocation.id;
            }
            if (!locationId && window.currentPlayerData?.currentLocation) {
                locationId = window.currentPlayerData.currentLocation;
            }

            const payload = {};
            if (ownerId) {
                payload.ownerId = ownerId;
            }
            if (ownerType) {
                payload.ownerType = ownerType;
            }
            locationId = normalizeId(locationId);
            if (locationId) {
                payload.locationId = locationId;
            }

            const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}/drop`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json().catch(() => ({}));

            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            const droppedThing = result.thing || thing;
            thingDataCache.set(droppedThing.id, droppedThing);

            if (result.owner && result.owner.id) {
                if (window.currentNpcData instanceof Map) {
                    window.currentNpcData.set(result.owner.id, result.owner);
                }

                if (playerId && result.owner.id === playerId) {
                    window.currentPlayerData = { ...window.currentPlayerData, ...result.owner };
                    try {
                        await window.refreshInventory?.();
                    } catch (inventoryError) {
                        console.warn('Failed to refresh inventory after drop:', inventoryError);
                    }
                }
            } else if (ownerType === 'player') {
                try {
                    await window.refreshInventory?.();
                } catch (inventoryError) {
                    console.warn('Failed to refresh inventory after drop:', inventoryError);
                }
            }

            if (options.context === 'npc-inventory' && Array.isArray(currentNpcInventory)) {
                currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                renderNpcInventory(currentNpcInventory);
            }

            if (options.context === 'npc-equipment' && typeof currentNpcViewId !== 'undefined') {
                const viewId = currentNpcViewId;
                const refreshedNpc = (result.owner && result.owner.id === viewId)
                    ? result.owner
                    : (window.currentNpcData instanceof Map ? window.currentNpcData.get(viewId) : null);
                if (refreshedNpc && typeof showNpcViewModal === 'function') {
                    showNpcViewModal(refreshedNpc);
                }
            }

            if (result.location) {
                try {
                    await window.updateLocationDisplay?.(result.location);
                    window.lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                } catch (locationError) {
                    console.warn('Failed to update location display after drop:', locationError);
                    try {
                        await window.loadCurrentLocation?.();
                    } catch (_) {}
                }
            } else {
                try {
                    await window.loadCurrentLocation?.();
                } catch (locationError) {
                    console.warn('Failed to reload location after drop:', locationError);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (partyError) {
                console.warn('Failed to refresh party after drop:', partyError);
            }

            return result;
        }

        async function moveThingToNpcInventory(thing, npcId, { locationId = null } = {}) {
            if (!thing || !thing.id) {
                throw new Error('Missing item information.');
            }
            if (!npcId) {
                throw new Error('NPC identifier is required.');
            }

            const payload = {
                ownerId: npcId,
                ownerType: 'npc'
            };
            if (locationId) {
                payload.locationId = locationId;
            }

            const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}/give`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json().catch(() => ({}));
            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            const ownerData = result.owner || null;
            if (ownerData && window.currentNpcData instanceof Map) {
                window.currentNpcData.set(ownerData.id, ownerData);
            }

            const updatedThing = result.thing || thing;
            thingDataCache.set(updatedThing.id, updatedThing);

            if (window.lastRenderedLocation) {
                if (Array.isArray(window.lastRenderedLocation.things)) {
                    window.lastRenderedLocation.things = window.lastRenderedLocation.things.filter(entry => entry && entry.id !== thing.id);
                }
                if (Array.isArray(window.lastRenderedLocation.thingIds)) {
                    window.lastRenderedLocation.thingIds = window.lastRenderedLocation.thingIds.filter(id => id !== thing.id);
                }
            }

            if (ownerData && currentNpcInventoryNpcId && ownerData.id === currentNpcInventoryNpcId) {
                const updatedInventory = Array.isArray(ownerData.inventory) ? ownerData.inventory : [];
                currentNpcInventory = updatedInventory;
                renderNpcInventory(updatedInventory);
            }

            if (ownerData && currentNpcViewId && ownerData.id === currentNpcViewId && typeof showNpcViewModal === 'function') {
                showNpcViewModal(ownerData);
            }

            if (locationId && window.lastRenderedLocation && (window.lastRenderedLocation.id === locationId)) {
                try {
                    if (result.location) {
                        await window.updateLocationDisplay?.(result.location);
                        window.lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                    } else {
                        await window.loadCurrentLocation?.();
                    }
                } catch (error) {
                    console.warn('Failed to update location after moving item to NPC inventory:', error);
                }
            } else if (result.location && result.location.id && window.lastRenderedLocation && window.lastRenderedLocation.id === result.location.id) {
                try {
                    await window.updateLocationDisplay?.(result.location);
                    window.lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                } catch (error) {
                    console.warn('Failed to refresh location after moving item to NPC inventory:', error);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (partyError) {
                console.warn('Failed to refresh party after moving item to NPC inventory:', partyError);
            }

            return result;
        }

        let teleportLocationOptionsCache = null;
        let teleportLocationOptionsPromise = null;

        async function loadTeleportLocationOptions() {
            if (Array.isArray(teleportLocationOptionsCache)) {
                return teleportLocationOptionsCache;
            }
            if (teleportLocationOptionsPromise) {
                return teleportLocationOptionsPromise;
            }

            teleportLocationOptionsPromise = (async () => {
                try {
                    const response = await fetch('/api/locations?scope=named', { cache: 'no-store' });
                    const data = await response.json().catch(() => ({}));
                    if (!response.ok || !data?.success || !Array.isArray(data.locations)) {
                        throw new Error(data?.error || `HTTP ${response.status}`);
                    }

                    const normalized = data.locations
                        .filter(entry => entry && entry.id && typeof entry.label === 'string' && entry.label.trim())
                        .map(entry => ({
                            id: entry.id,
                            label: entry.label.trim(),
                            normalizedLabel: entry.label.trim().toLowerCase()
                        }))
                        .sort((a, b) => a.normalizedLabel.localeCompare(b.normalizedLabel));

                    teleportLocationOptionsCache = normalized;
                    return normalized;
                } catch (error) {
                    console.warn('Failed to load teleport destinations:', error);
                    return [];
                } finally {
                    teleportLocationOptionsPromise = null;
                }
            })();

            return teleportLocationOptionsPromise;
        }

        function invalidateTeleportLocationCache() {
            teleportLocationOptionsCache = null;
        }

        async function applyTeleportLocationUpdate(locationPayload) {
            if (!locationPayload || !locationPayload.id) {
                return false;
            }
            if (!window.lastRenderedLocation || window.lastRenderedLocation.id !== locationPayload.id) {
                return false;
            }
            try {
                await window.updateLocationDisplay?.(locationPayload);
                window.lastRenderedLocation = JSON.parse(JSON.stringify(locationPayload));
                return true;
            } catch (error) {
                console.warn('Failed to apply location update after teleport:', error);
                return false;
            }
        }

        async function teleportThingToLocation(thing, destinationLocationId, { context = 'general', card = null, npcId = null, originLocationId = null } = {}) {
            if (!thing || !thing.id) {
                throw new Error('Missing item information.');
            }
            if (!destinationLocationId) {
                throw new Error('Destination location is required.');
            }

            const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}/teleport`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locationId: destinationLocationId })
            });

            const result = await response.json().catch(() => ({}));
            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            invalidateTeleportLocationCache();

            const updatedThing = result.thing || thing;
            thingDataCache.set(updatedThing.id, updatedThing);

            const removedOwnerIds = Array.isArray(result.removedOwnerIds) ? result.removedOwnerIds : [];

            const updateNpcInventoryCache = (targetNpcId) => {
                if (!targetNpcId) {
                    return;
                }
                if (currentNpcInventoryNpcId && targetNpcId === currentNpcInventoryNpcId && Array.isArray(currentNpcInventory)) {
                    currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                    renderNpcInventory(currentNpcInventory);
                }
                if (window.currentNpcData instanceof Map && window.currentNpcData.has(targetNpcId)) {
                    const npcRecord = window.currentNpcData.get(targetNpcId);
                    if (npcRecord && Array.isArray(npcRecord.inventory)) {
                        npcRecord.inventory = npcRecord.inventory.filter(item => item && item.id !== thing.id);
                        window.currentNpcData.set(targetNpcId, npcRecord);
                        if (currentNpcViewId === targetNpcId && typeof showNpcViewModal === 'function') {
                            showNpcViewModal(npcRecord);
                        }
                    }
                }
            };

            removedOwnerIds.forEach(updateNpcInventoryCache);

            if (npcId) {
                updateNpcInventoryCache(npcId);
            }

            const activeContext = context || 'general';

            if (activeContext === 'npc-inventory' && Array.isArray(currentNpcInventory)) {
                currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                renderNpcInventory(currentNpcInventory);
            }

            if (activeContext === 'npc-equipment' && card && card.parentElement) {
                card.remove();
            }

            if (card && card.parentElement && activeContext === 'location') {
                const destinationId = result.destination?.id || null;
                if (!destinationId || destinationId !== (window.lastRenderedLocation?.id || null)) {
                    card.remove();
                    const container = card.parentElement;
                    const hasRemainingCards = container.querySelector('.location-entity-card');
                    if (!hasRemainingCards) {
                        const emptyMessage = container.id === 'locationScenery'
                            ? 'No notable scenery present.'
                            : 'No notable items present.';
                        container.innerHTML = `<div class="location-thing-empty">${emptyMessage}</div>`;
                    }
                }
            }

            if (npc?.isNPC && card && card.parentElement && !['location', 'npc-equipment', 'npc-inventory'].includes(activeContext)) {
                card.remove();
            }

            const currentPlayerId = window.currentPlayerData?.id || null;
            if (currentPlayerId && removedOwnerIds.includes(currentPlayerId)) {
                try {
                    await window.refreshInventory?.();
                } catch (error) {
                    console.warn('Failed to refresh player inventory after teleport:', error);
                }
            }

            if (result.previousLocation) {
                await applyTeleportLocationUpdate(result.previousLocation);
            }
            if (result.destination) {
                await applyTeleportLocationUpdate(result.destination);
            }

            const currentLocationId = window.lastRenderedLocation?.id || null;
            const destinationId = result.destination?.id || null;
            const shouldReload = (!applied && (
                (originLocationId && originLocationId === currentLocationId)
                || (destinationId && destinationId === currentLocationId)
            ));

            if (shouldReload) {
                try {
                    await window.loadCurrentLocation?.();
                } catch (error) {
                    console.warn('Failed to reload current location after teleport:', error);
                }
            }

            if (activeContext === 'player-inventory' && (!currentPlayerId || !removedOwnerIds.includes(currentPlayerId))) {
                try {
                    await window.refreshInventory?.();
                } catch (error) {
                    console.warn('Failed to refresh player inventory after teleport:', error);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (error) {
                console.warn('Failed to refresh party after teleport:', error);
            }

            return result;
        }

        async function teleportNpcToLocation(npc, destinationLocationId, { card = null, originLocationId = null } = {}) {
            if (!npc || !npc.id) {
                throw new Error('Missing character information.');
            }
            if (!destinationLocationId) {
                throw new Error('Destination location is required.');
            }

            const npcId = npc.id;
            const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}/teleport`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locationId: destinationLocationId })
            });

            const result = await response.json().catch(() => ({}));
            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            const updatedNpc = result.npc || npc;
            if (window.currentNpcData instanceof Map) {
                window.currentNpcData.set(updatedNpc.id, cloneActorRecord(updatedNpc) || { ...updatedNpc });
            }

            if (updatedNpc && !updatedNpc.isNPC && typeof updateChatPlayerPanel === 'function') {
                updateChatPlayerPanel(updatedNpc);
            }

            const destinationId = result.destination?.id || null;
            const currentLocationId = window.lastRenderedLocation?.id || null;
            if (npc?.isNPC && card && card.parentElement) {
                if (!destinationId || destinationId !== currentLocationId) {
                    card.remove();
                }
            }

            let applied = false;
            if (result.previousLocation) {
                applied = await applyTeleportLocationUpdate(result.previousLocation) || applied;
            }
            if (result.destination) {
                applied = await applyTeleportLocationUpdate(result.destination) || applied;
            }

            const shouldReload = (!applied && (
                (originLocationId && originLocationId === currentLocationId)
                || (destinationId && destinationId === currentLocationId)
            ));

            if (shouldReload && typeof window.loadCurrentLocation === 'function') {
                try {
                    await window.loadCurrentLocation();
                } catch (error) {
                    console.warn('Failed to refresh current location after teleporting NPC:', error);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (error) {
                console.warn('Failed to refresh party after teleporting NPC:', error);
            }

            if (updatedNpc && !updatedNpc.isNPC) {
                if (result.destination) {
                    try {
                        await window.updateLocationDisplay?.(result.destination);
                        window.lastRenderedLocation = JSON.parse(JSON.stringify(result.destination));
                    } catch (error) {
                        console.warn('Failed to refresh destination location after teleporting player:', error);
                    }
                } else {
                    try {
                        await window.loadCurrentLocation?.();
                    } catch (error) {
                        console.warn('Failed to load current location after teleporting player:', error);
                    }
                }
            }

            invalidateTeleportLocationCache();

            return result;
        }

        async function showTeleportLocationModal(thing, { context = 'general', card = null, locationId = null, npcId = null, npc = null } = {}) {
            const options = await loadTeleportLocationOptions();
            if (!Array.isArray(options) || !options.length) {
                alert('No named locations are currently available to teleport to.');
                return;
            }

            const modal = document.createElement('div');
            modal.className = 'npc-selection-modal';

            const backdrop = document.createElement('div');
            backdrop.className = 'npc-selection-backdrop';

            const dialog = document.createElement('div');
            dialog.className = 'npc-selection-dialog';

            const header = document.createElement('div');
            header.className = 'npc-selection-header';
            const title = document.createElement('h2');
            title.textContent = npcId ? 'Teleport Character' : 'Teleport Item';
            header.appendChild(title);

            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.className = 'npc-selection-close';
            closeBtn.textContent = 'üóô';
            closeBtn.setAttribute('aria-label', 'Close');
            header.appendChild(closeBtn);

            const body = document.createElement('div');
            body.className = 'npc-selection-body';

            const filterWrapper = document.createElement('div');
            filterWrapper.className = 'npc-selection-filter';

            const filterInput = document.createElement('input');
            filterInput.type = 'search';
            filterInput.className = 'npc-selection-filter-input';
            filterInput.placeholder = 'Filter locations';
            filterInput.setAttribute('aria-label', 'Filter locations by name');
            filterWrapper.appendChild(filterInput);
            body.appendChild(filterWrapper);

            const list = document.createElement('ul');
            list.className = 'npc-selection-list';
            body.appendChild(list);

            const decoratedOptions = options.map(entry => ({
                id: entry.id,
                label: entry.label,
                normalizedLabel: entry.normalizedLabel || entry.label.toLowerCase()
            }));

            const renderTeleportOptions = (filterValue = '') => {
                const normalizedFilter = filterValue.trim().toLowerCase();
                list.textContent = '';

                const filteredEntries = normalizedFilter
                    ? decoratedOptions.filter(entry => entry.normalizedLabel.includes(normalizedFilter))
                    : decoratedOptions;

                filteredEntries.forEach(entry => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'npc-selection-item';
                    button.textContent = entry.label;
                    button.dataset.locationId = entry.id;

                    const li = document.createElement('li');
                    li.appendChild(button);
                    list.appendChild(li);
                });
            };

            renderTeleportOptions();

            filterInput.addEventListener('input', () => {
                renderTeleportOptions(filterInput.value);
            });

            const footer = document.createElement('div');
            footer.className = 'npc-selection-footer';
            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'npc-selection-cancel';
            cancelBtn.textContent = 'Cancel';
            footer.appendChild(cancelBtn);

            dialog.appendChild(header);
            dialog.appendChild(body);
            dialog.appendChild(footer);
            modal.appendChild(backdrop);
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            document.body.classList.add('modal-open');

            const cleanup = () => {
                document.body.classList.remove('modal-open');
                modal.remove();
            };

            let isProcessing = false;

            const handleSelection = async (targetLocationId, triggerButton) => {
                if (!targetLocationId || isProcessing) {
                    return;
                }
                isProcessing = true;
                if (triggerButton) {
                    triggerButton.disabled = true;
                }

                let overlayVisible = false;
                try {
                    showLocationOverlay('Teleporting...');
                    overlayVisible = true;
                } catch (_) {
                    // ignore overlay errors
                }

                try {
                    if (npcId) {
                        const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                        const resolvedNpc = npc
                            || (npcDataCache ? (npcDataCache.get(npcId) || null) : null)
                            || { id: npcId };

                        await teleportNpcToLocation(resolvedNpc, targetLocationId, {
                            card,
                            originLocationId: locationId || (window.lastRenderedLocation?.id || null)
                        });
                    } else {
                        if (!thing || !thing.id) {
                            throw new Error('Item data unavailable for teleportation.');
                        }
                        await teleportThingToLocation(thing, targetLocationId, {
                            context,
                            card,
                            npcId,
                            originLocationId: locationId || (window.lastRenderedLocation?.id || null)
                        });
                    }
                    cleanup();
                } catch (error) {
                    console.warn('Failed to teleport entity:', error);
                    alert(`Failed to teleport ${npcId ? 'character' : 'item'}: ${error?.message || error}`);
                    if (triggerButton) {
                        triggerButton.disabled = false;
                    }
                } finally {
                    isProcessing = false;
                    if (overlayVisible) {
                        hideLocationOverlay();
                    }
                }
            };

            closeBtn.addEventListener('click', cleanup);
            cancelBtn.addEventListener('click', cleanup);
            backdrop.addEventListener('click', cleanup);
            list.addEventListener('click', (event) => {
                if (!(event.target instanceof HTMLButtonElement)) {
                    return;
                }
                const targetId = event.target.dataset.locationId || null;
                handleSelection(targetId, event.target);
            });
        }

        function registerThingContextMenu(card, thing, options = {}) {
            if (!card || !thing || !thing.id) {
                return;
            }

            attachThingMenuListeners();
            cacheThingData(thing);

            const thingIdString = String(thing.id);
            if (card.dataset.thingMenuAttached === 'true' && card.dataset.thingId === thingIdString) {
                return;
            }

            const existingButton = card.querySelector('.thing-card-menu-button');
            const existingMenu = card.querySelector('.thing-card-menu');
            existingButton?.remove();
            existingMenu?.remove();

            card.dataset.thingId = thingIdString;
            card.dataset.thingMenuAttached = 'true';

            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'thing-card-menu-button';
            button.setAttribute('aria-haspopup', 'true');
            button.setAttribute('aria-expanded', 'false');
            button.setAttribute('aria-label', `More actions for ${thing.name || 'item'}`);

            const icon = document.createElement('span');
            icon.setAttribute('aria-hidden', 'true');
            icon.textContent = '‚Ä¢‚Ä¢‚Ä¢';
            button.appendChild(icon);

            const menu = document.createElement('div');
            menu.className = 'thing-card-menu';

            const editButton = document.createElement('button');
            editButton.type = 'button';
            editButton.className = 'thing-card-menu-item';
            editButton.textContent = 'Edit';
            menu.appendChild(editButton);

            let regenerateImageButton = null;
            const imageGenerationEnabled = runtimeConfig?.imagegen?.enabled !== false;
            if (imageGenerationEnabled) {
                regenerateImageButton = document.createElement('button');
                regenerateImageButton.type = 'button';
                regenerateImageButton.className = 'thing-card-menu-item';
                regenerateImageButton.textContent = 'Regenerate Image';
                menu.appendChild(regenerateImageButton);
            }

            const canDrop = options.context === 'npc-inventory' || options.context === 'npc-equipment';
            let dropButton = null;
            if (canDrop) {
                dropButton = document.createElement('button');
                dropButton.type = 'button';
                dropButton.className = 'thing-card-menu-item';
                dropButton.textContent = 'Drop';
                menu.appendChild(dropButton);
            }

            const canPickup = options.context === 'location';
            let pickupButton = null;
            if (canPickup) {
                pickupButton = document.createElement('button');
                pickupButton.type = 'button';
                pickupButton.className = 'thing-card-menu-item';
                pickupButton.textContent = 'Put in Inventory';
                menu.appendChild(pickupButton);
            }

            const teleportButton = document.createElement('button');
            teleportButton.type = 'button';
            teleportButton.className = 'thing-card-menu-item';
            teleportButton.textContent = 'Teleport';
            menu.appendChild(teleportButton);

            const allowDeletion = Boolean(options.allowDelete ?? true);
            let deleteButton = null;
            if (allowDeletion) {
                deleteButton = document.createElement('button');
                deleteButton.type = 'button';
                deleteButton.className = 'thing-card-menu-item thing-card-menu-item--danger';
                deleteButton.textContent = 'Delete';
                menu.appendChild(deleteButton);
            }

            button.addEventListener('click', (event) => {
                event.stopPropagation();
                const wasOpen = thingMenuState.openMenu === menu;
                closeThingContextMenu();
                if (!wasOpen) {
                    menu.classList.add('is-open');
                    button.setAttribute('aria-expanded', 'true');
                    thingMenuState.openMenu = menu;
                    thingMenuState.trigger = button;
                    thingMenuState.card = card;
                    card.classList.add('context-menu-open');
                }
            });

            editButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeThingContextMenu();
                const cachedThing = thingDataCache.get(thing.id) || thing;
                try {
                    await showThingEditModal(cachedThing, options.context || 'general');
                } catch (error) {
                    console.warn('Failed to open thing editor:', error);
                }
            });

            if (regenerateImageButton) {
                regenerateImageButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeThingContextMenu();

                    const cachedThing = { ...(thingDataCache.get(thing.id) || thing) };
                    const entityId = String(cachedThing?.id || '');
                    if (!entityId) {
                        console.warn('Unable to regenerate image: missing thing identifier.');
                        return;
                    }

                    const context = options.context || 'general';
                    const locationId = options.locationId || null;
                    const npcId = options.npcId || null;
                    const previousImageId = cachedThing.imageId || null;
                    const placeholderAlt = cachedThing.name || 'Location item';

                    applyEntityImagePlaceholder('thing', entityId);

                    const updatedThing = {
                        ...cachedThing,
                        imageId: null,
                        imageJobId: null,
                        pendingImageJobId: null
                    };
                    thingDataCache.set(thing.id, updatedThing);
                    thing.imageId = null;
                    thing.imageJobId = null;
                    thing.pendingImageJobId = null;
                    updateLocationThingReference(entityId, (entry) => {
                        entry.imageId = null;
                        entry.imageJobId = null;
                        entry.pendingImageJobId = null;
                    });

                    const payload = {
                        entityType: 'thing',
                        entityId: entityId,
                        force: true
                    };
                    if (context) {
                        payload.context = context;
                    }
                    if (locationId) {
                        payload.locationId = locationId;
                    }
                    if (npcId) {
                        payload.npcId = npcId;
                    }
                    const clientId = window.AIRPG_CLIENT_ID || null;
                    if (clientId) {
                        payload.clientId = clientId;
                    }

                    try {
                        const response = await fetch('/api/images/request', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await response.json().catch(() => ({}));

                        if (!response.ok) {
                            throw new Error(data?.error || `HTTP ${response.status}`);
                        }

                        if (data?.skipped) {
                            thingDataCache.set(thing.id, { ...cachedThing });
                            thing.imageId = cachedThing?.imageId || thing.imageId || null;
                            thing.imageJobId = cachedThing?.imageJobId || thing.imageJobId || null;
                            thing.pendingImageJobId = cachedThing?.pendingImageJobId || null;
                            updateLocationThingReference(entityId, (entry) => {
                                entry.imageId = cachedThing?.imageId || null;
                                if ('imageJobId' in cachedThing) {
                                    entry.imageJobId = cachedThing.imageJobId;
                                }
                                if ('pendingImageJobId' in cachedThing) {
                                    entry.pendingImageJobId = cachedThing.pendingImageJobId || null;
                                }
                            });
                            renderEntityImages('thing', entityId, {
                                imageId: previousImageId,
                                force: false,
                                altText: placeholderAlt
                            });
                            return;
                        }

                        if (!data?.success && !data?.existingJob) {
                            throw new Error(data?.error || 'Image request was not accepted');
                        }

                        const nextThing = {
                            ...updatedThing,
                            pendingImageJobId: data?.jobId || null
                        };
                        thingDataCache.set(thing.id, nextThing);
                        thing.pendingImageJobId = data?.jobId || null;
                        if (data?.imageId) {
                            thing.imageId = data.imageId;
                        }
                        updateLocationThingReference(entityId, (entry) => {
                            entry.pendingImageJobId = data?.jobId || null;
                        });

                        renderEntityImages('thing', entityId, {
                            imageId: null,
                            force: true,
                            altText: placeholderAlt
                        });
                    } catch (error) {
                        console.warn('Failed to regenerate image for thing:', error);
                        thingDataCache.set(thing.id, { ...cachedThing });
                        thing.imageId = cachedThing?.imageId || thing.imageId || null;
                        thing.imageJobId = cachedThing?.imageJobId || thing.imageJobId || null;
                        thing.pendingImageJobId = cachedThing?.pendingImageJobId || null;
                        updateLocationThingReference(entityId, (entry) => {
                            entry.imageId = cachedThing?.imageId || null;
                            if ('imageJobId' in cachedThing) {
                                entry.imageJobId = cachedThing.imageJobId;
                            }
                            if ('pendingImageJobId' in cachedThing) {
                                entry.pendingImageJobId = cachedThing.pendingImageJobId || null;
                            }
                        });
                        renderEntityImages('thing', entityId, {
                            imageId: previousImageId,
                            force: false,
                            altText: placeholderAlt
                        });
                    }
                });
            }

            if (dropButton) {
                dropButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    dropButton.disabled = true;
                    try {
                        closeThingContextMenu();
                        await dropThingToCurrentLocation(thingDataCache.get(thing.id) || thing, options);
                    } catch (error) {
                        console.warn('Failed to drop item:', error);
                        alert(`Failed to drop item: ${error?.message || error}`);
                    } finally {
                        dropButton.disabled = false;
                    }
                });
            }

            if (pickupButton) {
                pickupButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeThingContextMenu();

                    try {
                        const fetchNpcOptions = async () => {
                            const options = [];
                            const seenIds = new Set();

                            const pushEntry = (entry) => {
                                if (!entry || !entry.id || !entry.name) {
                                    return;
                                }

                                const trimmedName = entry.name.trim();
                                if (!trimmedName || seenIds.has(entry.id)) {
                                    return;
                                }

                                seenIds.add(entry.id);
                                options.push({ id: entry.id, name: trimmedName });
                            };

                            // Always include the current player
                            if (window.currentPlayerData && window.currentPlayerData.id && window.currentPlayerData.name) {
                                pushEntry(window.currentPlayerData);
                            }

                            // Include cached NPCs
                            if (window.currentNpcData instanceof Map) {
                                window.currentNpcData.forEach(pushEntry);
                            }

                            try {
                                const response = await fetch('/api/players');
                                const data = await response.json().catch(() => ({}));
                                if (response.ok && data?.success && Array.isArray(data.players)) {
                                    data.players
                                        .filter(entry => entry && entry.id && entry.name && entry.isNPC)
                                        .forEach(pushEntry);
                                }
                            } catch (fetchError) {
                                console.warn('Failed to fetch NPC list:', fetchError);
                            }

                            return options;
                        };

                        const npcOptions = await fetchNpcOptions();

                        if (!npcOptions.length) {
                            alert('No NPCs are available to receive this item.');
                            return;
                        }

                        const sortedNpcList = npcOptions.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));

                        const modal = document.createElement('div');
                        modal.className = 'npc-selection-modal';

                        const backdrop = document.createElement('div');
                        backdrop.className = 'npc-selection-backdrop';

                        const dialog = document.createElement('div');
                        dialog.className = 'npc-selection-dialog';

                        const header = document.createElement('div');
                        header.className = 'npc-selection-header';
                        const title = document.createElement('h2');
                        title.textContent = 'Select Person';
                        header.appendChild(title);

                        const closeBtn = document.createElement('button');
                        closeBtn.type = 'button';
                        closeBtn.className = 'npc-selection-close';
                        closeBtn.textContent = 'üóô';
                        closeBtn.setAttribute('aria-label', 'Close');
                        header.appendChild(closeBtn);

                        const body = document.createElement('div');
                        body.className = 'npc-selection-body';

                        const filterWrapper = document.createElement('div');
                        filterWrapper.className = 'npc-selection-filter';

                        const filterInput = document.createElement('input');
                        filterInput.type = 'search';
                        filterInput.className = 'npc-selection-filter-input';
                        filterInput.placeholder = 'Filter by name';
                        filterInput.setAttribute('aria-label', 'Filter people by name');
                        filterWrapper.appendChild(filterInput);
                        body.appendChild(filterWrapper);

                        const list = document.createElement('ul');
                        list.className = 'npc-selection-list';
                        body.appendChild(list);

                        const decoratedNpcList = sortedNpcList.map(entry => ({
                            id: entry.id,
                            name: entry.name,
                            normalizedName: entry.name.toLocaleLowerCase()
                        }));

                        const renderNpcButtons = (filterValue = '') => {
                            const normalizedFilter = filterValue.trim().toLocaleLowerCase();
                            list.textContent = '';

                            const filteredEntries = normalizedFilter
                                ? decoratedNpcList.filter(entry => entry.normalizedName.includes(normalizedFilter))
                                : decoratedNpcList;

                            filteredEntries.forEach(entry => {
                                const itemButton = document.createElement('button');
                                itemButton.type = 'button';
                                itemButton.className = 'npc-selection-item';
                                itemButton.textContent = entry.name;
                                itemButton.dataset.npcId = entry.id;

                                const itemLi = document.createElement('li');
                                itemLi.appendChild(itemButton);
                                list.appendChild(itemLi);
                            });
                        };

                        renderNpcButtons();

                        filterInput.addEventListener('input', () => {
                            renderNpcButtons(filterInput.value);
                        });

                        const footer = document.createElement('div');
                        footer.className = 'npc-selection-footer';
                        const cancelBtn = document.createElement('button');
                        cancelBtn.type = 'button';
                        cancelBtn.className = 'npc-selection-cancel';
                        cancelBtn.textContent = 'Cancel';
                        footer.appendChild(cancelBtn);

                        dialog.appendChild(header);
                        dialog.appendChild(body);
                        dialog.appendChild(footer);
                        modal.appendChild(backdrop);
                        modal.appendChild(dialog);
                        document.body.appendChild(modal);
                        document.body.classList.add('modal-open');

                        const cleanup = () => {
                            document.body.classList.remove('modal-open');
                            modal.remove();
                        };

                        const handleSelection = async (npcId) => {
                            if (!npcId) {
                                return;
                            }
                            let moveResult = null;
                            try {
                                pickupButton.disabled = true;
                                moveResult = await moveThingToNpcInventory(thingDataCache.get(thing.id) || thing, npcId, {
                                    locationId: options.locationId || (window.lastRenderedLocation?.id || null)
                                });
                            } catch (error) {
                                console.warn('Failed to move item into inventory:', error);
                                alert(`Failed to move item: ${error?.message || error}`);
                            } finally {
                                pickupButton.disabled = false;
                                cleanup();
                            }

                            if (moveResult?.success && options.context === 'location' && card && card.parentElement) {
                                const container = card.parentElement;
                                card.remove();

                                const hasRemainingCards = container.querySelector('.location-entity-card');
                                if (!hasRemainingCards) {
                                    const emptyMessage = container.id === 'locationScenery'
                                        ? 'No notable scenery present.'
                                        : 'No notable items present.';
                                    container.innerHTML = `<div class="location-thing-empty">${emptyMessage}</div>`;
                                }
                            }
                        };

                        closeBtn.addEventListener('click', cleanup);
                        cancelBtn.addEventListener('click', cleanup);
                        backdrop.addEventListener('click', cleanup);
                        list.addEventListener('click', (ev) => {
                            if (!(ev.target instanceof HTMLButtonElement)) {
                                return;
                            }
                            const targetId = ev.target.dataset.npcId || null;
                            if (targetId) {
                                handleSelection(targetId);
                            }
                        });
                    } catch (error) {
                        console.warn('Failed to prepare NPC selection modal:', error);
                        alert(`Unable to show NPC selection: ${error?.message || error}`);
                    }
                });
            }

            teleportButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeThingContextMenu();
                try {
                    await showTeleportLocationModal(thingDataCache.get(thing.id) || thing, {
                        context: options.context || 'general',
                        card,
                        locationId: options.locationId || null,
                        npcId: options.npcId || null
                    });
                } catch (error) {
                    console.warn('Failed to open teleport modal:', error);
                    alert(`Unable to teleport item: ${error?.message || error}`);
                }
            });

            if (deleteButton) {
                deleteButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeThingContextMenu();

                    const cachedThing = thingDataCache.get(thing.id) || thing;
                    const thingName = cachedThing?.name || 'this item';
                    const confirmed = window.confirm(`Delete ${thingName}? This cannot be undone.`);
                    if (!confirmed) {
                        return;
                    }

                    const context = options.context || 'general';
                    const locationHintId = options.locationId || null;
                    const npcHintId = options.npcId || null;

                    try {
                        const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json().catch(() => ({}));
                        if (!response.ok || !result?.success) {
                            throw new Error(result?.error || `HTTP ${response.status}`);
                        }

                        thingDataCache.delete(thing.id);

                        const locationIds = Array.isArray(result.locationIds) ? result.locationIds : [];
                        const playerIds = Array.isArray(result.playerIds) ? result.playerIds : [];
                        const npcIds = Array.isArray(result.npcIds) ? result.npcIds : [];

                        const refreshLocationsByIds = async (ids = []) => {
                            if (typeof window.updateLocationDisplay !== 'function' || !Array.isArray(ids) || !ids.length) {
                                return false;
                            }
                            for (const locId of ids) {
                                if (!locId) {
                                    continue;
                                }
                                try {
                                    const resp = await fetch(`/api/locations/${encodeURIComponent(locId)}`, { cache: 'no-store' });
                                    const data = await resp.json().catch(() => ({}));
                                    if (resp.ok && data?.success && data.location) {
                                        await window.updateLocationDisplay(data.location);
                                        return true;
                                    }
                                } catch (refreshError) {
                                    console.warn('Failed to refresh location details:', refreshError);
                                }
                            }
                            return false;
                        };

                        try {
                            if (context === 'npc-inventory') {
                                if (Array.isArray(currentNpcInventory)) {
                                    currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                                    renderNpcInventory(currentNpcInventory);
                                }
                                let refreshed = await refreshLocationsByIds(locationIds.length ? locationIds : (locationHintId ? [locationHintId] : []));
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                }
                                if (npcHintId && currentNpcViewId === npcHintId) {
                                    const updatedNpc = window.currentNpcData?.get(npcHintId);
                                    if (updatedNpc) {
                                        showNpcViewModal(updatedNpc);
                                    }
                                }
                            } else if (context === 'npc-equipment') {
                                if (card && card.parentElement) {
                                    card.remove();
                                }
                                let refreshed = await refreshLocationsByIds(locationIds.length ? locationIds : (locationHintId ? [locationHintId] : []));
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                }
                                if (npcHintId && currentNpcViewId === npcHintId) {
                                    const updatedNpc = window.currentNpcData?.get(npcHintId);
                                    if (updatedNpc) {
                                        showNpcViewModal(updatedNpc);
                                    }
                                }
                            } else if (context === 'location') {
                                let refreshed = await refreshLocationsByIds(locationIds.length ? locationIds : (locationHintId ? [locationHintId] : []));
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                    refreshed = true;
                                }
                                if (!refreshed && card && card.parentElement) {
                                    card.remove();
                                }
                            } else {
                                await window.refreshInventory?.();
                                let refreshed = await refreshLocationsByIds(locationIds);
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                }
                            }

                            const currentPlayerId = window.currentPlayerData?.id;
                            if (currentPlayerId && playerIds.includes(currentPlayerId)) {
                                await window.refreshInventory?.();
                            }

                            if (npcHintId && context !== 'npc-inventory' && npcIds.includes(npcHintId) && currentNpcViewId === npcHintId) {
                                const updatedNpc = window.currentNpcData?.get(npcHintId);
                                if (updatedNpc) {
                                    showNpcViewModal(updatedNpc);
                                }
                            }
                        } catch (refreshError) {
                            console.warn('Failed to refresh after deleting thing:', refreshError);
                            if (card && card.parentElement) {
                                card.remove();
                            }
                        }

                        window.refreshParty?.();
                    } catch (error) {
                        console.warn('Failed to delete item:', error);
                        alert(`Failed to delete item: ${error?.message || 'Unknown error'}`);
                    }
                });
            }

            menu.addEventListener('click', (event) => event.stopPropagation());
            card.addEventListener('click', () => {
                if (thingMenuState.openMenu) {
                    closeThingContextMenu();
                }
            });

            card.appendChild(button);
            card.appendChild(menu);
        }

        const formatThingTooltip = (thing = {}) => {
            const normalizedType = normalizeThingType(thing);

            const metaParts = [];
            if (thing.thingType) {
                const label = thing.thingType === 'scenery' ? 'Scenery' : capitalize(thing.thingType);
                metaParts.push(escapeHtml(label));
            } else if (thing.type) {
                metaParts.push(escapeHtml(capitalize(thing.type)));
            } else if (thing.category) {
                metaParts.push(escapeHtml(capitalize(thing.category)));
            } else if (normalizedType) {
                metaParts.push(escapeHtml(capitalize(normalizedType)));
            }
            if (thing.rarity) {
                metaParts.push(escapeHtml(thing.rarity));
            }
            if (thing.itemTypeDetail) {
                metaParts.push(escapeHtml(thing.itemTypeDetail));
            }

            const detailItems = [];
            if (thing.metadata) {
                const { value, weight, properties } = thing.metadata;
                if (value) {
                    detailItems.push({ label: 'Value', value });
                }
                if (weight) {
                    detailItems.push({ label: 'Weight', value: weight });
                }
                if (properties) {
                    detailItems.push({ label: 'Properties', value: properties });
                }
            }
            if (thing.quantity !== undefined && thing.quantity !== null) {
                detailItems.push({ label: 'Quantity', value: thing.quantity });
            }

            const rarityClass = getRarityClass(thing.rarity);
            const nameClasses = ['tooltip-thing-name'];
            if (rarityClass) {
                nameClasses.push(rarityClass);
            }

            const nameHtml = `<div class="${nameClasses.join(' ')}">${escapeHtml(thing.name || 'Unknown Object')}</div>`;
            const metaHtml = metaParts.length
                ? `<div class="tooltip-thing-meta">${metaParts.join(' ‚Ä¢ ')}</div>`
                : '';
            const descriptionHtml = `<div class="tooltip-thing-description">${escapeHtml(thing.description || 'No description provided.').replace(/\n/g, '<br>')}</div>`;

            const attributeBonuses = getAttributeBonuses(thing).filter(Boolean);
            const bonusesHtml = attributeBonuses.length
                ? `<div class="tooltip-thing-bonuses">
                        <div class="tooltip-thing-bonuses-title">Attribute Bonuses</div>
                        <ul class="tooltip-thing-bonuses-list">
                            ${attributeBonuses.map(bonus => {
                                const attrName = formatAttributeName(bonus?.attribute || bonus?.name || 'Attribute');
                                const rawBonus = Number.parseFloat(bonus?.bonus ?? bonus?.value ?? 0);
                                const formattedBonus = Number.isFinite(rawBonus)
                                    ? (rawBonus > 0 ? `+${rawBonus}` : `${rawBonus}`)
                                    : escapeHtml(bonus?.bonus ?? bonus?.value ?? '0');
                                return `<li class="tooltip-thing-bonus-item"><span class="tooltip-thing-bonus-attr">${escapeHtml(attrName)}</span><span class="tooltip-thing-bonus-value">${escapeHtml(formattedBonus)}</span></li>`;
                            }).join('')}
                        </ul>
                    </div>`
                : '';
            const detailsHtml = detailItems.length
                ? `<div class="tooltip-thing-details">${detailItems.map(item => `
                        <div class="tooltip-thing-detail">
                            <span class="tooltip-thing-detail-label">${escapeHtml(item.label)}</span>
                            <span class="tooltip-thing-detail-value">${formatDetailValue(item.value)}</span>
                        </div>`).join('')}</div>`
                : '';

            const cardClass = normalizedType === 'scenery' ? 'is-scenery' : 'is-item';

            return `
                <div class="tooltip-thing ${cardClass}">
                    ${nameHtml}
                    ${metaHtml}
                    ${descriptionHtml}
                    ${bonusesHtml}
                    ${detailsHtml}
                </div>
            `.trim();
        };

        const npcEditModal = document.getElementById('npcEditModal');
        const npcInventoryModal = document.getElementById('npcInventoryModal');
        const npcInventoryModalTitle = document.getElementById('npcInventoryModalTitle');
        const npcViewModal = document.getElementById('npcViewModal');
        const npcModalBackdrop = document.getElementById('npcModalBackdrop');
        const npcDispositionModal = document.getElementById('npcDispositionModal');
        const npcDispositionModalTitle = document.getElementById('npcDispositionModalTitle');
        const npcDispositionForm = document.getElementById('npcDispositionForm');
        const npcDispositionSummary = document.getElementById('npcDispositionSummary');
        const npcDispositionList = document.getElementById('npcDispositionList');
        const npcDispositionEmpty = document.getElementById('npcDispositionEmpty');
        const npcDispositionStatus = document.getElementById('npcDispositionStatus');
        const npcDispositionLoading = document.getElementById('npcDispositionLoading');
        const npcDispositionCancelBtn = document.getElementById('npcDispositionCancelBtn');
        const npcDispositionSaveBtn = document.getElementById('npcDispositionSaveBtn');
        const npcDispositionCloseBtn = document.getElementById('npcDispositionCloseBtn');
        const npcNeedsModal = document.getElementById('npcNeedsModal');
        const npcNeedsModalTitle = document.getElementById('npcNeedsModalTitle');
        const npcNeedsForm = document.getElementById('npcNeedsForm');
        const npcNeedsSummary = document.getElementById('npcNeedsSummary');
        const npcNeedsList = document.getElementById('npcNeedsList');
        const npcNeedsEmpty = document.getElementById('npcNeedsEmpty');
        const npcNeedsStatus = document.getElementById('npcNeedsStatus');
        const npcNeedsLoading = document.getElementById('npcNeedsLoading');
        const npcNeedsCancelBtn = document.getElementById('npcNeedsCancelBtn');
        const npcNeedsSaveBtn = document.getElementById('npcNeedsSaveBtn');
        const npcNeedsCloseBtn = document.getElementById('npcNeedsCloseBtn');
        const npcMemoriesModal = document.getElementById('npcMemoriesModal');
        const npcMemoriesModalTitle = document.getElementById('npcMemoriesModalTitle');
        const npcMemoriesList = document.getElementById('npcMemoriesList');
        const npcMemoriesAddBtn = document.getElementById('npcMemoriesAddBtn');
        const npcMemoriesStatus = document.getElementById('npcMemoriesStatus');
        const npcMemoriesCancelBtn = document.getElementById('npcMemoriesCancelBtn');
        const npcMemoriesSaveBtn = document.getElementById('npcMemoriesSaveBtn');
        const npcMemoriesCloseBtn = document.getElementById('npcMemoriesCloseBtn');
        const npcGoalsModal = document.getElementById('npcGoalsModal');
        const npcGoalsModalTitle = document.getElementById('npcGoalsModalTitle');
        const npcGoalsList = document.getElementById('npcGoalsList');
        const npcGoalsAddBtn = document.getElementById('npcGoalsAddBtn');
        const npcGoalsStatus = document.getElementById('npcGoalsStatus');
        const npcGoalsCancelBtn = document.getElementById('npcGoalsCancelBtn');
        const npcGoalsSaveBtn = document.getElementById('npcGoalsSaveBtn');
        const npcGoalsCloseBtn = document.getElementById('npcGoalsCloseBtn');
        const newExitModal = document.getElementById('newExitModal');
        const newExitModalTitle = document.getElementById('newExitModalTitle');
        const newExitForm = document.getElementById('newExitForm');
        const newExitRegionSelect = document.getElementById('newExitRegion');
        const newExitLocationSelect = document.getElementById('newExitLocation');
        const newExitLocationGroup = document.getElementById('newExitLocationGroup');
        const newExitNameGroup = document.getElementById('newExitNameGroup');
        const newExitDescriptionGroup = document.getElementById('newExitDescriptionGroup');
        const newExitNameInput = document.getElementById('newExitName');
        const newExitDescriptionInput = document.getElementById('newExitDescription');
        const newExitVehicleGroup = document.getElementById('newExitVehicleGroup');
        const newExitVehicleInput = document.getElementById('newExitVehicle');
        const newExitStatus = document.getElementById('newExitStatus');
        const newExitCancelBtn = document.getElementById('newExitCancelBtn');
        const newExitSaveBtn = document.getElementById('newExitSaveBtn');
        const newExitCloseBtn = document.getElementById('newExitCloseBtn');
        const newExitChildRegionGroup = document.getElementById('newExitChildRegionGroup');
        const newExitChildRegionCheckbox = document.getElementById('newExitChildRegion');
        const newExitButton = document.getElementById('newExitButton');
        let newExitOptionsCache = null;
        let newExitRegionsById = new Map();
        let editingRegionId = null;
        let editingExitContext = null;
        const addNpcModal = document.getElementById('addNpcModal');
        const addNpcForm = document.getElementById('addNpcForm');
        const addNpcNameInput = document.getElementById('addNpcName');
        const addNpcShortDescriptionInput = document.getElementById('addNpcShortDescription');
        const addNpcDescriptionInput = document.getElementById('addNpcDescription');
        const addNpcRoleInput = document.getElementById('addNpcRole');
        const addNpcClassInput = document.getElementById('addNpcClass');
        const addNpcRaceInput = document.getElementById('addNpcRace');
        const addNpcLevelInput = document.getElementById('addNpcLevel');
        const addNpcCurrencyInput = document.getElementById('addNpcCurrency');
        const addNpcStatus = document.getElementById('addNpcStatus');
        const addNpcCancelBtn = document.getElementById('addNpcCancelBtn');
        const addNpcSaveBtn = document.getElementById('addNpcSaveBtn');
        const addNpcCloseBtn = document.getElementById('addNpcCloseBtn');
        const addNpcButton = document.getElementById('addNpcButton');
        const addThingButton = document.getElementById('addThingButton');
        const loadGameModal = document.getElementById('loadGameModal');
        const loadGameSelect = document.getElementById('loadGameSelect');
        const loadGameSourceSelect = document.getElementById('loadGameSourceSelect');
        const loadGameStatus = document.getElementById('loadGameStatus');
        const loadGameCancelBtn = document.getElementById('loadGameCancelBtn');
        const loadGameConfirmBtn = document.getElementById('loadGameConfirmBtn');
        const loadGameCloseBtn = document.getElementById('loadGameCloseBtn');
        const npcEditForm = document.getElementById('npcEditForm');
        const npcEditModalTitle = document.getElementById('npcEditModalTitle');
        const npcEditIdInput = document.getElementById('npcEditId');
        const npcEditNameInput = document.getElementById('npcEditName');
        const npcEditShortDescriptionInput = document.getElementById('npcEditShortDescription');
        const npcEditRaceInput = document.getElementById('npcEditRace');
        const npcEditClassInput = document.getElementById('npcEditClass');
        const npcEditLevelInput = document.getElementById('npcEditLevel');
        const npcEditHealthInput = document.getElementById('npcEditHealth');
        const npcEditMaxHealthDisplay = document.getElementById('npcEditMaxHealth');
        const npcEditHealthAttributeSelect = document.getElementById('npcEditHealthAttribute');
        const npcEditUnspentInput = document.getElementById('npcEditUnspent');
        const npcEditCurrencyInput = document.getElementById('npcEditCurrency');
        const npcEditExperienceInput = document.getElementById('npcEditExperience');
        const npcEditDescriptionInput = document.getElementById('npcEditDescription');
        const npcEditPersonalityTypeInput = document.getElementById('npcEditPersonalityType');
        const npcEditPersonalityTraitsInput = document.getElementById('npcEditPersonalityTraits');
        const npcEditPersonalityNotesInput = document.getElementById('npcEditPersonalityNotes');
        const npcEditAttributesContainer = document.getElementById('npcEditAttributes');
        const npcEditSkillsContainer = document.getElementById('npcEditSkills');
        const npcEditAbilitiesContainer = document.getElementById('npcEditAbilities');
        const npcAddSkillBtn = document.getElementById('npcAddSkillBtn');
        const npcAddAbilityBtn = document.getElementById('npcAddAbilityBtn');
        const npcEditCancelBtn = document.getElementById('npcEditCancelBtn');
        const npcEditCloseBtn = document.getElementById('npcEditCloseBtn');
        const npcEditStatus = document.getElementById('npcEditStatus');
        const npcEditSaveBtn = document.getElementById('npcEditSaveBtn');
        const npcInventoryGrid = document.getElementById('npcInventoryGrid');
        const npcInventoryFilterInput = document.getElementById('npcInventoryFilterInput');
        const npcInventorySlotFilter = document.getElementById('npcInventorySlotFilter');
        const npcInventoryShowAllRadio = document.getElementById('npcInventoryShowAll');
        const npcInventoryEquippedOnlyRadio = document.getElementById('npcInventoryEquippedOnly');
        const npcInventoryEquippableOnlyRadio = document.getElementById('npcInventoryEquippableOnly');
        const npcInventoryNonEquippableOnlyRadio = document.getElementById('npcInventoryNonEquippableOnly');
        const npcInventoryEmpty = document.getElementById('npcInventoryEmpty');
        const npcInventoryEmptyDefaultText = npcInventoryEmpty ? npcInventoryEmpty.textContent : 'Inventory is empty.';
        const npcInventoryCount = document.getElementById('npcInventoryCount');
        const npcInventoryName = document.getElementById('npcInventoryName');
        const npcInventoryCloseBtn = document.getElementById('npcInventoryCloseBtn');
        const npcViewModalTitle = document.getElementById('npcViewModalTitle');
        const npcViewCloseBtn = document.getElementById('npcViewCloseBtn');
        const npcViewImage = document.getElementById('npcViewImage');
        const locationImageWrapper = document.getElementById('locationImageWrapper');
        const locationImageMenuButton = document.getElementById('locationImageMenuButton');
        const locationImageMenu = document.getElementById('locationImageMenu');
        const locationImageEditButton = document.getElementById('locationImageEditButton');
        const locationRegionEditButton = document.getElementById('locationRegionEditButton');
        const locationSummonNpcButton = document.getElementById('locationSummonNpcButton');
        const locationSummonThingButton = document.getElementById('locationSummonThingButton');
        const locationImageRegenerateButton = document.getElementById('locationImageRegenerateButton');
        const locationEditModal = document.getElementById('locationEditModal');
        const locationEditForm = document.getElementById('locationEditForm');
        const locationEditNameInput = document.getElementById('locationEditName');
        const locationEditDescriptionInput = document.getElementById('locationEditDescription');
        const locationEditLevelInput = document.getElementById('locationEditLevel');
        const locationEditAbsoluteLevel = document.getElementById('locationEditAbsoluteLevel');
        const locationEditStatus = document.getElementById('locationEditStatus');
        const locationEditCancelBtn = document.getElementById('locationEditCancelBtn');
        const locationEditCloseBtn = document.getElementById('locationEditCloseBtn');
        const locationEditSaveBtn = document.getElementById('locationEditSaveBtn');
        const summonNpcModal = document.getElementById('summonNpcModal');
        const summonNpcForm = document.getElementById('summonNpcForm');
        const summonNpcSelect = document.getElementById('summonNpcSelect');
        const summonNpcStatus = document.getElementById('summonNpcStatus');
        const summonNpcCancelBtn = document.getElementById('summonNpcCancelBtn');
        const summonNpcCloseBtn = document.getElementById('summonNpcCloseBtn');
        const summonNpcConfirmBtn = document.getElementById('summonNpcConfirmBtn');
        const summonThingModal = document.getElementById('summonThingModal');
        const summonThingForm = document.getElementById('summonThingForm');
        const summonThingSelect = document.getElementById('summonThingSelect');
        const summonThingStatus = document.getElementById('summonThingStatus');
        const summonThingCancelBtn = document.getElementById('summonThingCancelBtn');
        const summonThingCloseBtn = document.getElementById('summonThingCloseBtn');
        const summonThingConfirmBtn = document.getElementById('summonThingConfirmBtn');
        const regionEditModal = document.getElementById('regionEditModal');
        const regionEditForm = document.getElementById('regionEditForm');
        const regionEditNameInput = document.getElementById('regionEditName');
        const regionEditDescriptionInput = document.getElementById('regionEditDescription');
        const regionEditParentSelect = document.getElementById('regionEditParent');
        const regionEditAverageLevelInput = document.getElementById('regionEditAverageLevel');
        const regionEditStatus = document.getElementById('regionEditStatus');
        const regionEditCancelBtn = document.getElementById('regionEditCancelBtn');
        const regionEditCloseBtn = document.getElementById('regionEditCloseBtn');
        const regionEditSaveBtn = document.getElementById('regionEditSaveBtn');
        const npcViewName = document.getElementById('npcViewName');
        const npcViewDescription = document.getElementById('npcViewDescription');
        const npcViewClass = document.getElementById('npcViewClass');
        const npcViewRace = document.getElementById('npcViewRace');
        const npcViewLevel = document.getElementById('npcViewLevel');
        const npcViewHealth = document.getElementById('npcViewHealth');
        const npcViewCurrency = document.getElementById('npcViewCurrency');
        const npcViewExperience = document.getElementById('npcViewExperience');
        const npcViewDispositions = document.getElementById('npcViewDispositions');
        const npcViewDispositionsList = document.getElementById('npcViewDispositionsList');
        const npcViewAttributes = document.getElementById('npcViewAttributes');
        const npcViewAttributesEmpty = document.getElementById('npcViewAttributesEmpty');
        const npcViewEquipment = document.getElementById('npcViewEquipment');
        const npcViewEquipmentEmpty = document.getElementById('npcViewEquipmentEmpty');
        const npcViewSkills = document.getElementById('npcViewSkills');
        const npcViewSkillsEmpty = document.getElementById('npcViewSkillsEmpty');
        const npcViewAbilities = document.getElementById('npcViewAbilities');
        const npcViewAbilitiesEmpty = document.getElementById('npcViewAbilitiesEmpty');
        const npcViewStatuses = document.getElementById('npcViewStatuses');
        const npcViewStatusesEmpty = document.getElementById('npcViewStatusesEmpty');
        const thingEditModal = document.getElementById('thingEditModal');
        const thingEditForm = document.getElementById('thingEditForm');
        const thingEditModalTitle = document.getElementById('thingEditModalTitle');
        const thingEditIdInput = document.getElementById('thingEditId');
        const thingEditNameInput = document.getElementById('thingEditName');
        const thingEditTypeSelect = document.getElementById('thingEditType');
        const thingEditRarityInput = document.getElementById('thingEditRarity');
        const thingEditItemDetailInput = document.getElementById('thingEditItemDetail');
        const thingEditSlotSelect = document.getElementById('thingEditSlot');
        const thingEditLevelInput = document.getElementById('thingEditLevel');
        const thingEditImageIdInput = document.getElementById('thingEditImageId');
        const thingEditDescriptionInput = document.getElementById('thingEditDescription');
        const thingMetadataList = document.getElementById('thingEditMetadataList');
        const thingMetadataAddBtn = document.getElementById('thingMetadataAddBtn');
        const thingAttributeBonusesList = document.getElementById('thingEditAttributeBonusesList');
        const thingAttributeBonusAddBtn = document.getElementById('thingAttributeBonusAddBtn');
        const thingCauseEffectNameInput = document.getElementById('thingEditCauseStatusEffectName');
        const thingCauseEffectDescriptionInput = document.getElementById('thingEditCauseStatusEffectDescription');
        const thingCauseEffectDurationInput = document.getElementById('thingEditCauseStatusEffectDuration');
        const thingStatusEffectsList = document.getElementById('thingEditStatusEffectsList');
        const thingStatusEffectAddBtn = document.getElementById('thingStatusEffectAddBtn');
        const thingEditCancelBtn = document.getElementById('thingEditCancelBtn');
        const thingEditCloseBtn = document.getElementById('thingEditCloseBtn');
        const thingEditSaveBtn = document.getElementById('thingEditSaveBtn');
        const thingEditStatus = document.getElementById('thingEditStatus');

        let locationImageMenuOpen = false;

        function openLocationImageMenu() {
            if (!locationImageMenu || !locationImageMenuButton) {
                return;
            }
            locationImageMenu.hidden = false;
            locationImageMenu.classList.add('is-open');
            locationImageMenuButton.setAttribute('aria-expanded', 'true');
            locationImageMenuOpen = true;
            if (locationImageWrapper) {
                locationImageWrapper.classList.add('context-menu-open');
            }

            const firstItem = locationImageMenu.querySelector('.location-image-menu-item');
            if (firstItem) {
                requestAnimationFrame(() => {
                    if (locationImageMenuOpen) {
                        firstItem.focus();
                    }
                });
            }
        }

        function closeLocationImageMenu() {
            if (!locationImageMenu || !locationImageMenuButton) {
                return;
            }
            if (!locationImageMenuOpen) {
                return;
            }

            locationImageMenu.hidden = true;
            locationImageMenu.classList.remove('is-open');
            locationImageMenuButton.setAttribute('aria-expanded', 'false');
            locationImageMenuOpen = false;
            if (locationImageWrapper) {
                locationImageWrapper.classList.remove('context-menu-open');
            }

            requestAnimationFrame(() => {
                if (document.activeElement && locationImageMenu?.contains(document.activeElement)) {
                    locationImageMenuButton.focus();
                }
            });
        }

        function toggleLocationImageMenu() {
            if (locationImageMenuOpen) {
                closeLocationImageMenu();
            } else {
                openLocationImageMenu();
            }
        }

        function safeJsonStringify(value, fallback = '') {
            try {
                return JSON.stringify(value, null, 2);
            } catch (_) {
                return fallback;
            }
        }

        function formatThingMetadataValue(value) {
            if (value === undefined || value === null) {
                return '';
            }
            if (typeof value === 'object') {
                return safeJsonStringify(value, '');
            }
            return String(value);
        }

        function extractEditableThingMetadata(thing = {}) {
            if (!thing || typeof thing !== 'object') {
                return {};
            }
            const metadata = thing.metadata && typeof thing.metadata === 'object'
                ? { ...thing.metadata }
                : {};
            delete metadata.slot;
            delete metadata.attributeBonuses;
            delete metadata.causeStatusEffect;
            delete metadata.level;
            delete metadata.relativeLevel;
            delete metadata.location;
            delete metadata.locationId;
            return metadata;
        }

        function createThingMetadataRow(entry = {}) {
            if (!thingMetadataList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-metadata-row';

            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.className = 'thing-edit-metadata-key';
            keyInput.placeholder = 'Key';
            keyInput.autocomplete = 'off';
            keyInput.value = entry.key || '';

            const valueInput = document.createElement('textarea');
            valueInput.className = 'thing-edit-metadata-value';
            valueInput.rows = 1;
            valueInput.placeholder = 'Value (text, number, or JSON)';
            valueInput.value = entry.value !== undefined ? formatThingMetadataValue(entry.value) : '';

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(keyInput);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);

            thingMetadataList.appendChild(row);

            return row;
        }

        function renderThingMetadataEntries(metadata = {}) {
            if (!thingMetadataList) {
                return;
            }
            thingMetadataList.innerHTML = '';
            const entries = metadata && typeof metadata === 'object'
                ? Object.entries(metadata)
                : [];
            if (!entries.length) {
                createThingMetadataRow({});
                return;
            }
            entries.forEach(([key, value]) => {
                createThingMetadataRow({ key, value });
            });
        }

        function collectThingMetadataEntries() {
            if (!thingMetadataList) {
                return {};
            }
            const metadata = {};
            thingMetadataList.querySelectorAll('.thing-edit-metadata-row').forEach(row => {
                const key = row.querySelector('.thing-edit-metadata-key')?.value?.trim();
                if (!key) {
                    return;
                }
                const rawValue = row.querySelector('.thing-edit-metadata-value')?.value ?? '';
                const trimmed = rawValue.trim();
                if (!trimmed) {
                    metadata[key] = '';
                    return;
                }
                let parsed = trimmed;
                try {
                    parsed = JSON.parse(trimmed);
                } catch (_) {
                    parsed = trimmed;
                }
                metadata[key] = parsed;
            });
            return metadata;
        }

        function populateAttributeSelect(selectElement, selectedAttribute = '') {
            if (!selectElement) {
                return;
            }

            const normalized = typeof selectedAttribute === 'string' ? selectedAttribute.trim() : '';
            const normalizedLower = normalized.toLowerCase();

            selectElement.innerHTML = '';

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select attribute';
            selectElement.appendChild(placeholder);

            let hasMatch = false;
            if (Array.isArray(attributeOptions) && attributeOptions.length) {
                attributeOptions.forEach(attr => {
                    if (!attr || !attr.key) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.value = attr.key;
                    option.textContent = attr.label || titleCase(attr.key);
                    if (attr.description) {
                        option.dataset.description = attr.description;
                    }
                    if (normalizedLower && attr.keyLower === normalizedLower) {
                        option.selected = true;
                        hasMatch = true;
                    }
                    selectElement.appendChild(option);
                });
            }

            if (normalized && !hasMatch) {
                const customOption = document.createElement('option');
                customOption.value = normalized;
                customOption.textContent = titleCase(normalized);
                customOption.selected = true;
                selectElement.appendChild(customOption);
            }
        }

        function createThingAttributeBonusRow(entry = {}) {
            if (!thingAttributeBonusesList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-bonus-row';

            const attributeSelect = document.createElement('select');
            attributeSelect.className = 'thing-edit-bonus-attribute';
            populateAttributeSelect(attributeSelect, entry.attribute || entry.attributeName || '');

            const bonusInput = document.createElement('input');
            bonusInput.type = 'number';
            bonusInput.step = '1';
            bonusInput.className = 'thing-edit-bonus-value';
            bonusInput.placeholder = 'Bonus';
            if (entry.bonus !== undefined && entry.bonus !== null && entry.bonus !== '') {
                const numericBonus = Number(entry.bonus);
                if (!Number.isNaN(numericBonus)) {
                    bonusInput.value = numericBonus;
                }
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(attributeSelect);
            row.appendChild(bonusInput);
            row.appendChild(removeBtn);

            thingAttributeBonusesList.appendChild(row);

            return row;
        }

        function renderThingAttributeBonuses(bonuses = []) {
            if (!thingAttributeBonusesList) {
                return;
            }
            thingAttributeBonusesList.innerHTML = '';
            const entries = Array.isArray(bonuses) ? bonuses : [];
            if (!entries.length) {
                createThingAttributeBonusRow({});
                return;
            }
            entries.forEach(entry => createThingAttributeBonusRow(entry));
        }

        function collectThingAttributeBonuses() {
            if (!thingAttributeBonusesList) {
                return [];
            }
            const bonuses = [];
            thingAttributeBonusesList.querySelectorAll('.thing-edit-bonus-row').forEach(row => {
                const attribute = row.querySelector('.thing-edit-bonus-attribute')?.value?.trim();
                if (!attribute) {
                    return;
                }
                const rawBonus = row.querySelector('.thing-edit-bonus-value')?.value ?? '';
                const numeric = Number.parseFloat(rawBonus);
                bonuses.push({
                    attribute,
                    bonus: Number.isFinite(numeric) ? numeric : 0
                });
            });
            return bonuses;
        }

        function populateThingCauseStatusEffect(effect = null) {
            if (thingCauseEffectNameInput) {
                thingCauseEffectNameInput.value = effect?.name || '';
            }
            if (thingCauseEffectDescriptionInput) {
                thingCauseEffectDescriptionInput.value = effect?.description || effect?.text || '';
            }
            if (thingCauseEffectDurationInput) {
                if (effect && effect.duration !== undefined && effect.duration !== null) {
                    thingCauseEffectDurationInput.value = String(effect.duration);
                } else {
                    thingCauseEffectDurationInput.value = '';
                }
            }
        }

        function collectThingCauseStatusEffect() {
            const name = thingCauseEffectNameInput?.value?.trim();
            const description = thingCauseEffectDescriptionInput?.value?.trim();
            const durationRaw = thingCauseEffectDurationInput?.value?.trim();

            if (!name && !description && !durationRaw) {
                return null;
            }

            const effect = {};
            if (name) {
                effect.name = name;
            }
            if (description) {
                effect.description = description;
            }
            if (durationRaw) {
                const numeric = Number.parseInt(durationRaw, 10);
                effect.duration = Number.isFinite(numeric) ? numeric : durationRaw;
            }
            return Object.keys(effect).length ? effect : null;
        }

        function createThingStatusEffectRow(effect = {}) {
            if (!thingStatusEffectsList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-status-row';

            const descriptionInput = document.createElement('textarea');
            descriptionInput.className = 'thing-edit-status-description';
            descriptionInput.rows = 2;
            descriptionInput.placeholder = 'Description';
            descriptionInput.value = effect.description || effect.text || effect.name || '';

            const durationInput = document.createElement('input');
            durationInput.type = 'text';
            durationInput.className = 'thing-edit-status-duration';
            durationInput.placeholder = 'Duration';
            if (effect.duration !== undefined && effect.duration !== null && effect.duration !== '') {
                durationInput.value = String(effect.duration);
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(descriptionInput);
            row.appendChild(durationInput);
            row.appendChild(removeBtn);

            thingStatusEffectsList.appendChild(row);

            return row;
        }

        function renderThingStatusEffects(effects = []) {
            if (!thingStatusEffectsList) {
                return;
            }
            thingStatusEffectsList.innerHTML = '';
            const entries = Array.isArray(effects) ? effects : [];
            if (!entries.length) {
                createThingStatusEffectRow({});
                return;
            }
            entries.forEach(effect => createThingStatusEffectRow(effect));
        }

        function collectThingStatusEffects() {
            if (!thingStatusEffectsList) {
                return [];
            }
            const effects = [];
            thingStatusEffectsList.querySelectorAll('.thing-edit-status-row').forEach(row => {
                const description = row.querySelector('.thing-edit-status-description')?.value?.trim();
                if (!description) {
                    return;
                }
                const durationRaw = row.querySelector('.thing-edit-status-duration')?.value?.trim();
                const effect = { description };
                if (durationRaw) {
                    const numeric = Number.parseInt(durationRaw, 10);
                    effect.duration = Number.isFinite(numeric) ? numeric : durationRaw;
                }
                effects.push(effect);
            });
            return effects;
        }

        function populateThingRarityOptions(selectedRarity = '') {
            if (!thingEditRarityInput) {
                return;
            }

            const normalized = typeof selectedRarity === 'string' ? selectedRarity.trim().toLowerCase() : '';

            thingEditRarityInput.innerHTML = '';

            const unspecifiedOption = document.createElement('option');
            unspecifiedOption.value = '';
            unspecifiedOption.textContent = 'Not specified';
            thingEditRarityInput.appendChild(unspecifiedOption);

            rarityClassLookup.forEach(({ key, className, label }) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = label || getRarityLabel(key);
                option.className = className;
                if (normalized && (normalized === key || normalized.includes(key))) {
                    option.selected = true;
                }
                thingEditRarityInput.appendChild(option);
            });

            if (normalized && !rarityClassLookup.some(entry => entry.key === normalized)) {
                const customOption = document.createElement('option');
                customOption.value = normalized;
                customOption.textContent = getRarityLabel(normalized);
                const customClass = getRarityClass(normalized);
                if (customClass) {
                    customOption.className = customClass;
                }
                customOption.selected = true;
                thingEditRarityInput.appendChild(customOption);
            }

            if (!thingEditRarityInput.value && normalized) {
                thingEditRarityInput.value = normalized;
            }
        }

        function populateThingSlotOptions(selectedSlot = '') {
            if (!thingEditSlotSelect) {
                return;
            }

            const normalized = normalizeSlotType(selectedSlot);
            if (normalized) {
                addAvailableSlotType(normalized);
            }
            const slotTypes = Array.from(availableSlotTypes);
            if (normalized && !slotTypes.includes(normalized)) {
                slotTypes.push(normalized);
            }

            slotTypes.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

            thingEditSlotSelect.innerHTML = '';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = 'Not equippable';
            thingEditSlotSelect.appendChild(emptyOption);

            slotTypes.forEach(slotType => {
                if (!slotType) {
                    return;
                }
                const option = document.createElement('option');
                option.value = slotType;
                option.textContent = formatSlotTypeLabel(slotType);
                if (slotType === normalized) {
                    option.selected = true;
                }
                thingEditSlotSelect.appendChild(option);
            });

            if (!thingEditSlotSelect.value && normalized) {
                thingEditSlotSelect.value = normalized;
            }
        }

        function populateThingEditForm(thing, options = {}) {
            if (!thingEditForm) {
                return;
            }

            thingEditForm.reset();

            const mode = options.mode === 'create' ? 'create' : 'edit';

            if (thingEditModalTitle) {
                if (mode === 'create') {
                    const defaultTitle = options.itemOrScenery === 'scenery' ? 'Create Scenery' : 'Create Item';
                    thingEditModalTitle.textContent = options.title || defaultTitle;
                } else {
                    thingEditModalTitle.textContent = thing?.name ? `Edit ${thing.name}` : 'Edit Item';
                }
            }

            if (thingEditIdInput) {
                thingEditIdInput.value = thing?.id || '';
            }

            if (thingEditNameInput) {
                thingEditNameInput.value = thing?.name || '';
            }

            if (thingEditTypeSelect) {
                const explicitType = options.itemOrScenery ? String(options.itemOrScenery).toLowerCase() : null;
                const typeValue = explicitType
                    || (thing?.thingType || thing?.type || thing?.itemOrScenery || 'item').toString().toLowerCase();
                thingEditTypeSelect.value = typeValue === 'scenery' ? 'scenery' : 'item';
            }

            const rarityValue = thing?.rarity || thing?.metadata?.rarity || '';
            populateThingRarityOptions(rarityValue);

            if (thingEditItemDetailInput) {
                const detail = thing?.itemTypeDetail || thing?.itemDetail || '';
                thingEditItemDetailInput.value = detail;
            }

            populateThingSlotOptions(thing?.slot || thing?.metadata?.slot || '');

            if (thingEditLevelInput) {
                const numericLevel = Number.parseInt(thing?.level, 10);
                thingEditLevelInput.value = Number.isFinite(numericLevel) ? numericLevel : '';
            }


            if (thingEditImageIdInput) {
                thingEditImageIdInput.value = thing?.imageId || '';
            }

            if (thingEditDescriptionInput) {
                thingEditDescriptionInput.value = thing?.description || '';
            }

            currentThingLockedMetadata = {};
            if (thing && typeof thing.metadata === 'object' && thing.metadata) {
                const locked = {};
                if (thing.metadata.location !== undefined) {
                    locked.location = thing.metadata.location;
                }
                if (thing.metadata.locationId !== undefined) {
                    locked.locationId = thing.metadata.locationId;
                }
                currentThingLockedMetadata = locked;
            }

            const metadata = extractEditableThingMetadata(thing);
            renderThingMetadataEntries(metadata);

            const bonuses = Array.isArray(thing?.attributeBonuses)
                ? thing.attributeBonuses
                : Array.isArray(thing?.metadata?.attributeBonuses)
                    ? thing.metadata.attributeBonuses
                    : [];
            renderThingAttributeBonuses(bonuses);
            refreshAllAttributeSelects();

            const causeStatusEffect = thing?.causeStatusEffect || thing?.metadata?.causeStatusEffect || null;
            populateThingCauseStatusEffect(causeStatusEffect);

            const statusEffects = Array.isArray(thing?.statusEffects) ? thing.statusEffects : [];
            renderThingStatusEffects(statusEffects);

            updateThingEditStatus('');
        }

        function formatPossessiveName(name, fallback = 'Character') {
            const base = typeof name === 'string' && name.trim() ? name.trim() : fallback;
            if (!base) {
                return fallback;
            }
            const lastChar = base.charAt(base.length - 1);
            return lastChar.toLowerCase() === 's' ? `${base}'` : `${base}'s`;
        }

        function scrollModalToTop(modal) {
            if (!modal) {
                return;
            }

            const safeScrollTo = (element) => {
                if (!element) {
                    return;
                }
                try {
                    if (typeof element.scrollTo === 'function') {
                        element.scrollTo(0, 0);
                        return;
                    }
                } catch (_) {
                    // fallback to scrollTop assignment below
                }
                element.scrollTop = 0;
            };

            safeScrollTo(modal);
            safeScrollTo(modal.querySelector('.modal__dialog'));
            safeScrollTo(modal.querySelector('.modal__body'));
        }

        async function showThingEditModal(thing, context = 'general', options = {}) {
            if (!thingEditModal || !thingEditForm || !npcModalBackdrop) {
                return;
            }

            const mode = options.mode === 'create' ? 'create' : 'edit';
            let resolvedThing = thing ? { ...thing } : {};

            if (mode === 'edit') {
                if (!thing || !thing.id) {
                    return;
                }

                const needsDetails = resolvedThing.level === undefined
                    || (resolvedThing.metadata && typeof resolvedThing.metadata === 'object'
                        && ('level' in resolvedThing.metadata));

                if (needsDetails) {
                    try {
                        const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data?.thing) {
                                resolvedThing = { ...data.thing };
                                cacheThingData(resolvedThing);
                            }
                        }
                    } catch (error) {
                        console.warn('Failed to fetch full item details:', error);
                    }
                }
            }

            await Promise.all([ensureGearSlotTypes(), ensureAttributeDefinitions()]);

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            populateThingEditForm(resolvedThing, {
                mode,
                itemOrScenery: options.itemOrScenery,
                title: options.title
            });

            currentThingEditContext = context;
            currentThingEditMode = mode;
            thingEditForm.dataset.thingContext = context;
            thingEditForm.dataset.thingMode = mode;

            if (mode === 'edit') {
                currentThingEditId = resolvedThing.id;
                currentThingCreationLocation = null;
                thingEditForm.dataset.thingId = resolvedThing.id;
            } else {
                currentThingEditId = null;
                currentThingCreationLocation = options.location || lastRenderedLocation || null;
                delete thingEditForm.dataset.thingId;

                if (thingEditTypeSelect) {
                    const defaultType = options.itemOrScenery === 'scenery' ? 'scenery' : 'item';
                    thingEditTypeSelect.value = defaultType;
                }
            }

            thingEditModal.removeAttribute('hidden');
            thingEditModal.setAttribute('aria-hidden', 'false');
            npcModalBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');
            scrollModalToTop(thingEditModal);

            setTimeout(() => {
                thingEditNameInput?.focus();
            }, 50);
        }

        let currentNpcEditId = null;
        let currentNpcOriginalHealthAttribute = '';
        let currentNpcInventory = [];
        let currentNpcInventoryNpcId = null;
        let currentNpcViewId = null;
        let currentNpcDispositionId = null;
        let currentNpcDispositionData = null;
        let currentNpcNeedsTargetId = null;
        let currentNpcNeedsTargetType = null;
        let currentNpcNeedsData = null;
        let currentNpcMemoriesId = null;
        let currentNpcMemoriesName = '';
        let npcMemoriesDirty = false;
        let draggedNpcMemoryRow = null;
        let currentNpcGoalsId = null;
        let currentNpcGoalsName = '';
        let npcGoalsDirty = false;
        let draggedNpcGoalRow = null;
        let locationImageGenerationEnabled = true;
        let lastRenderedLocation = null;
        let currentThingEditId = null;
        let currentThingEditContext = null;
        let currentThingEditMode = 'edit';
        let currentThingCreationLocation = null;
        let currentThingLockedMetadata = {};

        function isNpcEditorAvailable() {
            return Boolean(npcEditModal && npcEditForm && npcModalBackdrop);
        }

        function formatNpcLabel(value) {
            if (!value) {
                return '';
            }
            return String(value)
                .replace(/_/g, ' ')
                .replace(/\b\w/g, (char) => char.toUpperCase());
        }

        function updateNpcEditStatus(message = '', type = null) {
            if (!npcEditStatus) {
                return;
            }
            npcEditStatus.textContent = message || '';
            npcEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcEditStatus.classList.add('is-success');
            }
        }

        function clampDispositionValue(value, range = {}) {
            const numeric = Number(value);
            let resolved = Number.isFinite(numeric) ? numeric : 0;
            const min = Number.isFinite(range?.min) ? range.min : null;
            const max = Number.isFinite(range?.max) ? range.max : null;
            if (Number.isFinite(min) && resolved < min) {
                resolved = min;
            }
            if (Number.isFinite(max) && resolved > max) {
                resolved = max;
            }
            return Math.round(resolved);
        }

        function formatSignedValue(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric) || numeric === 0) {
                return '0';
            }
            return numeric > 0 ? `+${numeric}` : `${numeric}`;
        }

        function resolveDispositionIntensityLabel(thresholds, value, fallback = 'neutral') {
            if (!Array.isArray(thresholds) || thresholds.length === 0) {
                return fallback;
            }
            const sorted = thresholds
                .map(entry => ({
                    threshold: Number(entry?.threshold),
                    name: entry?.name || ''
                }))
                .filter(entry => Number.isFinite(entry.threshold) && entry.name)
                .sort((a, b) => a.threshold - b.threshold);

            if (!sorted.length) {
                return fallback;
            }

            let label = fallback;
            for (const entry of sorted) {
                if (value >= entry.threshold) {
                    label = entry.name;
                }
            }
            return label || fallback;
        }

        function formatDispositionThresholds(thresholds) {
            if (!Array.isArray(thresholds) || !thresholds.length) {
                return '';
            }
            const parts = thresholds
                .map(entry => {
                    const thresholdValue = Number(entry?.threshold);
                    const name = entry?.name || '';
                    if (!Number.isFinite(thresholdValue) || !name) {
                        return null;
                    }
                    return `${formatSignedValue(thresholdValue)} ‚Üí ${name}`;
                })
                .filter(Boolean);
            return parts.length ? `Thresholds: ${parts.join(' ¬∑ ')}` : '';
        }

        function setNpcDispositionStatus(message = '', type = null) {
            if (!npcDispositionStatus) {
                return;
            }
            npcDispositionStatus.textContent = message || '';
            npcDispositionStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcDispositionStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcDispositionStatus.classList.add('is-success');
            }
        }

        function setNpcDispositionDirty() {
            if (!npcDispositionSaveBtn) {
                return;
            }
            if (!currentNpcDispositionData || !Array.isArray(currentNpcDispositionData.dispositions)) {
                npcDispositionSaveBtn.disabled = true;
                return;
            }
            const hasChanges = currentNpcDispositionData.dispositions.some(entry => entry.value !== entry.originalValue);
            npcDispositionSaveBtn.disabled = !hasChanges;
        }

        function updateNpcDispositionSummary(payload) {
            if (!npcDispositionSummary) {
                return;
            }
            if (!payload || !payload.npc) {
                npcDispositionSummary.textContent = '';
                return;
            }

            const npcName = payload.npc?.name || 'NPC';
            const playerName = payload.player?.name || 'the player';
            const min = Number.isFinite(payload.range?.min) ? payload.range.min : null;
            const max = Number.isFinite(payload.range?.max) ? payload.range.max : null;
            const step = Number.isFinite(payload.range?.typicalStep) ? payload.range.typicalStep : null;
            const bigStep = Number.isFinite(payload.range?.typicalBigStep) ? payload.range.typicalBigStep : null;

            const parts = [`Adjust ${npcName}'s dispositions toward ${playerName}.`];
            if (Number.isFinite(min) && Number.isFinite(max)) {
                parts.push(`Range ${formatSignedValue(min)} to ${formatSignedValue(max)}.`);
            }
            const stepParts = [];
            if (Number.isFinite(step)) {
                stepParts.push(`${step}`);
            }
            if (Number.isFinite(bigStep)) {
                stepParts.push(`${bigStep}`);
            }
            if (stepParts.length) {
                const descriptor = stepParts.length === 1 ? stepParts[0] : stepParts.join(' / ');
                parts.push(`Use quick adjust buttons for ${descriptor} changes.`);
            }
            npcDispositionSummary.textContent = parts.join(' ');
        }

        function updateCachedNpcDispositions(npcId, payload) {
            const cache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            if (!cache || !npcId) {
                return null;
            }
            const baseNpc = cache.get(npcId) || { id: npcId, isNPC: true };
            const dispositionsTowardsPlayer = Array.isArray(payload?.dispositions)
                ? payload.dispositions.map(entry => ({
                    type: entry.label || entry.key || 'Disposition',
                    intensityName: entry.intensity || resolveDispositionIntensityLabel(entry.thresholds, entry.value, 'neutral'),
                    value: entry.value
                }))
                : [];
            const updatedNpc = {
                ...baseNpc,
                dispositionsTowardsPlayer
            };
            cache.set(npcId, updatedNpc);
            return updatedNpc;
        }

        function renderNpcDispositionEntries(data) {
            if (!npcDispositionList || !npcDispositionEmpty) {
                return;
            }

            npcDispositionList.innerHTML = '';

            if (!data || !Array.isArray(data.dispositions) || data.dispositions.length === 0) {
                npcDispositionEmpty.removeAttribute('hidden');
                setNpcDispositionDirty();
                return;
            }

            npcDispositionEmpty.setAttribute('hidden', '');

            const range = data.range || {};
            const min = Number.isFinite(range.min) ? range.min : -200;
            const max = Number.isFinite(range.max) ? range.max : 200;
            const step = Number.isFinite(range.typicalStep) ? range.typicalStep : null;
            const bigStep = Number.isFinite(range.typicalBigStep) ? range.typicalBigStep : null;

            data.dispositions.forEach(entry => {
                const normalizedValue = clampDispositionValue(entry.value, range);
                entry.value = normalizedValue;
                if (entry.originalValue === undefined || entry.originalValue === null) {
                    entry.originalValue = normalizedValue;
                }
                const intensityLabel = resolveDispositionIntensityLabel(entry.thresholds, normalizedValue, entry.intensity || 'neutral');
                entry.intensity = intensityLabel;

                const card = document.createElement('div');
                card.className = 'npc-disposition-entry';
                card.dataset.key = entry.key || '';

                const heading = document.createElement('div');
                heading.className = 'npc-disposition-heading';

                const labelEl = document.createElement('div');
                labelEl.className = 'npc-disposition-label';
                labelEl.textContent = entry.label || entry.key || 'Disposition';
                heading.appendChild(labelEl);

                const intensityEl = document.createElement('div');
                intensityEl.className = 'npc-disposition-intensity';
                intensityEl.textContent = `Intensity: ${intensityLabel} (${formatSignedValue(normalizedValue)})`;
                heading.appendChild(intensityEl);

                card.appendChild(heading);

                if (entry.description) {
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'npc-disposition-description';
                    descriptionEl.textContent = entry.description;
                    card.appendChild(descriptionEl);
                }

                const sliderRow = document.createElement('div');
                sliderRow.className = 'npc-disposition-slider-row';

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.className = 'npc-disposition-slider';
                slider.min = String(min);
                slider.max = String(max);
                slider.step = '1';
                slider.value = String(normalizedValue);
                sliderRow.appendChild(slider);
                card.appendChild(sliderRow);

                const controlRow = document.createElement('div');
                controlRow.className = 'npc-disposition-control-row';

                const valueWrapper = document.createElement('label');
                valueWrapper.className = 'npc-disposition-value-input';
                valueWrapper.textContent = 'Value';

                const numberInput = document.createElement('input');
                numberInput.type = 'number';
                numberInput.value = String(normalizedValue);
                numberInput.step = '1';
                numberInput.min = String(min);
                numberInput.max = String(max);
                valueWrapper.appendChild(numberInput);
                controlRow.appendChild(valueWrapper);

                const buttonsWrapper = document.createElement('div');
                buttonsWrapper.className = 'npc-disposition-buttons';

                const seenAdjustments = new Set();
                const addAdjustmentButton = (delta, label) => {
                    if (!Number.isFinite(delta) || seenAdjustments.has(delta)) {
                        return;
                    }
                    seenAdjustments.add(delta);
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.dataset.delta = String(delta);
                    button.textContent = label;
                    buttonsWrapper.appendChild(button);
                };

                if (Number.isFinite(bigStep) && bigStep > 0) {
                    addAdjustmentButton(-bigStep, `-${bigStep}`);
                }
                if (Number.isFinite(step) && step > 0) {
                    addAdjustmentButton(-step, `-${step}`);
                    addAdjustmentButton(step, `+${step}`);
                }
                if (Number.isFinite(bigStep) && bigStep > 0) {
                    addAdjustmentButton(bigStep, `+${bigStep}`);
                }
                if (!buttonsWrapper.childElementCount) {
                    addAdjustmentButton(-1, '-1');
                    addAdjustmentButton(1, '+1');
                }

                controlRow.appendChild(buttonsWrapper);
                card.appendChild(controlRow);

                const thresholdsLabel = formatDispositionThresholds(entry.thresholds);
                if (thresholdsLabel) {
                    const thresholdsEl = document.createElement('div');
                    thresholdsEl.className = 'npc-disposition-thresholds';
                    thresholdsEl.textContent = thresholdsLabel;
                    card.appendChild(thresholdsEl);
                }

                const applyValue = (nextValue) => {
                    const clampedValue = clampDispositionValue(nextValue, range);
                    slider.value = String(clampedValue);
                    numberInput.value = String(clampedValue);
                    const label = resolveDispositionIntensityLabel(entry.thresholds, clampedValue, entry.intensity || 'neutral');
                    intensityEl.textContent = `Intensity: ${label} (${formatSignedValue(clampedValue)})`;
                    entry.value = clampedValue;
                    entry.intensity = label;
                    setNpcDispositionDirty();
                };

                slider.addEventListener('input', () => {
                    applyValue(Number(slider.value));
                });

                numberInput.addEventListener('input', () => {
                    const parsed = Number(numberInput.value);
                    if (Number.isFinite(parsed)) {
                        applyValue(parsed);
                    }
                });

                numberInput.addEventListener('blur', () => {
                    applyValue(Number(numberInput.value));
                });

                buttonsWrapper.querySelectorAll('button').forEach(button => {
                    button.addEventListener('click', (event) => {
                        event.preventDefault();
                        const delta = Number(button.dataset.delta);
                        if (!Number.isFinite(delta)) {
                            return;
                        }
                        applyValue(entry.value + delta);
                    });
                });

                npcDispositionList.appendChild(card);
            });

            setNpcDispositionDirty();
        }

        function clampNeedValue(value, min, max) {
            let numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                numeric = Number.isFinite(min) ? min : 0;
            }
            if (Number.isFinite(min)) {
                numeric = Math.max(min, numeric);
            }
            if (Number.isFinite(max)) {
                numeric = Math.min(max, numeric);
            }
            return Math.round(numeric);
        }

        function resolveNeedThreshold(effectThresholds, value) {
            if (!Array.isArray(effectThresholds) || !effectThresholds.length) {
                return null;
            }
            if (!Number.isFinite(value)) {
                return null;
            }

            let resolved = null;
            for (const entry of effectThresholds) {
                if (!entry) {
                    continue;
                }
                const threshold = Number(entry.threshold);
                if (!Number.isFinite(threshold)) {
                    continue;
                }
                if (value >= threshold && (!resolved || threshold >= resolved.threshold)) {
                    resolved = {
                        threshold,
                        name: typeof entry.name === 'string' ? entry.name : '',
                        effect: typeof entry.effect === 'string' ? entry.effect : ''
                    };
                }
            }
            return resolved;
        }

        function updateCachedNpcNeeds(npcId, needs, options = {}) {
            const cache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            if (!cache || !npcId) {
                return null;
            }

            const baseNpc = cache.get(npcId) || { id: npcId, isNPC: options.isNPC !== undefined ? options.isNPC : true };
            const needBars = Array.isArray(needs)
                ? needs.map(bar => ({ ...bar }))
                : [];

            const updatedNpc = {
                ...baseNpc,
                isNPC: options.isNPC !== undefined ? options.isNPC : baseNpc.isNPC,
                needBars
            };

            cache.set(npcId, updatedNpc);
            return updatedNpc;
        }

        function setNpcNeedsStatus(message = '', type = null) {
            if (!npcNeedsStatus) {
                return;
            }
            npcNeedsStatus.textContent = message || '';
            npcNeedsStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcNeedsStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcNeedsStatus.classList.add('is-success');
            }
        }

        function setNpcNeedsDirty() {
            if (!npcNeedsSaveBtn) {
                return;
            }
            if (!currentNpcNeedsData || !Array.isArray(currentNpcNeedsData.needs)) {
                npcNeedsSaveBtn.disabled = true;
                return;
            }
            const hasChanges = currentNpcNeedsData.needs.some(entry => entry.value !== entry.originalValue);
            npcNeedsSaveBtn.disabled = !hasChanges;
        }

        function updateNpcNeedsSummary(payload) {
            if (!npcNeedsSummary) {
                return;
            }
            if (!payload) {
                npcNeedsSummary.textContent = '';
                return;
            }

            const subject = payload.player || payload.npc || {};
            const name = subject.name || 'the character';
            const isPlayer = Boolean(payload.player && !payload.player.isNPC);

            const notes = [`Adjust the need bars for ${name}.`];
            if (!isPlayer && payload.includePlayerOnly === false) {
                notes.push('Player-only needs are hidden for NPCs.');
            }
            npcNeedsSummary.textContent = notes.join(' ');
        }

        function renderNpcNeedsEntries(data) {
            if (!npcNeedsList || !npcNeedsEmpty) {
                return;
            }

            npcNeedsList.innerHTML = '';

            const needs = Array.isArray(data?.needs) ? data.needs : [];
            if (!needs.length) {
                npcNeedsEmpty.removeAttribute('hidden');
                setNpcNeedsDirty();
                return;
            }

            npcNeedsEmpty.setAttribute('hidden', '');

            needs.forEach(entry => {
                const min = Number.isFinite(Number(entry.min)) ? Number(entry.min) : 0;
                let max = Number.isFinite(Number(entry.max)) ? Number(entry.max) : null;
                if (!Number.isFinite(max)) {
                    max = min + Math.max(100, Math.abs(min) || 100);
                }
                if (max <= min) {
                    max = min + 100;
                }

                const normalizedValue = clampNeedValue(entry.value, min, max);
                entry.value = normalizedValue;
                if (entry.originalValue === undefined || entry.originalValue === null) {
                    entry.originalValue = normalizedValue;
                }

                const card = document.createElement('div');
                card.className = 'npc-needs-entry';
                card.dataset.needId = entry.id || '';

                const heading = document.createElement('div');
                heading.className = 'npc-needs-heading';

                const labelEl = document.createElement('div');
                labelEl.className = 'npc-needs-label';
                if (entry.icon) {
                    const iconEl = document.createElement('span');
                    iconEl.textContent = entry.icon;
                    iconEl.setAttribute('aria-hidden', 'true');
                    labelEl.appendChild(iconEl);
                }
                const nameSpan = document.createElement('span');
                nameSpan.textContent = entry.name || entry.id || 'Need';
                labelEl.appendChild(nameSpan);
                heading.appendChild(labelEl);

                const metaEl = document.createElement('div');
                metaEl.className = 'npc-needs-meta';
                const rangeLabel = document.createElement('span');
                rangeLabel.textContent = `Range ${min} ‚Äì ${max}`;
                metaEl.appendChild(rangeLabel);
                if (Number.isFinite(entry.changePerTurn) && entry.changePerTurn !== 0) {
                    const rateLabel = document.createElement('span');
                    rateLabel.textContent = `Œî/turn ${entry.changePerTurn > 0 ? `+${entry.changePerTurn}` : entry.changePerTurn}`;
                    metaEl.appendChild(rateLabel);
                }
                if (entry.playerOnly) {
                    const badge = document.createElement('span');
                    badge.textContent = 'Player-only';
                    badge.style.color = '#fde68a';
                    metaEl.appendChild(badge);
                }
                heading.appendChild(metaEl);
                card.appendChild(heading);

                if (entry.description) {
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'npc-needs-description';
                    descriptionEl.textContent = entry.description;
                    card.appendChild(descriptionEl);
                }

                const progress = document.createElement('div');
                progress.className = 'npc-needs-progress';
                if (entry.color) {
                    progress.style.setProperty('--npc-needs-color', entry.color);
                }
                const progressFill = document.createElement('div');
                progressFill.className = 'npc-needs-progress-fill';
                progress.appendChild(progressFill);
                card.appendChild(progress);

                const sliderRow = document.createElement('div');
                sliderRow.className = 'npc-needs-slider-row';

                const valueDisplay = document.createElement('span');
                valueDisplay.className = 'npc-needs-value-display';
                sliderRow.appendChild(valueDisplay);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.className = 'npc-needs-slider';
                slider.min = String(min);
                slider.max = String(max);
                slider.step = '1';
                slider.value = String(normalizedValue);
                sliderRow.appendChild(slider);

                card.appendChild(sliderRow);

                const inputRow = document.createElement('div');
                inputRow.className = 'npc-needs-input-row';

                const valueWrapper = document.createElement('label');
                valueWrapper.className = 'npc-needs-value-input';
                valueWrapper.textContent = 'Value';
                const numberInput = document.createElement('input');
                numberInput.type = 'number';
                numberInput.value = String(normalizedValue);
                numberInput.step = '1';
                numberInput.min = String(min);
                numberInput.max = String(max);
                valueWrapper.appendChild(numberInput);
                inputRow.appendChild(valueWrapper);

                const buttonsWrapper = document.createElement('div');
                buttonsWrapper.className = 'npc-needs-buttons';

                const addButton = (label, action, delta = 0) => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.dataset.action = action;
                    button.dataset.delta = String(delta);
                    button.textContent = label;
                    buttonsWrapper.appendChild(button);
                };

                addButton('Min', 'min');
                const rangeSpan = max - min;
                const step = Math.max(1, Math.round(rangeSpan / 10));
                addButton(`-${step}`, 'delta', -step);
                addButton(`+${step}`, 'delta', step);
                addButton('Max', 'max');

                inputRow.appendChild(buttonsWrapper);
                card.appendChild(inputRow);

                const thresholdLabel = resolveNeedThreshold(entry.effectThresholds, normalizedValue);
                const thresholdEl = document.createElement('div');
                thresholdEl.className = 'npc-needs-thresholds';
                thresholdEl.textContent = thresholdLabel
                    ? `Current effect: ${thresholdLabel.name || thresholdLabel.effect || 'None'}`
                    : 'Current effect: None';
                card.appendChild(thresholdEl);

                const updateDisplays = (current) => {
                    const denominator = max - min;
                    const ratio = denominator ? Math.max(0, Math.min(1, (current - min) / denominator)) : 1;
                    progressFill.style.width = `${(ratio * 100).toFixed(1)}%`;
                    valueDisplay.textContent = `${current} / ${max}`;
                    const resolvedThreshold = resolveNeedThreshold(entry.effectThresholds, current);
                    thresholdEl.textContent = resolvedThreshold
                        ? `Current effect: ${resolvedThreshold.name || resolvedThreshold.effect || 'None'}`
                        : 'Current effect: None';
                };

                updateDisplays(normalizedValue);

                const applyValue = (nextValue) => {
                    const clampedValue = clampNeedValue(nextValue, min, max);
                    slider.value = String(clampedValue);
                    numberInput.value = String(clampedValue);
                    entry.value = clampedValue;
                    updateDisplays(clampedValue);
                    setNpcNeedsDirty();
                };

                slider.addEventListener('input', () => {
                    applyValue(Number(slider.value));
                });

                numberInput.addEventListener('input', () => {
                    const parsed = Number(numberInput.value);
                    if (Number.isFinite(parsed)) {
                        applyValue(parsed);
                    }
                });

                numberInput.addEventListener('blur', () => {
                    applyValue(Number(numberInput.value));
                });

                buttonsWrapper.querySelectorAll('button').forEach(button => {
                    button.addEventListener('click', (event) => {
                        event.preventDefault();
                        const action = button.dataset.action;
                        if (action === 'min') {
                            applyValue(min);
                        } else if (action === 'max') {
                            applyValue(max);
                        } else if (action === 'delta') {
                            const delta = Number(button.dataset.delta);
                            if (Number.isFinite(delta)) {
                                applyValue(entry.value + delta);
                            }
                        }
                    });
                });

                npcNeedsList.appendChild(card);
            });

            setNpcNeedsDirty();
        }

        function updateThingEditStatus(message = '', type = null) {
            if (!thingEditStatus) {
                return;
            }
            thingEditStatus.textContent = message || '';
            thingEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                thingEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                thingEditStatus.classList.add('is-success');
            }
        }

        function resolveDefaultHealthAttributeKey(attributeKeys = [], preferred = '') {
            if (!Array.isArray(attributeKeys)) {
                return preferred || '';
            }

            const normalizedPreferred = typeof preferred === 'string' ? preferred.trim().toLowerCase() : '';
            if (normalizedPreferred) {
                const preferredMatch = attributeKeys.find(key => typeof key === 'string' && key.toLowerCase() === normalizedPreferred);
                if (preferredMatch) {
                    return preferredMatch;
                }
            }

            const preferredList = ['constitution', 'endurance', 'stamina', 'vitality'];
            for (const candidate of preferredList) {
                const match = attributeKeys.find(key => typeof key === 'string' && key.toLowerCase() === candidate);
                if (match) {
                    return match;
                }
            }

            return attributeKeys[0] || '';
        }

        function getNpcAttributesFromInputs() {
            const attributes = {};
            if (!npcEditAttributesContainer) {
                return attributes;
            }
            npcEditAttributesContainer.querySelectorAll('input[data-attribute]').forEach(input => {
                const attributeKey = input.dataset.attribute;
                if (!attributeKey) {
                    return;
                }
                const attributeValue = Number.parseInt(input.value ?? '', 10);
                if (Number.isFinite(attributeValue)) {
                    attributes[attributeKey] = attributeValue;
                }
            });
            return attributes;
        }

        function populateHealthAttributeOptions(attributes = {}, current = '') {
            if (!npcEditHealthAttributeSelect) {
                return;
            }

            const attributeKeys = Object.keys(attributes || {});
            const uniqueKeys = Array.from(new Set(attributeKeys.filter(key => typeof key === 'string' && key.trim().length > 0)));
            const normalizedCurrent = typeof current === 'string' ? current.trim() : '';
            if (normalizedCurrent && !uniqueKeys.some(key => key.toLowerCase() === normalizedCurrent.toLowerCase())) {
                uniqueKeys.push(normalizedCurrent);
            }

            npcEditHealthAttributeSelect.innerHTML = '';

            if (!uniqueKeys.length) {
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = 'No attributes available';
                npcEditHealthAttributeSelect.appendChild(placeholder);
                npcEditHealthAttributeSelect.disabled = true;
                return;
            }

            npcEditHealthAttributeSelect.disabled = false;
            const resolved = resolveDefaultHealthAttributeKey(uniqueKeys, normalizedCurrent);

            uniqueKeys.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = formatNpcLabel(key);
                if (key === resolved) {
                    option.selected = true;
                }
                npcEditHealthAttributeSelect.appendChild(option);
            });

            npcEditHealthAttributeSelect.value = resolved || '';
        }

        function updateNpcMaxHealth() {
            if (!npcEditMaxHealthDisplay) {
                return;
            }

            const attributes = getNpcAttributesFromInputs();
            const attributeKeys = Object.keys(attributes);

            const selectedAttribute = npcEditHealthAttributeSelect && !npcEditHealthAttributeSelect.disabled
                ? (npcEditHealthAttributeSelect.value || '').trim()
                : '';

            const resolvedAttribute = selectedAttribute || resolveDefaultHealthAttributeKey(attributeKeys, currentNpcOriginalHealthAttribute);
            const attributeValue = Number.isFinite(attributes[resolvedAttribute]) ? attributes[resolvedAttribute] : 10;

            const levelValue = Number.parseInt(npcEditLevelInput?.value ?? '', 10);
            const level = Number.isFinite(levelValue) && levelValue >= 1 ? levelValue : 1;

            const computed = Math.floor(10 + (attributeValue / 2) * (level + 1));
            const resolvedValue = Math.max(1, computed);
            npcEditMaxHealthDisplay.textContent = Number.isFinite(resolvedValue) ? resolvedValue : '‚Äî';
        }

        function populateNpcAttributes(attributes = {}) {
            if (!npcEditAttributesContainer) {
                return;
            }
            npcEditAttributesContainer.innerHTML = '';
            const entries = Object.entries(attributes || {});
            if (!entries.length) {
                const empty = document.createElement('div');
                empty.className = 'npc-edit-empty';
                empty.textContent = 'No attributes available.';
                npcEditAttributesContainer.appendChild(empty);
                return;
            }
            entries.sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));
            entries.forEach(([key, value]) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'npc-attribute-item';

                const label = document.createElement('label');
                const inputId = `npc-attribute-${key.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
                label.setAttribute('for', inputId);
                label.textContent = formatNpcLabel(key);

                const input = document.createElement('input');
                input.type = 'number';
                input.id = inputId;
                input.dataset.attribute = key;
                input.step = '1';
                input.value = Number.isFinite(Number(value)) ? Number(value) : '';

                wrapper.appendChild(label);
                wrapper.appendChild(input);
                input.addEventListener('input', updateNpcMaxHealth);
                input.addEventListener('change', updateNpcMaxHealth);
                npcEditAttributesContainer.appendChild(wrapper);
            });
        }

        function createSkillRow(skill = {}) {
            if (!npcEditSkillsContainer) {
                return null;
            }
            const row = document.createElement('div');
            row.className = 'npc-skill-row';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'npc-skill-name';
            nameInput.placeholder = 'Skill name';
            nameInput.autocomplete = 'off';
            nameInput.value = skill.name || '';

            const valueInput = document.createElement('input');
            valueInput.type = 'number';
            valueInput.className = 'npc-skill-value';
            valueInput.placeholder = 'Value';
            valueInput.step = '1';
            if (skill.value !== undefined && skill.value !== null && skill.value !== '') {
                const numeric = Number(skill.value);
                valueInput.value = Number.isFinite(numeric) ? numeric : '';
            } else {
                valueInput.value = '';
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(nameInput);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);
            npcEditSkillsContainer.appendChild(row);
            return row;
        }

        function populateNpcSkills(skills = {}) {
            if (!npcEditSkillsContainer) {
                return;
            }
            npcEditSkillsContainer.innerHTML = '';
            const entries = Array.isArray(skills)
                ? skills
                : Object.entries(skills || {}).map(([name, value]) => ({ name, value }));
            if (!entries.length) {
                createSkillRow({ name: '', value: '' });
                return;
            }
            entries.sort((a, b) => (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' }));
            entries.forEach(entry => createSkillRow(entry));
        }

        function createAbilityRow(ability = {}) {
            if (!npcEditAbilitiesContainer) {
                return null;
            }
            const row = document.createElement('div');
            row.className = 'npc-ability-row';

            const main = document.createElement('div');
            main.className = 'npc-ability-row-main';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'npc-ability-name';
            nameInput.placeholder = 'Ability name';
            nameInput.autocomplete = 'off';
            nameInput.value = ability.name || '';

            const typeSelect = document.createElement('select');
            typeSelect.className = 'npc-ability-type';
            ['Passive', 'Active', 'Triggered'].forEach(optionValue => {
                const option = document.createElement('option');
                option.value = optionValue;
                option.textContent = optionValue;
                typeSelect.appendChild(option);
            });
            const normalizedType = typeof ability.type === 'string'
                ? ability.type.trim().toLowerCase()
                : '';
            if (normalizedType) {
                const match = ['passive', 'active', 'triggered'].find(value => value === normalizedType);
                if (match) {
                    typeSelect.value = match.charAt(0).toUpperCase() + match.slice(1);
                }
            }

            const levelInput = document.createElement('input');
            levelInput.type = 'number';
            levelInput.className = 'npc-ability-level';
            levelInput.min = '1';
            levelInput.max = '20';
            levelInput.step = '1';
            const numericLevel = Number.parseInt(ability.level, 10);
            levelInput.value = Number.isFinite(numericLevel) ? numericLevel : 1;

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            main.appendChild(nameInput);
            main.appendChild(typeSelect);
            main.appendChild(levelInput);
            main.appendChild(removeBtn);

            const descriptionTextarea = document.createElement('textarea');
            descriptionTextarea.className = 'npc-ability-description';
            descriptionTextarea.rows = 2;
            descriptionTextarea.placeholder = 'Description';
            descriptionTextarea.value = ability.description || '';

            row.appendChild(main);
            row.appendChild(descriptionTextarea);
            npcEditAbilitiesContainer.appendChild(row);
            return row;
        }

        function populateNpcAbilities(abilities = []) {
            if (!npcEditAbilitiesContainer) {
                return;
            }
            npcEditAbilitiesContainer.innerHTML = '';
            const entries = Array.isArray(abilities) ? abilities : [];
            if (!entries.length) {
                createAbilityRow({});
                return;
            }
            entries.forEach(ability => createAbilityRow(ability));
        }

        function showNpcEditModal(npc) {
            if (!isNpcEditorAvailable() || !npc) {
                return;
            }

            currentNpcEditId = npc.id || null;
            currentNpcOriginalHealthAttribute = npc.healthAttribute || '';
            if (npcEditModalTitle) {
                npcEditModalTitle.textContent = npc.name ? `Edit ${npc.name}` : 'Edit NPC';
            }

            if (npcEditIdInput) {
                npcEditIdInput.value = npc.id || '';
            }
            if (npcEditNameInput) {
                npcEditNameInput.value = npc.name || '';
            }
            if (npcEditShortDescriptionInput) {
                npcEditShortDescriptionInput.value = npc.shortDescription || '';
            }
            if (npcEditRaceInput) {
                npcEditRaceInput.value = npc.race || '';
            }
            if (npcEditClassInput) {
                npcEditClassInput.value = npc.class || '';
            }
            if (npcEditLevelInput) {
                const numericLevel = Number.parseInt(npc.level, 10);
                npcEditLevelInput.value = Number.isFinite(numericLevel) ? numericLevel : '';
            }
            if (npcEditHealthInput) {
                const numericHealth = Number.parseInt(npc.health, 10);
                npcEditHealthInput.value = Number.isFinite(numericHealth) ? numericHealth : '';
            }
            if (npcEditMaxHealthDisplay) {
                const numericMax = Number.parseInt(npc.maxHealth, 10);
                npcEditMaxHealthDisplay.textContent = Number.isFinite(numericMax) ? numericMax : '‚Äî';
            }
            if (npcEditUnspentInput) {
                const numericUnspent = Number.parseInt(npc.unspentSkillPoints, 10);
                npcEditUnspentInput.value = Number.isFinite(numericUnspent) ? numericUnspent : 0;
            }
            if (npcEditCurrencyInput) {
                const numericCurrency = Number.parseInt(npc.currency, 10);
                npcEditCurrencyInput.value = Number.isFinite(numericCurrency) && numericCurrency >= 0 ? numericCurrency : '';
            }
            if (npcEditExperienceInput) {
                const numericExperience = Number.parseInt(npc.experience, 10);
                npcEditExperienceInput.value = Number.isFinite(numericExperience) && numericExperience >= 0 ? numericExperience : '';
            }
            if (npcEditDescriptionInput) {
                npcEditDescriptionInput.value = npc.description || '';
            }
            const personalityDetails = npc.personality || {};
            if (npcEditPersonalityTypeInput) {
                npcEditPersonalityTypeInput.value = npc.personalityType
                    ?? personalityDetails.type
                    ?? '';
            }
            if (npcEditPersonalityTraitsInput) {
                npcEditPersonalityTraitsInput.value = npc.personalityTraits
                    ?? personalityDetails.traits
                    ?? '';
            }
            if (npcEditPersonalityNotesInput) {
                npcEditPersonalityNotesInput.value = npc.personalityNotes
                    ?? personalityDetails.notes
                    ?? '';
            }

            populateNpcAttributes(npc.attributes || {});
            populateNpcSkills(npc.skills || {});
            populateNpcAbilities(Array.isArray(npc.abilities) ? npc.abilities : []);
            populateHealthAttributeOptions(npc.attributes || {}, npc.healthAttribute || '');
            updateNpcMaxHealth();

            updateNpcEditStatus('');

            npcEditForm.dataset.npcId = currentNpcEditId || '';
        npcEditModal.removeAttribute('hidden');
        npcEditModal.setAttribute('aria-hidden', 'false');
        npcEditBackdrop.removeAttribute('hidden');
        document.body.classList.add('modal-open');
        scrollModalToTop(npcEditModal);

        setTimeout(() => {
            npcEditNameInput?.focus();
        }, 50);
    }

        function closeNpcEditModal() {
            if (!isNpcEditorAvailable()) {
                return;
            }
            npcEditModal.setAttribute('aria-hidden', 'true');
            npcEditModal.setAttribute('hidden', '');
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
            currentNpcEditId = null;
            currentNpcOriginalHealthAttribute = '';
            updateNpcEditStatus('');
        }

        function closeNpcInventoryModal() {
            if (!npcInventoryModal) {
                return;
            }
            npcInventoryModal.setAttribute('aria-hidden', 'true');
            npcInventoryModal.setAttribute('hidden', '');
            npcInventoryGrid.innerHTML = '';
            npcInventoryEmpty.style.display = 'block';
            npcInventoryCount.textContent = '0 items';
            if (npcInventoryFilterInput) {
                npcInventoryFilterInput.value = '';
            }
            if (npcInventoryShowAllRadio) {
                npcInventoryShowAllRadio.checked = true;
            }
            if (npcInventoryEquippedOnlyRadio) {
                npcInventoryEquippedOnlyRadio.checked = false;
            }
            if (npcInventoryEquippableOnlyRadio) {
                npcInventoryEquippableOnlyRadio.checked = false;
            }
            if (npcInventoryNonEquippableOnlyRadio) {
                npcInventoryNonEquippableOnlyRadio.checked = false;
            }
            if (npcInventoryEmpty) {
                npcInventoryEmpty.textContent = npcInventoryEmptyDefaultText;
            }
            currentNpcInventory = [];
            currentNpcInventoryNpcId = null;
            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (editHidden && viewHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeNpcDispositionModal() {
            if (!npcDispositionModal) {
                return;
            }
            npcDispositionModal.setAttribute('aria-hidden', 'true');
            npcDispositionModal.setAttribute('hidden', '');
            currentNpcDispositionId = null;
            currentNpcDispositionData = null;
            if (npcDispositionList) {
                npcDispositionList.innerHTML = '';
                npcDispositionList.removeAttribute('aria-busy');
            }
            if (npcDispositionSummary) {
                npcDispositionSummary.textContent = '';
            }
            if (npcDispositionLoading) {
                npcDispositionLoading.setAttribute('hidden', '');
            }
            setNpcDispositionStatus('', null);
            if (npcDispositionSaveBtn) {
                npcDispositionSaveBtn.disabled = true;
            }
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeNpcNeedsModal() {
            if (!npcNeedsModal) {
                return;
            }
            npcNeedsModal.setAttribute('aria-hidden', 'true');
            npcNeedsModal.setAttribute('hidden', '');
            currentNpcNeedsTargetId = null;
            currentNpcNeedsTargetType = null;
            currentNpcNeedsData = null;
            if (npcNeedsList) {
                npcNeedsList.innerHTML = '';
                npcNeedsList.removeAttribute('aria-busy');
            }
            if (npcNeedsSummary) {
                npcNeedsSummary.textContent = '';
            }
            if (npcNeedsLoading) {
                npcNeedsLoading.setAttribute('hidden', '');
            }
            setNpcNeedsStatus('', null);
            if (npcNeedsSaveBtn) {
                npcNeedsSaveBtn.disabled = true;
            }
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function setNpcMemoriesStatus(message = '', type = null) {
            if (!npcMemoriesStatus) {
                return;
            }
            npcMemoriesStatus.textContent = message || '';
            npcMemoriesStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcMemoriesStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcMemoriesStatus.classList.add('is-success');
            }
        }

        function resetNpcMemoriesDirty() {
            npcMemoriesDirty = false;
            if (npcMemoriesSaveBtn) {
                npcMemoriesSaveBtn.disabled = true;
            }
        }

        function markNpcMemoriesDirty() {
            npcMemoriesDirty = true;
            if (npcMemoriesSaveBtn) {
                npcMemoriesSaveBtn.disabled = false;
            }
        }

        function setNpcGoalsStatus(message = '', type = null) {
            if (!npcGoalsStatus) {
                return;
            }
            npcGoalsStatus.textContent = message || '';
            npcGoalsStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcGoalsStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcGoalsStatus.classList.add('is-success');
            }
        }

        function resetNpcGoalsDirty() {
            npcGoalsDirty = false;
            if (npcGoalsSaveBtn) {
                npcGoalsSaveBtn.disabled = true;
            }
        }

        function markNpcGoalsDirty() {
            npcGoalsDirty = true;
            if (npcGoalsSaveBtn) {
                npcGoalsSaveBtn.disabled = false;
            }
        }

        function createNpcMemoryRow(value = '') {
            const row = document.createElement('div');
            row.className = 'npc-memory-row';
            row.setAttribute('role', 'listitem');

            const handle = document.createElement('button');
            handle.type = 'button';
            handle.className = 'npc-memory-handle';
            handle.setAttribute('aria-label', 'Reorder memory');
            handle.textContent = '‚â°';
            handle.draggable = true;

            const textarea = document.createElement('textarea');
            textarea.className = 'npc-memory-text';
            textarea.rows = 3;
            textarea.value = value || '';
            textarea.addEventListener('input', () => {
                markNpcMemoriesDirty();
            });

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'npc-memory-delete';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
                row.remove();
                markNpcMemoriesDirty();
                if (npcMemoriesList && !npcMemoriesList.children.length) {
                    npcMemoriesList.appendChild(createNpcMemoryRow(''));
                }
            });

            handle.addEventListener('dragstart', (event) => {
                draggedNpcMemoryRow = row;
                row.classList.add('dragging');
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', 'memory');
            });

            handle.addEventListener('dragend', () => {
                if (draggedNpcMemoryRow === row) {
                    draggedNpcMemoryRow = null;
                }
                row.classList.remove('dragging');
            });

            row.append(handle, textarea, deleteButton);
            return row;
        }

        function renderNpcMemories(memories = []) {
            if (!npcMemoriesList) {
                return;
            }
            npcMemoriesList.innerHTML = '';
            const entries = Array.isArray(memories) && memories.length ? memories : [''];
            entries.forEach(memory => {
                npcMemoriesList.appendChild(createNpcMemoryRow(memory));
            });
            resetNpcMemoriesDirty();
        }

        function createNpcGoalRow(value = '') {
            const row = document.createElement('div');
            row.className = 'npc-goal-row';
            row.setAttribute('role', 'listitem');

            const handle = document.createElement('button');
            handle.type = 'button';
            handle.className = 'npc-goal-handle';
            handle.setAttribute('aria-label', 'Reorder goal');
            handle.textContent = '‚â°';
            handle.draggable = true;

            const textarea = document.createElement('textarea');
            textarea.className = 'npc-goal-text';
            textarea.rows = 2;
            textarea.value = value || '';
            textarea.addEventListener('input', () => {
                markNpcGoalsDirty();
            });

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'npc-goal-delete';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
                row.remove();
                markNpcGoalsDirty();
                if (npcGoalsList && !npcGoalsList.children.length) {
                    npcGoalsList.appendChild(createNpcGoalRow(''));
                }
            });

            handle.addEventListener('dragstart', (event) => {
                draggedNpcGoalRow = row;
                row.classList.add('dragging');
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', 'goal');
            });

            handle.addEventListener('dragend', () => {
                if (draggedNpcGoalRow === row) {
                    draggedNpcGoalRow = null;
                }
                row.classList.remove('dragging');
            });

            row.append(handle, textarea, deleteButton);
            return row;
        }

        function renderNpcGoals(goals = []) {
            if (!npcGoalsList) {
                return;
            }
            npcGoalsList.innerHTML = '';
            const entries = Array.isArray(goals) && goals.length ? goals : [''];
            entries.forEach(goal => {
                npcGoalsList.appendChild(createNpcGoalRow(goal));
            });
            resetNpcGoalsDirty();
        }

        function collectNpcMemories() {
            if (!npcMemoriesList) {
                return [];
            }
            return Array.from(npcMemoriesList.querySelectorAll('.npc-memory-text'))
                .map(field => (typeof field.value === 'string' ? field.value.trim() : ''))
                .filter(entry => entry.length > 0);
        }

        function closeNpcMemoriesModal() {
            if (!npcMemoriesModal) {
                return;
            }
            npcMemoriesModal.setAttribute('aria-hidden', 'true');
            npcMemoriesModal.setAttribute('hidden', '');
            currentNpcMemoriesId = null;
            currentNpcMemoriesName = '';
            draggedNpcMemoryRow = null;
            if (npcMemoriesList) {
                npcMemoriesList.innerHTML = '';
            }
            setNpcMemoriesStatus('', null);
            resetNpcMemoriesDirty();
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        async function showNpcMemoriesModal(target) {
            if (!target || !npcMemoriesModal || !npcModalBackdrop) {
                return;
            }

            const npcId = typeof target.id === 'string' ? target.id : null;
            if (!npcId) {
                console.warn('Unable to open memories editor: NPC id missing');
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            const latestNpc = npcDataCache?.get(npcId) || target;
            const memories = Array.isArray(latestNpc?.importantMemories)
                ? latestNpc.importantMemories.map(entry => (typeof entry === 'string' ? entry : '')).filter(Boolean)
                : [];

            currentNpcMemoriesId = npcId;
            currentNpcMemoriesName = latestNpc?.name || target.name || 'Character';
            draggedNpcMemoryRow = null;
            setNpcMemoriesStatus('', null);
            renderNpcMemories(memories);

            npcModalBackdrop.removeAttribute('hidden');
            npcMemoriesModal.removeAttribute('hidden');
            npcMemoriesModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcMemoriesModalTitle) {
                npcMemoriesModalTitle.textContent = `${formatPossessiveName(currentNpcMemoriesName, 'Character')} Memories`;
            }
            scrollModalToTop(npcMemoriesModal);

            const firstField = npcMemoriesList?.querySelector('.npc-memory-text');
            if (firstField) {
                firstField.focus();
            }
        }

        async function saveNpcMemories() {
            if (!currentNpcMemoriesId) {
                return;
            }
            const memories = collectNpcMemories();

            try {
                setNpcMemoriesStatus('Saving memories...');
                if (npcMemoriesSaveBtn) {
                    npcMemoriesSaveBtn.disabled = true;
                }

                const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcMemoriesId)}/memories`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ memories })
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setNpcMemoriesStatus('Memories saved.', 'success');
                resetNpcMemoriesDirty();

                const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                if (npcDataCache) {
                    const cached = npcDataCache.get(currentNpcMemoriesId) || {};
                    npcDataCache.set(currentNpcMemoriesId, { ...cached, importantMemories: memories.slice(0) });
                }

                if (typeof window.loadCurrentLocation === 'function') {
                    await window.loadCurrentLocation();
                }
                window.refreshParty?.();

                closeNpcMemoriesModal();
            } catch (error) {
                console.warn('Failed to save NPC memories:', error);
                setNpcMemoriesStatus(error?.message || 'Failed to save memories.', 'error');
                if (npcMemoriesSaveBtn) {
                    npcMemoriesSaveBtn.disabled = false;
                }
            }
        }

        function collectNpcGoals() {
            if (!npcGoalsList) {
                return [];
            }
            return Array.from(npcGoalsList.querySelectorAll('.npc-goal-text'))
                .map(field => (typeof field.value === 'string' ? field.value.trim() : ''))
                .filter(entry => entry.length > 0);
        }

        function closeNpcGoalsModal() {
            if (!npcGoalsModal) {
                return;
            }
            npcGoalsModal.setAttribute('aria-hidden', 'true');
            npcGoalsModal.setAttribute('hidden', '');
            currentNpcGoalsId = null;
            currentNpcGoalsName = '';
            draggedNpcGoalRow = null;
            if (npcGoalsList) {
                npcGoalsList.innerHTML = '';
            }
            setNpcGoalsStatus('', null);
            resetNpcGoalsDirty();
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        async function showNpcGoalsModal(target) {
            if (!target || !npcGoalsModal || !npcModalBackdrop) {
                return;
            }

            const npcId = typeof target.id === 'string' ? target.id : null;
            if (!npcId) {
                console.warn('Unable to open goals editor: NPC id missing');
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            const latestNpc = npcDataCache?.get(npcId) || target;
            let goals = [];
            if (Array.isArray(latestNpc?.personality?.goals)) {
                goals = latestNpc.personality.goals
                    .map(entry => (typeof entry === 'string' ? entry : ''))
                    .filter(Boolean);
            } else if (Array.isArray(latestNpc?.goals)) {
                goals = latestNpc.goals
                    .map(entry => (typeof entry === 'string' ? entry : ''))
                    .filter(Boolean);
            }

            currentNpcGoalsId = npcId;
            currentNpcGoalsName = latestNpc?.name || target.name || 'Character';
            draggedNpcGoalRow = null;
            setNpcGoalsStatus('', null);
            renderNpcGoals(goals);

            npcModalBackdrop.removeAttribute('hidden');
            npcGoalsModal.removeAttribute('hidden');
            npcGoalsModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcGoalsModalTitle) {
                npcGoalsModalTitle.textContent = `${formatPossessiveName(currentNpcGoalsName, 'Character')} Goals`;
            }
            scrollModalToTop(npcGoalsModal);

            const firstField = npcGoalsList?.querySelector('.npc-goal-text');
            if (firstField) {
                firstField.focus();
            }
        }

        async function saveNpcGoals() {
            if (!currentNpcGoalsId) {
                return;
            }
            const goals = collectNpcGoals();

            try {
                setNpcGoalsStatus('Saving goals...');
                if (npcGoalsSaveBtn) {
                    npcGoalsSaveBtn.disabled = true;
                }

                const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcGoalsId)}/goals`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ goals })
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setNpcGoalsStatus('Goals saved.', 'success');
                resetNpcGoalsDirty();

                const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                if (npcDataCache) {
                    const cached = npcDataCache.get(currentNpcGoalsId) || {};
                    const updatedPersonality = {
                        ...(cached.personality || {}),
                        goals: goals.slice(0)
                    };
                    npcDataCache.set(currentNpcGoalsId, { ...cached, personality: updatedPersonality, goals: goals.slice(0) });
                }

                if (typeof window.loadCurrentLocation === 'function') {
                    await window.loadCurrentLocation();
                }
                window.refreshParty?.();

                closeNpcGoalsModal();
            } catch (error) {
                console.warn('Failed to save NPC goals:', error);
                setNpcGoalsStatus(error?.message || 'Failed to save goals.', 'error');
                if (npcGoalsSaveBtn) {
                    npcGoalsSaveBtn.disabled = false;
                }
            }
        }

        async function resolveCurrentPlayerId() {
            if (window.currentPlayerData && typeof window.currentPlayerData.id === 'string' && window.currentPlayerData.id.trim()) {
                return window.currentPlayerData.id.trim();
            }
            try {
                const response = await fetch('/api/player', { cache: 'no-store' });
                const result = await response.json().catch(() => ({}));
                if (response.ok && result?.success && result.player?.id) {
                    window.currentPlayerData = result.player;
                    if (typeof result.player.id === 'string' && result.player.id.trim()) {
                        return result.player.id.trim();
                    }
                }
            } catch (error) {
                console.warn('Failed to resolve current player ID:', error);
            }
            throw new Error('Unable to determine current player ID.');
        }

        function updateNpcPartyMembershipCache(npcId, inPlayerParty, fallbackNpc = null) {
            if (!npcId) {
                return;
            }
            const isMember = Boolean(inPlayerParty);
            if (fallbackNpc && typeof fallbackNpc === 'object') {
                fallbackNpc.isInPlayerParty = isMember;
            }
            if (window.currentNpcData instanceof Map) {
                const snapshot = window.currentNpcData.get(npcId) || fallbackNpc || { id: npcId };
                const updated = cloneActorRecord(snapshot) || { ...snapshot };
                updated.isInPlayerParty = isMember;
                window.currentNpcData.set(npcId, updated);
            }
            if (window.currentPlayerData) {
                const existingMembers = Array.isArray(window.currentPlayerData.partyMembers)
                    ? new Set(window.currentPlayerData.partyMembers)
                    : new Set();
                if (isMember) {
                    existingMembers.add(npcId);
                } else {
                    existingMembers.delete(npcId);
                }
                window.currentPlayerData = {
                    ...window.currentPlayerData,
                    partyMembers: Array.from(existingMembers)
                };
            }
        }

        async function recruitNpcToParty(npc, { card = null } = {}) {
            if (!npc || !npc.id) {
                throw new Error('Missing character information.');
            }
            const ownerId = await resolveCurrentPlayerId();
            const label = npc.name || 'character';
            showLocationOverlay(`Recruiting ${label}...`);
            try {
                const response = await fetch('/api/player/party', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ownerId, memberId: npc.id })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                updateNpcPartyMembershipCache(npc.id, true, npc);

                try {
                    if (typeof window.refreshParty === 'function') {
                        await window.refreshParty();
                    }
                } catch (refreshError) {
                    console.warn('Failed to refresh party after recruiting NPC:', refreshError);
                }

                try {
                    if (typeof window.loadCurrentLocation === 'function') {
                        await window.loadCurrentLocation();
                    }
                } catch (locationError) {
                    console.warn('Failed to refresh location after recruiting NPC:', locationError);
                }

                if (card && card.parentElement) {
                    card.remove();
                }

                return data;
            } finally {
                hideLocationOverlay();
            }
        }

        async function dismissNpcFromParty(npc, { card = null } = {}) {
            if (!npc || !npc.id) {
                throw new Error('Missing character information.');
            }
            const ownerId = await resolveCurrentPlayerId();
            const label = npc.name || 'character';
            showLocationOverlay(`Dismissing ${label}...`);
            try {
                const response = await fetch('/api/player/party', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ownerId, memberId: npc.id })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                updateNpcPartyMembershipCache(npc.id, false, npc);

                try {
                    if (typeof window.refreshParty === 'function') {
                        await window.refreshParty();
                    }
                } catch (refreshError) {
                    console.warn('Failed to refresh party after dismissing NPC:', refreshError);
                }

                try {
                    if (typeof window.loadCurrentLocation === 'function') {
                        await window.loadCurrentLocation();
                    }
                } catch (locationError) {
                    console.warn('Failed to refresh location after dismissing NPC:', locationError);
                }

                if (card && card.parentElement) {
                    card.remove();
                }

                return data;
            } finally {
                hideLocationOverlay();
            }
        }

        function setAddNpcStatus(message = '', type = null) {
            if (!addNpcStatus) {
                return;
            }
            addNpcStatus.textContent = message || '';
            addNpcStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                addNpcStatus.classList.add('is-error');
            } else if (type === 'success') {
                addNpcStatus.classList.add('is-success');
            }
        }

        function setLoadGameStatus(message, variant = null) {
            if (!loadGameStatus) {
                return;
            }
            loadGameStatus.textContent = message || '';
            if (variant) {
                loadGameStatus.dataset.variant = variant;
            } else {
                delete loadGameStatus.dataset.variant;
            }
        }

        function getLoadGameSourceLabel({ source = currentLoadGameSource, plural = false } = {}) {
            const normalizedSource = source === 'autosaves' ? 'autosaves' : 'saves';
            if (plural) {
                return normalizedSource === 'autosaves' ? 'autosaves' : 'saved games';
            }
            return normalizedSource === 'autosaves' ? 'autosave' : 'saved game';
        }

        function populateLoadGameOptions(saves = [], { emptyLabel = null } = {}) {
            if (!loadGameSelect) {
                return;
            }

            loadGameSelect.innerHTML = '';

            if (!Array.isArray(saves) || saves.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = emptyLabel || `No ${getLoadGameSourceLabel({ plural: true })} available`;
                option.disabled = true;
                loadGameSelect.appendChild(option);
                loadGameSelect.disabled = true;
                if (loadGameConfirmBtn) {
                    loadGameConfirmBtn.disabled = true;
                }
                return;
            }

            loadGameSelect.disabled = false;
            saves.forEach((save, index) => {
                const option = document.createElement('option');
                option.value = save.saveName;
                option.dataset.source = save.source === 'autosaves' ? 'autosaves' : currentLoadGameSource;
                const timestamp = new Date(save.timestamp);
                const playerName = save.playerName || 'Unknown';
                const levelLabel = save.playerLevel !== undefined && save.playerLevel !== null
                    ? save.playerLevel
                    : '?';
                const timestampLabel = Number.isFinite(timestamp.getTime())
                    ? timestamp.toLocaleString()
                    : 'Unknown time';
                const prefix = currentLoadGameSource === 'autosaves' ? 'Autosave' : 'Save';
                const locationName = typeof save.currentLocationName === 'string'
                    ? save.currentLocationName.trim()
                    : '';
                const locationSuffix = locationName ? ` @ ${locationName}` : '';
                option.textContent = `${prefix}: ${playerName} (Level ${levelLabel})${locationSuffix} ‚Ä¢ ${timestampLabel}`;
                if (index === 0) {
                    option.selected = true;
                }
                loadGameSelect.appendChild(option);
            });

            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = false;
            }
        }

        async function refreshLoadGameList(source = 'saves') {
            const normalizedSource = source === 'autosaves' ? 'autosaves' : 'saves';
            currentLoadGameSource = normalizedSource;

            if (loadGameSourceSelect && loadGameSourceSelect.value !== normalizedSource) {
                loadGameSourceSelect.value = normalizedSource;
            }

            const requestId = ++loadGameFetchToken;
            const pluralLabel = getLoadGameSourceLabel({ source: normalizedSource, plural: true });

            if (loadGameSelect) {
                loadGameSelect.innerHTML = '';
                const loadingOption = document.createElement('option');
                loadingOption.value = '';
                loadingOption.textContent = `Loading ${pluralLabel}‚Ä¶`;
                loadingOption.disabled = true;
                loadingOption.selected = true;
                loadGameSelect.appendChild(loadingOption);
                loadGameSelect.disabled = true;
            }

            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = true;
            }

            setLoadGameStatus(`Loading ${pluralLabel}‚Ä¶`, 'info');

            try {
                const response = await fetch(`/api/saves?type=${normalizedSource}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json().catch(() => ({}));
                const rawSaves = Array.isArray(result?.saves) ? result.saves : [];

                if (requestId !== loadGameFetchToken) {
                    return;
                }

                const safeParseTimestamp = (value) => {
                    const parsed = new Date(value || '').getTime();
                    return Number.isFinite(parsed) ? parsed : 0;
                };

                loadGameSaves = [...rawSaves].sort((a, b) => {
                    return safeParseTimestamp(b.timestamp) - safeParseTimestamp(a.timestamp);
                });

                populateLoadGameOptions(loadGameSaves, {
                    emptyLabel: `No ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })} available`
                });

                if (loadGameSaves.length) {
                    setLoadGameStatus('', null);
                    if (loadGameSelect && !loadGameSelect.disabled) {
                        loadGameSelect.focus();
                    }
                } else {
                    setLoadGameStatus(`No ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })} available.`, 'info');
                }
            } catch (error) {
                if (requestId !== loadGameFetchToken) {
                    return;
                }

                loadGameSaves = [];
                populateLoadGameOptions([], {
                    emptyLabel: `Unable to load ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })}`
                });
                setLoadGameStatus(`Failed to load ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })}: ${error.message}`, 'error');
            }
        }

        function openLoadGameModal({ initialSource = 'saves' } = {}) {
            if (!loadGameModal || !npcModalBackdrop) {
                return;
            }

            loadGameSaves = [];
            currentLoadGameSource = initialSource === 'autosaves' ? 'autosaves' : 'saves';
            if (loadGameSourceSelect) {
                loadGameSourceSelect.value = currentLoadGameSource;
            }
            if (loadGameSelect) {
                loadGameSelect.innerHTML = '';
                loadGameSelect.disabled = true;
            }
            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = true;
            }
            setLoadGameStatus('', null);

            npcModalBackdrop.removeAttribute('hidden');
            loadGameModal.removeAttribute('hidden');
            loadGameModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(loadGameModal);

            setTimeout(() => {
                if (loadGameSelect && !loadGameSelect.disabled) {
                    loadGameSelect.focus();
                } else if (loadGameCancelBtn) {
                    loadGameCancelBtn.focus();
                }
            }, 50);
        }

        function closeLoadGameModal({ focusTrigger = false } = {}) {
            if (!loadGameModal) {
                return;
            }

            loadGameFetchToken += 1;
            currentLoadGameSource = 'saves';
            loadGameModal.setAttribute('aria-hidden', 'true');
            loadGameModal.setAttribute('hidden', '');
            setLoadGameStatus('');
            loadGameSaves = [];
            if (loadGameSelect) {
                loadGameSelect.innerHTML = '';
                loadGameSelect.disabled = false;
            }
            if (loadGameSourceSelect) {
                loadGameSourceSelect.value = 'saves';
            }
            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = false;
                loadGameConfirmBtn.textContent = 'Load Game';
            }
            if (loadGameCancelBtn) {
                loadGameCancelBtn.disabled = false;
            }

            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalBackdrop && inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }

            if (focusTrigger && loadGameTriggerButton) {
                loadGameTriggerButton.focus();
            }
            loadGameTriggerButton = null;
        }

        function openAddNpcModal() {
            if (!addNpcModal || !npcModalBackdrop) {
                return;
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                alert('No active location available to add NPCs.');
                return;
            }

            if (addNpcForm) {
                addNpcForm.reset();
            }
            const baseLevel = Number.isFinite(Number(lastRenderedLocation.baseLevel))
                ? Number(lastRenderedLocation.baseLevel)
                : (Number.isFinite(Number(lastRenderedLocation.level)) ? Number(lastRenderedLocation.level) : '');
            if (addNpcLevelInput) {
                addNpcLevelInput.value = Number.isFinite(baseLevel) ? baseLevel : '';
            }
            setAddNpcStatus('', null);
            if (addNpcSaveBtn) {
                addNpcSaveBtn.disabled = false;
            }

            npcModalBackdrop.removeAttribute('hidden');
            addNpcModal.removeAttribute('hidden');
            addNpcModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(addNpcModal);

            setTimeout(() => {
                addNpcNameInput?.focus();
            }, 50);
        }

        async function openAddThingModal({ itemOrScenery = 'item' } = {}) {
            if (!thingEditModal || !npcModalBackdrop) {
                return;
            }

            const activeLocation = (lastRenderedLocation && lastRenderedLocation.id)
                ? lastRenderedLocation
                : null;
            if (!activeLocation) {
                alert('No active location available to add items.');
                return;
            }

            const baseLevel = Number.isFinite(Number(activeLocation.baseLevel))
                ? Number(activeLocation.baseLevel)
                : (Number.isFinite(Number(activeLocation.level)) ? Number(activeLocation.level) : null);

            try {
                await showThingEditModal({}, 'location', {
                    mode: 'create',
                    itemOrScenery,
                    location: activeLocation
                });
            } catch (error) {
                console.warn('Failed to open item creation modal:', error);
                return;
            }

            if (thingEditLevelInput) {
                if (Number.isFinite(baseLevel)) {
                    thingEditLevelInput.value = baseLevel;
                } else {
                    thingEditLevelInput.value = '';
                }
            }

            updateThingEditStatus('');
        }

        function closeAddNpcModal({ focusTrigger = false } = {}) {
            if (!addNpcModal) {
                return;
            }

            addNpcModal.setAttribute('aria-hidden', 'true');
            addNpcModal.setAttribute('hidden', '');

            if (addNpcForm) {
                addNpcForm.reset();
            }
            if (addNpcSaveBtn) {
                addNpcSaveBtn.disabled = false;
            }
            setAddNpcStatus('', null);

            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalBackdrop && inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }

            if (focusTrigger && addNpcButton) {
                addNpcButton.focus();
            }
        }

        async function submitAddNpc(event) {
            if (event) {
                event.preventDefault();
            }

            if (!addNpcForm || !addNpcSaveBtn) {
                return;
            }

            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                setAddNpcStatus('No active location is available for adding NPCs.', 'error');
                return;
            }

            const name = addNpcNameInput?.value?.trim();

            const payload = {};
            if (name) {
                payload.name = name;
            }
            const shortDescription = addNpcShortDescriptionInput?.value?.trim();
            if (shortDescription) {
                payload.shortDescription = shortDescription;
            }
            const description = addNpcDescriptionInput?.value?.trim();
            if (description) {
                payload.description = description;
            }
            const role = addNpcRoleInput?.value?.trim();
            if (role) {
                payload.role = role;
            }
            const className = addNpcClassInput?.value?.trim();
            if (className) {
                payload.class = className;
            }
            const race = addNpcRaceInput?.value?.trim();
            if (race) {
                payload.race = race;
            }

            const levelValueRaw = addNpcLevelInput?.value;
            if (levelValueRaw !== undefined && levelValueRaw !== null && String(levelValueRaw).trim() !== '') {
                const levelNumber = Number(levelValueRaw);
                if (Number.isFinite(levelNumber)) {
                    payload.level = Math.max(1, Math.round(levelNumber));
                }
            }

            const currencyValueRaw = addNpcCurrencyInput?.value;
            if (currencyValueRaw !== undefined && currencyValueRaw !== null && String(currencyValueRaw).trim() !== '') {
                const currencyNumber = Number(currencyValueRaw);
                if (Number.isFinite(currencyNumber) && currencyNumber >= 0) {
                    payload.currency = Math.round(currencyNumber);
                }
            }

            setAddNpcStatus('Creating NPC‚Ä¶', null);
            addNpcSaveBtn.disabled = true;

            let overlayShown = false;
            try {
                const response = await fetch(`/api/locations/${encodeURIComponent(lastRenderedLocation.id)}/npcs`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                closeAddNpcModal({ focusTrigger: false });
                showLocationOverlay('Refreshing characters...');
                overlayShown = true;

                if (data.location) {
                    lastRenderedLocation = JSON.parse(JSON.stringify(data.location));
                    await window.updateLocationDisplay(data.location);
                }
            } catch (error) {
                console.warn('Failed to create NPC:', error);
                setAddNpcStatus(`Failed to create NPC: ${error?.message || 'Unknown error'}`, 'error');
                addNpcSaveBtn.disabled = false;
            } finally {
                if (overlayShown) {
                    hideLocationOverlay();
                }
            }
        }

        function setNewExitStatus(message = '', type = null) {
            if (!newExitStatus) {
                return;
            }
            newExitStatus.textContent = message || '';
            newExitStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                newExitStatus.classList.add('is-error');
            } else if (type === 'success') {
                newExitStatus.classList.add('is-success');
            }
        }

        function getNewExitRegionOption(regionId) {
            if (!regionId) {
                return null;
            }
            return newExitRegionsById.get(regionId) || null;
        }

        function findRegionAndLocationOptionForLocationId(locationId) {
            if (!locationId || !(newExitRegionsById instanceof Map)) {
                return null;
            }
            for (const region of newExitRegionsById.values()) {
                if (!region || !Array.isArray(region.locations)) {
                    continue;
                }
                const match = region.locations.find(loc => loc && loc.id === locationId);
                if (match) {
                    return { region, location: match };
                }
            }
            return null;
        }

        function findExitMatchForPayload(locationData = {}, payload = {}, createdInfo = {}) {
            const exits = Object.values(locationData.exits || {});
            if (!exits.length) {
                return null;
            }

            const normalizedType = (payload.type || '').toLowerCase();

            if (normalizedType === 'region') {
                const regionId = createdInfo?.regionId || payload.regionId || null;
                const stubId = createdInfo?.stubId || null;
                if (stubId) {
                    const stubMatch = exits.find(exit => exit && exit.destination === stubId);
                    if (stubMatch) {
                        return stubMatch;
                    }
                }
                if (regionId) {
                    const regionMatch = exits.find(exit => exit && exit.destinationRegion === regionId);
                    if (regionMatch) {
                        return regionMatch;
                    }
                }
            }

            const targetLocationId = payload.locationId
                || createdInfo?.destinationId
                || createdInfo?.stubId
                || null;

            if (targetLocationId) {
                const locationMatch = exits.find(exit => exit && exit.destination === targetLocationId);
                if (locationMatch) {
                    return locationMatch;
                }
            }

            return null;
        }

        async function ensureNewExitOptionsLoaded(force = false) {
            if (!force && newExitOptionsCache && Array.isArray(newExitOptionsCache.regions)) {
                return newExitOptionsCache;
            }

            const originLocationId = lastRenderedLocation?.id;
            const query = originLocationId ? `?originLocationId=${encodeURIComponent(originLocationId)}` : '';
            const response = await fetch(`/api/exits/options${query}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            if (!data?.success || !Array.isArray(data.regions)) {
                throw new Error(data?.error || 'Invalid response when loading region data');
            }

            const filteredRegions = Array.isArray(data.regions)
                ? data.regions
                    .filter(region => {
                        const name = typeof region?.name === 'string' ? region.name.trim() : '';
                        return Boolean(name);
                    })
                    .map(region => ({
                        ...region,
                        name: region.name.trim(),
                        locations: Array.isArray(region.locations)
                            ? region.locations
                                .filter(loc => {
                                    const name = typeof loc?.name === 'string' ? loc.name.trim() : '';
                                    return Boolean(name);
                                })
                                .map(loc => ({
                                    ...loc,
                                    name: loc.name.trim()
                                }))
                            : []
                    }))
                : [];

            newExitOptionsCache = {
                ...data,
                regions: filteredRegions
            };
            newExitRegionsById = new Map();
            filteredRegions.forEach(region => {
                const normalizedLocations = Array.isArray(region.locations)
                    ? region.locations.map(loc => ({
                        id: loc.id,
                        name: loc.name,
                        isStub: Boolean(loc.isStub),
                        regionId: loc.regionId || region.id,
                        isRegionEntryStub: Boolean(loc.isRegionEntryStub)
                    }))
                    : [];
                newExitRegionsById.set(region.id, {
                    id: region.id,
                    name: region.name,
                    isStub: Boolean(region.isStub),
                    locations: normalizedLocations
                });
            });

            return newExitOptionsCache;
        }

        function populateNewExitRegionSelect(defaultRegionId = '') {
            if (!newExitRegionSelect) {
                return;
            }

            const previousValue = defaultRegionId !== undefined ? defaultRegionId : newExitRegionSelect.value;
            newExitRegionSelect.innerHTML = '';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Create new region';
            newExitRegionSelect.appendChild(defaultOption);

            if (newExitOptionsCache?.regions) {
                newExitOptionsCache.regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region.id;
                    option.textContent = region.isStub ? `${region.name} (pending)` : region.name;
                    option.dataset.isStub = region.isStub ? 'true' : 'false';
                    newExitRegionSelect.appendChild(option);
                });
            }

            if (previousValue && Array.from(newExitRegionSelect.options).some(opt => opt.value === previousValue)) {
                newExitRegionSelect.value = previousValue;
            } else {
                newExitRegionSelect.value = '';
            }

            handleNewExitRegionChange();
        }

        function populateNewExitLocationSelect(regionId) {
            if (!newExitLocationSelect || !newExitLocationGroup) {
                return;
            }

            if (!regionId) {
                newExitLocationSelect.innerHTML = '';
                newExitLocationGroup.setAttribute('hidden', '');
                return;
            }

            const regionOption = getNewExitRegionOption(regionId);

            newExitLocationGroup.removeAttribute('hidden');
            newExitLocationSelect.innerHTML = '';

            const createOption = document.createElement('option');
            createOption.value = '';
            createOption.textContent = 'Create new location';
            createOption.dataset.isCreateOption = 'true';
            newExitLocationSelect.appendChild(createOption);

            if (regionOption && Array.isArray(regionOption.locations)) {
                regionOption.locations.forEach(loc => {
                    const option = document.createElement('option');
                    option.value = loc.id;
                    option.textContent = loc.name;
                    option.dataset.isStub = loc.isStub ? 'true' : 'false';
                    option.dataset.regionId = loc.regionId || regionOption.id;
                    newExitLocationSelect.appendChild(option);
                });
            }

            newExitLocationSelect.selectedIndex = 0;

            handleNewExitLocationChange();
        }

        function shouldShowNewExitTextFields() {
            const selectedLocationId = newExitLocationSelect?.value || '';
            return !selectedLocationId;
        }

        function syncNewExitFieldVisibility() {
            const selectedRegionId = newExitRegionSelect?.value?.trim() || '';
            const selectedLocationId = newExitLocationSelect?.value?.trim() || '';
            const showFields = !selectedLocationId;
            const creatingNewRegion = !selectedRegionId;
            const currentRegionId = lastRenderedLocation?.regionId || lastRenderedLocation?.stubMetadata?.regionId || null;
            if (newExitNameGroup) {
                if (showFields) {
                    newExitNameGroup.removeAttribute('hidden');
                } else {
                    newExitNameGroup.setAttribute('hidden', '');
                }
            }
            if (newExitDescriptionGroup) {
                if (showFields) {
                    newExitDescriptionGroup.removeAttribute('hidden');
                } else {
                    newExitDescriptionGroup.setAttribute('hidden', '');
                }
            }
            if (newExitVehicleGroup) {
                if (showFields) {
                    newExitVehicleGroup.removeAttribute('hidden');
                } else {
                    newExitVehicleGroup.setAttribute('hidden', '');
                    if (newExitVehicleInput) {
                        newExitVehicleInput.value = '';
                    }
                }
            }
            if (newExitChildRegionGroup) {
                if (creatingNewRegion && currentRegionId) {
                    newExitChildRegionGroup.removeAttribute('hidden');
                } else {
                    newExitChildRegionGroup.setAttribute('hidden', '');
                    if (newExitChildRegionCheckbox) {
                        newExitChildRegionCheckbox.checked = false;
                    }
                }
            }
        }

        function handleNewExitRegionChange() {
            const regionId = newExitRegionSelect?.value || '';
            populateNewExitLocationSelect(regionId);
            syncNewExitFieldVisibility();
        }

        function handleNewExitLocationChange() {
            syncNewExitFieldVisibility();
            const selectedLocationId = newExitLocationSelect?.value || '';
            if (selectedLocationId) {
                if (newExitNameInput) {
                    newExitNameInput.value = '';
                }
                if (newExitDescriptionInput) {
                    newExitDescriptionInput.value = '';
                }
                if (newExitVehicleInput) {
                    newExitVehicleInput.value = '';
                }
            }
        }


        async function openNewExitModal(context = null) {
            if (!newExitModal || !npcModalBackdrop) {
                return;
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                alert('No active location available to add an exit.');
                return;
            }

            const isEditing = Boolean(context && context.mode === 'edit' && context.exit && context.exitId);
            editingExitContext = isEditing
                ? {
                    locationId: context.locationId || lastRenderedLocation.id,
                    exitId: context.exitId,
                    exit: context.exit,
                    direction: context.direction || null
                }
                : null;

            if (newExitForm) {
                newExitForm.reset();
            }
            if (newExitRegionSelect) {
                newExitRegionSelect.value = '';
            }
            if (newExitLocationSelect) {
                newExitLocationSelect.innerHTML = '';
            }
            if (newExitLocationGroup) {
                newExitLocationGroup.setAttribute('hidden', '');
            }
            if (newExitNameGroup) {
                newExitNameGroup.removeAttribute('hidden');
            }
            if (newExitDescriptionGroup) {
                newExitDescriptionGroup.removeAttribute('hidden');
            }
            if (newExitVehicleGroup) {
                newExitVehicleGroup.removeAttribute('hidden');
            }
            if (newExitVehicleInput) {
                newExitVehicleInput.value = '';
            }
            if (newExitChildRegionGroup) {
                newExitChildRegionGroup.setAttribute('hidden', '');
            }
            if (newExitChildRegionCheckbox) {
                newExitChildRegionCheckbox.checked = false;
            }

            if (newExitModalTitle) {
                newExitModalTitle.textContent = isEditing ? 'Edit Exit' : 'Add New Exit';
            }
            if (newExitSaveBtn) {
                newExitSaveBtn.textContent = isEditing ? 'Update Exit' : 'Create Exit';
                newExitSaveBtn.disabled = false;
            }
            setNewExitStatus('', null);
            syncNewExitFieldVisibility();

            let loadError = null;
            try {
                await ensureNewExitOptionsLoaded();
                populateNewExitRegionSelect('');
                if (isEditing && editingExitContext?.exit) {
                    const exit = editingExitContext.exit;
                    const destinationId = exit.destination || null;
                    const destinationRegionId = exit.destinationRegion || null;

                    let selectedRegionId = null;
                    let selectedLocationId = null;

                    if (destinationId) {
                        const regionMatch = findRegionAndLocationOptionForLocationId(destinationId);
                        if (regionMatch) {
                            selectedRegionId = regionMatch.region.id;
                            selectedLocationId = regionMatch.location.id;
                        }
                    }

                    if (!selectedRegionId && destinationRegionId) {
                        selectedRegionId = destinationRegionId;
                        selectedLocationId = destinationId || '';
                    }

                    if (newExitRegionSelect) {
                        if (selectedRegionId && Array.from(newExitRegionSelect.options).some(opt => opt.value === selectedRegionId)) {
                            newExitRegionSelect.value = selectedRegionId;
                        } else {
                            newExitRegionSelect.value = '';
                        }
                    }

                    handleNewExitRegionChange();

                    if (selectedLocationId && newExitLocationSelect) {
                        if (Array.from(newExitLocationSelect.options).some(opt => opt.value === selectedLocationId)) {
                            newExitLocationSelect.value = selectedLocationId;
                        } else {
                            newExitLocationSelect.value = '';
                        }
                        handleNewExitLocationChange();
                    } else {
                        handleNewExitLocationChange();
                    }

                    const showTextFields = shouldShowNewExitTextFields();
                    if (showTextFields && newExitNameInput) {
                        newExitNameInput.value = exit.destinationRegionName
                            || exit.destinationName
                            || exit.description
                            || '';
                    }
                    if (newExitDescriptionInput) {
                        newExitDescriptionInput.value = exit.description || '';
                    }
                    if (newExitVehicleInput) {
                        newExitVehicleInput.value = exit.vehicleType || '';
                    }
                } else {
                    handleNewExitRegionChange();
                }
            } catch (error) {
                loadError = error;
                setNewExitStatus(`Failed to load region information: ${error?.message || 'Unknown error'}`, 'error');
                if (newExitSaveBtn) {
                    newExitSaveBtn.disabled = true;
                }
            }

            npcModalBackdrop.removeAttribute('hidden');
            newExitModal.removeAttribute('hidden');
            newExitModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(newExitModal);

            setTimeout(() => {
                if (loadError) {
                    newExitCloseBtn?.focus();
                } else if (newExitRegionSelect) {
                    newExitRegionSelect.focus();
                } else {
                    newExitNameInput?.focus();
                }
            }, 50);
        }

        async function submitNewExit(event) {
            if (event) {
                event.preventDefault();
            }

            if (!newExitForm || !newExitSaveBtn) {
                return;
            }

            const isEditing = Boolean(editingExitContext);
            const activeLocationId = isEditing
                ? (editingExitContext?.locationId || lastRenderedLocation?.id || null)
                : (lastRenderedLocation?.id || null);

            if (!activeLocationId) {
                setNewExitStatus('No active location is available for managing exits.', 'error');
                return;
            }

            const selectedRegionId = newExitRegionSelect?.value?.trim() || '';
            const selectedLocationId = newExitLocationSelect?.value?.trim() || '';
            const nameFieldsVisible = shouldShowNewExitTextFields();
            const name = newExitNameInput?.value?.trim() || '';
            const description = newExitDescriptionInput?.value?.trim() || '';
            const vehicleTypeInput = newExitVehicleInput?.value?.trim() || '';

            if (nameFieldsVisible && !name) {
                setNewExitStatus('Please provide a name for the exit.', 'error');
                newExitNameInput?.focus();
                return;
            }

            const creatingNewRegion = !selectedRegionId;
            const creatingNewLocation = Boolean(
                selectedRegionId
                && (!selectedLocationId || !Array.from(newExitLocationSelect?.options || []).some(opt => opt.value === selectedLocationId))
            );
            const usingExistingLocation = Boolean(selectedRegionId && selectedLocationId);
            const childRegionSelected = Boolean(creatingNewRegion && newExitChildRegionCheckbox?.checked);
            const parentRegionIdForChild = childRegionSelected
                ? (lastRenderedLocation?.regionId || lastRenderedLocation?.stubMetadata?.regionId || null)
                : null;

            const type = creatingNewRegion ? 'region' : 'location';
            const locationOption = selectedLocationId
                ? Array.from(newExitLocationSelect?.options || []).find(opt => opt.value === selectedLocationId)
                : null;
            const regionOption = getNewExitRegionOption(selectedRegionId);
            const locationName = usingExistingLocation
                ? (locationOption?.textContent?.trim() || locationOption?.value || '')
                : creatingNewLocation
                    ? name || 'New location'
                    : '';

            let placeholderButton = null;
            if (!isEditing && locationExitsList) {
                const emptyState = locationExitsList.querySelector('.no-exits');
                if (emptyState) {
                    emptyState.remove();
                }
                placeholderButton = document.createElement('button');
                placeholderButton.type = 'button';
                placeholderButton.className = 'exit-button exit-button-pending';
                placeholderButton.disabled = true;
                let placeholderLabel = name;
                if (!placeholderLabel) {
                    if (creatingNewLocation) {
                        placeholderLabel = locationName || 'New location';
                    } else if (usingExistingLocation) {
                        placeholderLabel = locationOption?.textContent?.trim() || locationOption?.value || 'Selected location';
                    } else if (creatingNewRegion) {
                        placeholderLabel = regionOption?.name || regionOption?.id || 'Selected region';
                    } else {
                        placeholderLabel = 'New Exit';
                    }
                }
                placeholderButton.textContent = creatingNewRegion
                    ? `${placeholderLabel} (region)`
                    : placeholderLabel;
                placeholderButton.dataset.pendingExit = 'true';
                placeholderButton.classList.add('exit-button--unexplored');
                locationExitsList.appendChild(placeholderButton);
            }

            setNewExitStatus(isEditing ? 'Updating exit‚Ä¶' : 'Creating exit‚Ä¶', null);
            newExitSaveBtn.disabled = true;

            const payload = { type };
            if (!usingExistingLocation || name) {
                payload.name = name;
            }
            if (nameFieldsVisible || description) {
                payload.description = description;
            }
            if (selectedRegionId) {
                payload.regionId = selectedRegionId;
            }
            if (selectedLocationId) {
                payload.locationId = selectedLocationId;
            }
            if (creatingNewRegion && parentRegionIdForChild) {
                payload.parentRegionId = parentRegionIdForChild;
            }
            if (vehicleTypeInput) {
                payload.vehicleType = vehicleTypeInput;
            }

            const clientId = window.AIRPG_CLIENT_ID || null;
            if (clientId) {
                payload.clientId = clientId;
            }

            let overlayShown = false;
            try {
                const response = await fetch(`/api/locations/${encodeURIComponent(activeLocationId)}/exits`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setNewExitStatus('', null);
                newExitOptionsCache = null;
                newExitRegionsById = new Map();

                if (!isEditing) {
                    closeNewExitModal();
                    showLocationOverlay('Updating exits...');
                    overlayShown = true;

                    if (data.location) {
                        lastRenderedLocation = JSON.parse(JSON.stringify(data.location));
                        const exits = Array.isArray(data.location.exits)
                            ? data.location.exits
                            : Object.values(data.location.exits || {});
                        exits.forEach(exit => {
                            if (exit && exit.destination && typeof exit.destinationName === 'string' && exit.destinationName.trim()) {
                                locationCache[exit.destination] = exit.destinationName.trim();
                            }
                        });
                        await window.updateLocationDisplay(data.location);
                    }

                    const mapTab = document.querySelector('[data-tab="map"]');
                    if (mapTab && mapTab.classList.contains('active')) {
                        window.loadRegionMap?.();
                    }
                } else {
                    let finalLocation = data.location || null;
                    const createdInfo = data.created || {};
                    const originalExitId = editingExitContext?.exitId || null;

                    const newExitMatch = findExitMatchForPayload(finalLocation, payload, createdInfo);
                    const newExitId = newExitMatch?.id || null;

                    let shouldRemoveOriginal = false;
                    if (originalExitId && newExitId && originalExitId !== newExitId) {
                        shouldRemoveOriginal = true;
                    } else if (!newExitId && originalExitId) {
                        // If destination changed but we couldn't identify the new exit, fall back to comparing existing exit
                        const originalStillPresent = Object.values(finalLocation?.exits || {})
                            .some(exit => exit?.id === originalExitId);
                        if (originalStillPresent) {
                            const desiredDestination = payload.locationId
                                || createdInfo?.destinationId
                                || null;
                            const originalExit = Object.values(finalLocation?.exits || {})
                                .find(exit => exit?.id === originalExitId);
                            if (originalExit && desiredDestination && originalExit.destination !== desiredDestination) {
                                shouldRemoveOriginal = true;
                            }
                        }
                    }

                    if (shouldRemoveOriginal && originalExitId) {
                        try {
                            if (!overlayShown) {
                                showLocationOverlay('Updating exits...');
                                overlayShown = true;
                            }
                            const deleteResponse = await fetch(`/api/locations/${encodeURIComponent(activeLocationId)}/exits/${encodeURIComponent(originalExitId)}`, {
                                method: 'DELETE',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ clientId })
                            });
                            const deleteData = await deleteResponse.json().catch(() => ({}));
                            if (!deleteResponse.ok || !deleteData?.success) {
                                throw new Error(deleteData?.error || `HTTP ${deleteResponse.status}`);
                            }
                            finalLocation = deleteData.location || finalLocation;
                        } catch (deleteError) {
                            console.warn('Failed to remove previous exit during edit:', deleteError);
                            alert(`Exit update succeeded, but removing the previous exit failed: ${deleteError?.message || deleteError}`);
                        }
                    }

                    if (!overlayShown) {
                        showLocationOverlay('Updating exits...');
                        overlayShown = true;
                    }

                    const locationPayload = finalLocation || (await (async () => {
                        try {
                            const cacheBuster = Date.now().toString(36);
                            const locationResponse = await fetch(`/api/locations/${encodeURIComponent(activeLocationId)}?_=${cacheBuster}`, { cache: 'no-store' });
                            const locationData = await locationResponse.json().catch(() => ({}));
                            return locationResponse.ok && locationData?.success ? locationData.location : null;
                        } catch (_) {
                            return null;
                        }
                    })());

                    if (locationPayload) {
                        lastRenderedLocation = JSON.parse(JSON.stringify(locationPayload));
                        await window.updateLocationDisplay(locationPayload);
                    } else {
                        await window.loadCurrentLocation?.();
                    }

                    const mapTab = document.querySelector('[data-tab="map"]');
                    if (mapTab && mapTab.classList.contains('active')) {
                        window.loadRegionMap?.();
                    }

                    closeNewExitModal();
                }
            } catch (error) {
                console.warn('Failed to create exit:', error);
                setNewExitStatus(`${isEditing ? 'Failed to update exit' : 'Failed to create exit'}: ${error?.message || 'Unknown error'}`, 'error');
                if (!isEditing && placeholderButton && placeholderButton.isConnected) {
                    placeholderButton.remove();
                    if (locationExitsList && !locationExitsList.querySelector('.exit-button')) {
                        const emptyState = document.createElement('div');
                        emptyState.className = 'no-exits';
                        emptyState.textContent = 'No exits discovered yet.';
                        locationExitsList.appendChild(emptyState);
                    }
                }
            } finally {
                if (overlayShown) {
                    hideLocationOverlay();
                }
                newExitSaveBtn.disabled = false;
            }
        }

        function closeNewExitModal() {
            if (!newExitModal) {
                return;
            }
            newExitModal.setAttribute('aria-hidden', 'true');
            newExitModal.setAttribute('hidden', '');
            editingExitContext = null;
            if (newExitForm) {
                newExitForm.reset();
            }
            if (newExitRegionSelect) {
                newExitRegionSelect.value = '';
            }
            if (newExitLocationSelect) {
                newExitLocationSelect.innerHTML = '';
            }
            if (newExitLocationGroup) {
                newExitLocationGroup.setAttribute('hidden', '');
            }
            if (newExitNameGroup) {
                newExitNameGroup.removeAttribute('hidden');
            }
            if (newExitDescriptionGroup) {
                newExitDescriptionGroup.removeAttribute('hidden');
            }
            if (newExitVehicleGroup) {
                newExitVehicleGroup.removeAttribute('hidden');
            }
            if (newExitVehicleInput) {
                newExitVehicleInput.value = '';
            }
            if (newExitChildRegionGroup) {
                newExitChildRegionGroup.setAttribute('hidden', '');
            }
            if (newExitChildRegionCheckbox) {
                newExitChildRegionCheckbox.checked = false;
            }
            setNewExitStatus('', null);
            if (newExitSaveBtn) {
                newExitSaveBtn.textContent = 'Create Exit';
                newExitSaveBtn.disabled = false;
            }
            if (newExitModalTitle) {
                newExitModalTitle.textContent = 'Add New Exit';
            }
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalBackdrop && inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
            if (newExitButton) {
                newExitButton.focus();
            }
        }

        function closeNpcViewModal() {
            if (!npcViewModal) {
                return;
            }
            npcViewModal.setAttribute('aria-hidden', 'true');
            npcViewModal.setAttribute('hidden', '');
            currentNpcViewId = null;
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeThingEditModal() {
            if (!thingEditModal) {
                return;
            }
            thingEditModal.setAttribute('aria-hidden', 'true');
            thingEditModal.setAttribute('hidden', '');
            updateThingEditStatus('');
            currentThingEditId = null;
            currentThingEditContext = null;
            currentThingEditMode = 'edit';
            currentThingCreationLocation = null;
            if (thingEditForm) {
                thingEditForm.reset();
                delete thingEditForm.dataset.thingId;
                delete thingEditForm.dataset.thingContext;
                delete thingEditForm.dataset.thingMode;
            }
            if (thingMetadataList) {
                thingMetadataList.innerHTML = '';
            }
            if (thingAttributeBonusesList) {
                thingAttributeBonusesList.innerHTML = '';
            }
            if (thingStatusEffectsList) {
                thingStatusEffectsList.innerHTML = '';
            }
            populateThingCauseStatusEffect(null);
            if (thingEditRarityInput) {
                thingEditRarityInput.innerHTML = '';
            }
            if (thingEditSlotSelect) {
                thingEditSlotSelect.innerHTML = '';
            }
            currentThingLockedMetadata = {};
            const npcModalHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const npcInventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const npcViewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalHidden && npcInventoryHidden && npcViewHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        if (loadGameCancelBtn) {
            loadGameCancelBtn.addEventListener('click', () => {
                closeLoadGameModal({ focusTrigger: true });
            });
        }

        if (loadGameCloseBtn) {
            loadGameCloseBtn.addEventListener('click', () => {
                closeLoadGameModal({ focusTrigger: true });
            });
        }

        if (loadGameSourceSelect) {
            loadGameSourceSelect.addEventListener('change', (event) => {
                const selectedSource = event.target.value === 'autosaves' ? 'autosaves' : 'saves';
                refreshLoadGameList(selectedSource);
            });
        }

        if (loadGameSelect && loadGameConfirmBtn) {
            loadGameSelect.addEventListener('dblclick', () => {
                if (!loadGameConfirmBtn.disabled) {
                    loadGameConfirmBtn.click();
                }
            });
            loadGameSelect.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    if (!loadGameConfirmBtn.disabled) {
                        loadGameConfirmBtn.click();
                    }
                }
            });
        }

        if (loadGameConfirmBtn) {
            loadGameConfirmBtn.addEventListener('click', async () => {
                if (!loadGameSelect || loadGameSelect.disabled) {
                    setLoadGameStatus(`No ${getLoadGameSourceLabel({ plural: true })} available.`, 'error');
                    return;
                }

                const saveName = loadGameSelect.value;
                if (!saveName) {
                    setLoadGameStatus(`Select a ${getLoadGameSourceLabel()} to load.`, 'error');
                    loadGameSelect.focus();
                    return;
                }

                const selectedSave = loadGameSaves.find(save => save.saveName === saveName);
                if (!selectedSave) {
                    setLoadGameStatus(`Selected ${getLoadGameSourceLabel()} could not be found.`, 'error');
                    return;
                }

                const selectedOption = loadGameSelect.selectedOptions ? loadGameSelect.selectedOptions[0] : null;
                const optionSource = selectedOption?.dataset?.source === 'autosaves' ? 'autosaves' : null;
                const saveSource = optionSource
                    || (selectedSave?.source === 'autosaves' ? 'autosaves' : (currentLoadGameSource === 'autosaves' ? 'autosaves' : 'saves'));
                const singularLabel = getLoadGameSourceLabel({ source: saveSource, plural: false });

                const originalLabel = loadGameConfirmBtn.textContent;
                try {
                    loadGameConfirmBtn.disabled = true;
                    loadGameConfirmBtn.textContent = 'Loading...';
                    if (loadGameCancelBtn) {
                        loadGameCancelBtn.disabled = true;
                    }
                    setLoadGameStatus(`Loading ${singularLabel}‚Ä¶`, 'info');

                    const loadResponse = await fetch('/api/load', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ saveName, saveType: saveSource })
                    });

                    const loadResult = await loadResponse.json().catch(() => ({}));

                    if (loadResponse.ok && loadResult?.success) {
                        closeLoadGameModal();
                        window.location.reload();
                    } else {
                        const errorMessage = loadResult?.error || `HTTP ${loadResponse.status}`;
                        setLoadGameStatus(errorMessage, 'error');
                        loadGameConfirmBtn.disabled = false;
                        loadGameConfirmBtn.textContent = originalLabel;
                        if (loadGameCancelBtn) {
                            loadGameCancelBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    setLoadGameStatus(error.message, 'error');
                    loadGameConfirmBtn.disabled = false;
                    loadGameConfirmBtn.textContent = originalLabel;
                    if (loadGameCancelBtn) {
                        loadGameCancelBtn.disabled = false;
                    }
                }
            });
        }

        if (npcAddSkillBtn) {
            npcAddSkillBtn.addEventListener('click', () => {
                createSkillRow({ name: '', value: '' });
                if (npcEditSkillsContainer) {
                    npcEditSkillsContainer.scrollTop = npcEditSkillsContainer.scrollHeight;
                }
            });
        }

        if (npcAddAbilityBtn) {
            npcAddAbilityBtn.addEventListener('click', () => {
                createAbilityRow({});
                if (npcEditAbilitiesContainer) {
                    npcEditAbilitiesContainer.scrollTop = npcEditAbilitiesContainer.scrollHeight;
                }
            });
        }

        if (npcEditCancelBtn) {
            npcEditCancelBtn.addEventListener('click', () => {
                closeNpcEditModal();
            });
        }

        if (npcEditCloseBtn) {
            npcEditCloseBtn.addEventListener('click', () => {
                closeNpcEditModal();
            });
        }

        if (npcInventoryCloseBtn) {
            npcInventoryCloseBtn.addEventListener('click', () => {
                closeNpcInventoryModal();
            });
        }

        if (npcDispositionCancelBtn) {
            npcDispositionCancelBtn.addEventListener('click', () => {
                closeNpcDispositionModal();
            });
        }

        if (npcDispositionCloseBtn) {
            npcDispositionCloseBtn.addEventListener('click', () => {
                closeNpcDispositionModal();
            });
        }

        if (npcDispositionForm) {
            npcDispositionForm.addEventListener('submit', submitNpcDispositions);
        }

        if (npcNeedsCancelBtn) {
            npcNeedsCancelBtn.addEventListener('click', () => {
                closeNpcNeedsModal();
            });
        }

        if (npcNeedsCloseBtn) {
            npcNeedsCloseBtn.addEventListener('click', () => {
                closeNpcNeedsModal();
            });
        }

        if (npcNeedsForm) {
            npcNeedsForm.addEventListener('submit', submitNpcNeeds);
        }

        if (npcMemoriesCancelBtn) {
            npcMemoriesCancelBtn.addEventListener('click', () => {
                closeNpcMemoriesModal();
            });
        }

        if (npcMemoriesCloseBtn) {
            npcMemoriesCloseBtn.addEventListener('click', () => {
                closeNpcMemoriesModal();
            });
        }

        if (npcMemoriesSaveBtn) {
            npcMemoriesSaveBtn.addEventListener('click', async () => {
                await saveNpcMemories();
            });
            npcMemoriesSaveBtn.disabled = true;
        }

        if (npcMemoriesAddBtn) {
            npcMemoriesAddBtn.addEventListener('click', () => {
                if (!npcMemoriesList) {
                    return;
                }
                const row = createNpcMemoryRow('');
                npcMemoriesList.appendChild(row);
                const textarea = row.querySelector('.npc-memory-text');
                if (textarea) {
                    textarea.focus();
                }
                markNpcMemoriesDirty();
            });
        }

        if (npcMemoriesList) {
            npcMemoriesList.addEventListener('dragover', (event) => {
                if (!draggedNpcMemoryRow) {
                    return;
                }
                event.preventDefault();
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = 'move';
                }
                const targetRow = event.target.closest('.npc-memory-row');
                if (!targetRow) {
                    if (npcMemoriesList.lastElementChild !== draggedNpcMemoryRow) {
                        npcMemoriesList.appendChild(draggedNpcMemoryRow);
                        markNpcMemoriesDirty();
                    }
                    return;
                }
                if (targetRow === draggedNpcMemoryRow) {
                    return;
                }
                const targetRect = targetRow.getBoundingClientRect();
                const shouldInsertBefore = event.clientY < targetRect.top + targetRect.height / 2;
                if (shouldInsertBefore) {
                    npcMemoriesList.insertBefore(draggedNpcMemoryRow, targetRow);
                } else {
                    npcMemoriesList.insertBefore(draggedNpcMemoryRow, targetRow.nextSibling);
                }
                markNpcMemoriesDirty();
            });

            npcMemoriesList.addEventListener('drop', (event) => {
                if (!draggedNpcMemoryRow) {
                    return;
                }
                event.preventDefault();
                draggedNpcMemoryRow.classList.remove('dragging');
                draggedNpcMemoryRow = null;
                markNpcMemoriesDirty();
            });

            npcMemoriesList.addEventListener('dragend', () => {
                if (draggedNpcMemoryRow) {
                    draggedNpcMemoryRow.classList.remove('dragging');
                    draggedNpcMemoryRow = null;
                }
            });
        }

        if (npcGoalsCancelBtn) {
            npcGoalsCancelBtn.addEventListener('click', () => {
                closeNpcGoalsModal();
            });
        }

        if (npcGoalsCloseBtn) {
            npcGoalsCloseBtn.addEventListener('click', () => {
                closeNpcGoalsModal();
            });
        }

        if (npcGoalsSaveBtn) {
            npcGoalsSaveBtn.addEventListener('click', async () => {
                await saveNpcGoals();
            });
        }

        if (npcGoalsAddBtn) {
            npcGoalsAddBtn.addEventListener('click', () => {
                if (!npcGoalsList) {
                    return;
                }
                const row = createNpcGoalRow('');
                npcGoalsList.appendChild(row);
                const textarea = row.querySelector('.npc-goal-text');
                if (textarea) {
                    textarea.focus();
                }
                markNpcGoalsDirty();
            });
        }

        if (npcGoalsList) {
            npcGoalsList.addEventListener('dragover', (event) => {
                if (!draggedNpcGoalRow) {
                    return;
                }
                event.preventDefault();
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = 'move';
                }
                const targetRow = event.target.closest('.npc-goal-row');
                if (!targetRow) {
                    if (npcGoalsList.lastElementChild !== draggedNpcGoalRow) {
                        npcGoalsList.appendChild(draggedNpcGoalRow);
                        markNpcGoalsDirty();
                    }
                    return;
                }
                if (targetRow === draggedNpcGoalRow) {
                    return;
                }
                const targetRect = targetRow.getBoundingClientRect();
                const shouldInsertBefore = event.clientY < targetRect.top + targetRect.height / 2;
                if (shouldInsertBefore) {
                    npcGoalsList.insertBefore(draggedNpcGoalRow, targetRow);
                } else {
                    npcGoalsList.insertBefore(draggedNpcGoalRow, targetRow.nextSibling);
                }
                markNpcGoalsDirty();
            });

            npcGoalsList.addEventListener('drop', (event) => {
                if (!draggedNpcGoalRow) {
                    return;
                }
                event.preventDefault();
                draggedNpcGoalRow.classList.remove('dragging');
                draggedNpcGoalRow = null;
                markNpcGoalsDirty();
            });

            npcGoalsList.addEventListener('dragend', () => {
                if (draggedNpcGoalRow) {
                    draggedNpcGoalRow.classList.remove('dragging');
                    draggedNpcGoalRow = null;
                }
            });
        }

        if (addNpcButton) {
            addNpcButton.addEventListener('click', () => {
                openAddNpcModal();
            });
        }

        if (addThingButton) {
            addThingButton.addEventListener('click', () => {
                openAddThingModal();
            });
        }

        if (addNpcCancelBtn) {
            addNpcCancelBtn.addEventListener('click', () => {
                closeAddNpcModal({ focusTrigger: true });
            });
        }

        if (addNpcCloseBtn) {
            addNpcCloseBtn.addEventListener('click', () => {
                closeAddNpcModal({ focusTrigger: true });
            });
        }

        if (addNpcForm) {
            addNpcForm.addEventListener('submit', submitAddNpc);
        }

        if (newExitButton) {
            newExitButton.addEventListener('click', () => {
                openNewExitModal();
            });
        }

        if (newExitCancelBtn) {
            newExitCancelBtn.addEventListener('click', () => {
                closeNewExitModal();
            });
        }

        if (newExitCloseBtn) {
            newExitCloseBtn.addEventListener('click', () => {
                closeNewExitModal();
            });
        }

        if (newExitRegionSelect) {
            newExitRegionSelect.addEventListener('change', handleNewExitRegionChange);
        }

        if (newExitLocationSelect) {
            newExitLocationSelect.addEventListener('change', handleNewExitLocationChange);
        }

        if (newExitForm) {
            newExitForm.addEventListener('submit', submitNewExit);
        }

        if (npcInventoryFilterInput) {
            npcInventoryFilterInput.addEventListener('input', () => {
                renderNpcInventory(currentNpcInventory);
            });
        }

        if (npcInventorySlotFilter) {
            npcInventorySlotFilter.addEventListener('change', () => {
                renderNpcInventory(currentNpcInventory);
            });
        }

        const filterRadios = [
            npcInventoryShowAllRadio,
            npcInventoryEquippedOnlyRadio,
            npcInventoryEquippableOnlyRadio,
            npcInventoryNonEquippableOnlyRadio
        ].filter(Boolean);

        filterRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) {
                    renderNpcInventory(currentNpcInventory);
                }
            });
        });

        if (npcViewCloseBtn) {
            npcViewCloseBtn.addEventListener('click', () => {
                closeNpcViewModal();
            });
        }

        if (thingEditCancelBtn) {
            thingEditCancelBtn.addEventListener('click', () => {
                closeThingEditModal();
            });
        }

        if (thingEditCloseBtn) {
            thingEditCloseBtn.addEventListener('click', () => {
                closeThingEditModal();
            });
        }

        if (thingMetadataAddBtn) {
            thingMetadataAddBtn.addEventListener('click', () => {
                const row = createThingMetadataRow({});
                row?.querySelector('.thing-edit-metadata-key')?.focus();
            });
        }

        if (thingAttributeBonusAddBtn) {
            thingAttributeBonusAddBtn.addEventListener('click', async () => {
                await ensureAttributeDefinitions();
                const row = createThingAttributeBonusRow({});
                row?.querySelector('.thing-edit-bonus-attribute')?.focus();
            });
        }

        if (thingStatusEffectAddBtn) {
            thingStatusEffectAddBtn.addEventListener('click', () => {
                const row = createThingStatusEffectRow({});
                row?.querySelector('.thing-edit-status-description')?.focus();
            });
        }

        if (npcModalBackdrop) {
            npcModalBackdrop.addEventListener('click', (event) => {
                if (event.target === npcModalBackdrop) {
                    if (addNpcModal && !addNpcModal.hasAttribute('hidden')) {
                        closeAddNpcModal({ focusTrigger: true });
                    } else if (newExitModal && !newExitModal.hasAttribute('hidden')) {
                        closeNewExitModal();
                    } else if (npcNeedsModal && !npcNeedsModal.hasAttribute('hidden')) {
                        closeNpcNeedsModal();
                    } else if (npcMemoriesModal && !npcMemoriesModal.hasAttribute('hidden')) {
                        closeNpcMemoriesModal();
                    } else if (npcGoalsModal && !npcGoalsModal.hasAttribute('hidden')) {
                        closeNpcGoalsModal();
                    } else if (npcDispositionModal && !npcDispositionModal.hasAttribute('hidden')) {
                        closeNpcDispositionModal();
                    } else if (thingEditModal && !thingEditModal.hasAttribute('hidden')) {
                        closeThingEditModal();
                    } else if (npcViewModal && !npcViewModal.hasAttribute('hidden')) {
                        closeNpcViewModal();
                    } else if (npcInventoryModal && !npcInventoryModal.hasAttribute('hidden')) {
                        closeNpcInventoryModal();
                    } else if (npcEditModal && !npcEditModal.hasAttribute('hidden')) {
                        closeNpcEditModal();
                    }
                }
            });
        }

        if (npcEditModal) {
            npcEditModal.addEventListener('click', (event) => {
                if (event.target === npcEditModal) {
                    closeNpcEditModal();
                }
            });
        }

        if (npcInventoryModal) {
            npcInventoryModal.addEventListener('click', (event) => {
                if (event.target === npcInventoryModal) {
                    closeNpcInventoryModal();
                }
            });
        }

        if (npcViewModal) {
            npcViewModal.addEventListener('click', (event) => {
                if (event.target === npcViewModal) {
                    closeNpcViewModal();
                }
            });
        }

        if (thingEditModal) {
            thingEditModal.addEventListener('click', (event) => {
                if (event.target === thingEditModal) {
                    closeThingEditModal();
                }
            });
        }

        if (npcEditLevelInput) {
            npcEditLevelInput.addEventListener('input', updateNpcMaxHealth);
            npcEditLevelInput.addEventListener('change', updateNpcMaxHealth);
        }

        if (npcEditHealthAttributeSelect) {
            npcEditHealthAttributeSelect.addEventListener('change', updateNpcMaxHealth);
        }

        if (npcEditForm) {
            npcEditForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (!currentNpcEditId) {
                    updateNpcEditStatus('No NPC selected.', 'error');
                    return;
                }

                const payload = {};

                const trimmedName = npcEditNameInput?.value?.trim();
                if (trimmedName) {
                    payload.name = trimmedName;
                }
                if (npcEditDescriptionInput) {
                    payload.description = npcEditDescriptionInput.value ?? '';
                }
                if (npcEditShortDescriptionInput) {
                    payload.shortDescription = npcEditShortDescriptionInput.value ?? '';
                }
                if (npcEditRaceInput) {
                    payload.race = npcEditRaceInput.value ?? '';
                }
                if (npcEditClassInput) {
                    payload.class = npcEditClassInput.value ?? '';
                }
                if (npcEditPersonalityTypeInput) {
                    payload.personalityType = npcEditPersonalityTypeInput.value ?? '';
                }
                if (npcEditPersonalityTraitsInput) {
                    payload.personalityTraits = npcEditPersonalityTraitsInput.value ?? '';
                }
                if (npcEditPersonalityNotesInput) {
                    payload.personalityNotes = npcEditPersonalityNotesInput.value ?? '';
                }

                const parsedLevel = Number.parseInt(npcEditLevelInput?.value ?? '', 10);
                if (Number.isFinite(parsedLevel)) {
                    payload.level = parsedLevel;
                }

                const parsedHealth = Number.parseInt(npcEditHealthInput?.value ?? '', 10);
                if (Number.isFinite(parsedHealth)) {
                    payload.health = parsedHealth;
                }

                const parsedUnspent = Number.parseInt(npcEditUnspentInput?.value ?? '', 10);
                if (Number.isFinite(parsedUnspent) && parsedUnspent >= 0) {
                    payload.unspentSkillPoints = parsedUnspent;
                }

                const parsedCurrency = Number.parseInt(npcEditCurrencyInput?.value ?? '', 10);
                if (Number.isFinite(parsedCurrency) && parsedCurrency >= 0) {
                    payload.currency = parsedCurrency;
                }

                const parsedExperience = Number.parseInt(npcEditExperienceInput?.value ?? '', 10);
                if (Number.isFinite(parsedExperience) && parsedExperience >= 0) {
                    payload.experience = parsedExperience;
                }

                const attributes = getNpcAttributesFromInputs();
                payload.attributes = attributes;

                const selectedHealthAttribute = npcEditHealthAttributeSelect && !npcEditHealthAttributeSelect.disabled
                    ? (npcEditHealthAttributeSelect.value || '').trim()
                    : '';
                if (selectedHealthAttribute) {
                    payload.healthAttribute = selectedHealthAttribute;
                }

                const skills = {};
                if (npcEditSkillsContainer) {
                    npcEditSkillsContainer.querySelectorAll('.npc-skill-row').forEach(row => {
                        const name = row.querySelector('.npc-skill-name')?.value?.trim();
                        if (!name) {
                            return;
                        }
                        const valueInput = row.querySelector('.npc-skill-value');
                        const numeric = Number.parseInt(valueInput?.value ?? '', 10);
                        skills[name] = Number.isFinite(numeric) ? numeric : 0;
                    });
                }
                payload.skills = skills;

                const abilityEntries = [];
                if (npcEditAbilitiesContainer) {
                    npcEditAbilitiesContainer.querySelectorAll('.npc-ability-row').forEach(row => {
                        const abilityName = row.querySelector('.npc-ability-name')?.value?.trim();
                        if (!abilityName) {
                            return;
                        }
                        const abilityType = row.querySelector('.npc-ability-type')?.value || 'Passive';
                        const abilityLevel = Number.parseInt(row.querySelector('.npc-ability-level')?.value ?? '', 10);
                        const abilityDescription = row.querySelector('.npc-ability-description')?.value?.trim() || '';
                        abilityEntries.push({
                            name: abilityName,
                            type: abilityType,
                            level: Number.isFinite(abilityLevel) ? abilityLevel : 1,
                            description: abilityDescription
                        });
                    });
                }
                payload.abilities = abilityEntries;

                const knownSkillSet = typeof window.getKnownSkillNameSet === 'function'
                    ? window.getKnownSkillNameSet()
                    : new Set();
                const unseenSkillKeys = new Set();
                for (const skillName of Object.keys(skills)) {
                    if (typeof skillName !== 'string') {
                        continue;
                    }
                    const normalized = skillName.trim().toLowerCase();
                    if (normalized && !knownSkillSet.has(normalized)) {
                        unseenSkillKeys.add(normalized);
                    }
                }

                const shouldGenerateSkillDetails = unseenSkillKeys.size > 0;
                let reloadTriggered = false;

                try {
                    if (shouldGenerateSkillDetails) {
                        updateNpcEditStatus('Generating skill details...');
                        if (typeof showLocationOverlay === 'function') {
                            showLocationOverlay('Generating skill details...');
                        }
                    } else {
                        updateNpcEditStatus('Saving changes...');
                    }

                    if (npcEditSaveBtn) {
                        npcEditSaveBtn.disabled = true;
                    }

                    const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcEditId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to update NPC');
                    }

                    if (shouldGenerateSkillDetails) {
                        updateNpcEditStatus('Skills updated. Refreshing...', 'success');
                        reloadTriggered = true;
                        window.location.reload();
                        return;
                    }

                    updateNpcEditStatus('Changes saved.', 'success');

                    if (typeof window.loadCurrentLocation === 'function') {
                        await window.loadCurrentLocation();
                    }
                    window.refreshParty?.();

                    closeNpcEditModal();
                } catch (error) {
                    updateNpcEditStatus(error?.message || 'Failed to update NPC.', 'error');
                    if (shouldGenerateSkillDetails && typeof hideLocationOverlay === 'function') {
                        hideLocationOverlay();
                    }
                } finally {
                    if (npcEditSaveBtn && !reloadTriggered) {
                        npcEditSaveBtn.disabled = false;
                    }
                    if (shouldGenerateSkillDetails && !reloadTriggered && typeof hideLocationOverlay === 'function') {
                        hideLocationOverlay();
                    }
                }
            });
        }

        if (thingEditForm) {
            thingEditForm.addEventListener('submit', async (event) => {
                event.preventDefault();

                const mode = (thingEditForm.dataset.thingMode === 'create' || currentThingEditMode === 'create')
                    ? 'create'
                    : 'edit';

                if (mode === 'create') {
                    if (!currentThingCreationLocation || !currentThingCreationLocation.id) {
                        updateThingEditStatus('No active location is available for adding items.', 'error');
                        return;
                    }

                    const trimmedName = thingEditNameInput?.value?.trim();
                    if (!trimmedName) {
                        updateThingEditStatus('Please provide a name for the item.', 'error');
                        thingEditNameInput?.focus();
                        return;
                    }

                    updateThingEditStatus('Generating item...');
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = true;
                    }

                    const typeSelection = (thingEditTypeSelect?.value || '').toLowerCase() === 'scenery'
                        ? 'scenery'
                        : 'item';
                    const seed = {
                        name: trimmedName,
                        itemOrScenery: typeSelection
                    };

                    const descriptionValue = thingEditDescriptionInput?.value?.trim();
                    if (descriptionValue) {
                        seed.description = descriptionValue;
                    }

                    const detailValue = thingEditItemDetailInput?.value?.trim();
                    if (detailValue) {
                        seed.type = detailValue;
                    }

                    const slotValue = normalizeSlotType(thingEditSlotSelect?.value || '');
                    if (slotValue) {
                        addAvailableSlotType(slotValue);
                        seed.slot = slotValue;
                    }

                    const rarityKey = thingEditRarityInput?.value?.trim();
                    if (rarityKey) {
                        seed.rarity = getRarityLabel(rarityKey);
                    }

                    const payload = { seed };

                    const levelRaw = thingEditLevelInput?.value;
                    if (levelRaw !== undefined && levelRaw !== null && String(levelRaw).trim() !== '') {
                        const numericLevel = Number(levelRaw);
                        if (Number.isFinite(numericLevel)) {
                            payload.level = Math.max(1, Math.round(numericLevel));
                        }
                    }

                    let overlayShown = false;
                    try {
                        showLocationOverlay('Forging a new item...');
                        overlayShown = true;

                        const response = await fetch(`/api/locations/${encodeURIComponent(currentThingCreationLocation.id)}/things`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        const result = await response.json().catch(() => ({}));
                        if (!response.ok || !result?.success) {
                            throw new Error(result?.error || `Request failed with status ${response.status}`);
                        }

                        closeThingEditModal();

                        if (result.location) {
                            lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                            await window.updateLocationDisplay(result.location);
                        } else if (typeof window.loadCurrentLocation === 'function') {
                            await window.loadCurrentLocation();
                        }

                        window.refreshInventory?.();
                        window.refreshParty?.();
                    } catch (error) {
                        console.warn('Failed to create item:', error);
                        updateThingEditStatus(error?.message || 'Failed to create item.', 'error');
                    } finally {
                        if (overlayShown) {
                            hideLocationOverlay();
                        }
                        if (thingEditSaveBtn) {
                            thingEditSaveBtn.disabled = false;
                        }
                    }

                    return;
                }

                if (!currentThingEditId) {
                    updateThingEditStatus('No item selected.', 'error');
                    return;
                }

                updateThingEditStatus('');

                const payload = {};

                const trimmedName = thingEditNameInput?.value?.trim();
                if (trimmedName) {
                    payload.name = trimmedName;
                }

                if (thingEditDescriptionInput) {
                    payload.description = thingEditDescriptionInput.value ?? '';
                }

                if (thingEditTypeSelect) {
                    const typeValue = (thingEditTypeSelect.value || '').toLowerCase();
                    payload.thingType = typeValue === 'scenery' ? 'scenery' : 'item';
                }

                if (thingEditRarityInput) {
                    const rarityKey = thingEditRarityInput.value?.trim();
                    payload.rarity = rarityKey ? getRarityLabel(rarityKey) : null;
                }

                if (thingEditItemDetailInput) {
                    const detailValue = thingEditItemDetailInput.value?.trim();
                    payload.itemTypeDetail = detailValue || null;
                }

                if (thingEditSlotSelect) {
                    const slotValue = normalizeSlotType(thingEditSlotSelect.value);
                    if (slotValue) {
                        addAvailableSlotType(slotValue);
                    }
                    payload.slot = slotValue || null;
                }

                if (thingEditLevelInput) {
                    const parsedLevel = Number.parseInt(thingEditLevelInput.value ?? '', 10);
                    payload.level = Number.isFinite(parsedLevel) ? parsedLevel : null;
                }

                if (thingEditImageIdInput) {
                    const imageValue = thingEditImageIdInput.value?.trim();
                    payload.imageId = imageValue || null;
                }

                const metadataValue = collectThingMetadataEntries();
                const finalMetadata = { ...metadataValue };
                if (currentThingLockedMetadata && typeof currentThingLockedMetadata === 'object') {
                    Object.entries(currentThingLockedMetadata).forEach(([key, value]) => {
                        if (value !== undefined) {
                            finalMetadata[key] = value;
                        }
                    });
                }
                payload.metadata = finalMetadata;

                const attributeBonusesValue = collectThingAttributeBonuses();
                payload.attributeBonuses = attributeBonusesValue;

                const causeStatusEffectValue = collectThingCauseStatusEffect();
                payload.causeStatusEffect = causeStatusEffectValue;

                const statusEffectsValue = collectThingStatusEffects();
                payload.statusEffects = statusEffectsValue;

                if (!payload.thingType) {
                    payload.thingType = 'item';
                }

                try {
                    updateThingEditStatus('Saving changes...');
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = true;
                    }

                    const response = await fetch(`/api/things/${encodeURIComponent(currentThingEditId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    let result = {};
                    try {
                        result = await response.json();
                    } catch (_) {
                        // ignore JSON parse failures; handled below
                    }

                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to update item.');
                    }

                    const updatedThing = result?.thing || { ...thingDataCache.get(currentThingEditId), ...payload, id: currentThingEditId };
                    cacheThingData(updatedThing);

                    if (currentThingEditContext === 'npc-inventory' && Array.isArray(currentNpcInventory)) {
                        currentNpcInventory = currentNpcInventory.map(item => item && item.id === updatedThing.id ? updatedThing : item);
                        renderNpcInventory(currentNpcInventory);
                    }

                    updateThingEditStatus('Changes saved.', 'success');

                    try {
                        if (currentThingEditContext === 'location') {
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } else if (currentThingEditContext === 'npc-inventory') {
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } else {
                            if (typeof window.refreshInventory === 'function') {
                                await window.refreshInventory();
                            }
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        }
                        window.refreshParty?.();
                    } catch (refreshError) {
                        console.warn('Failed to refresh displays after item update:', refreshError);
                    }

                    closeThingEditModal();
                } catch (error) {
                    updateThingEditStatus(error?.message || 'Failed to update item.', 'error');
                } finally {
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = false;
                    }
                }
            });
        }

        function bindThingTooltip(element, thing) {
            if (!element || !thing) {
                return;
            }

            element.addEventListener('mouseenter', (event) => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.show === 'function') {
                    const description = thing.description || 'No description provided.';
                    const fallbackTooltip = `<div class="tooltip-thing is-item"><div class="tooltip-thing-description">${escapeHtml(description)}</div></div>`;
                    const tooltipContent = formatThingTooltip(thing) || fallbackTooltip;
                    window.floatingTooltipController.show(tooltipContent, event, { allowHTML: true });
                }
            });

            element.addEventListener('mousemove', (event) => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.move === 'function') {
                    window.floatingTooltipController.move(event);
                }
            });

            element.addEventListener('mouseleave', () => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.hide === 'function') {
                    window.floatingTooltipController.hide();
                }
            });
        }

        async function setNpcItemEquipped(npcId, item, shouldEquip, { slotName = null, slotType = null } = {}) {
            if (!npcId || !item || !item.id) {
                return;
            }

            try {
                const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}/equipment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        itemId: item.id,
                        action: shouldEquip ? 'equip' : 'unequip',
                        slotName: slotName || null,
                        slotType: slotType || null
                    })
                });

                const result = await response.json().catch(() => ({}));
                if (!response.ok || !result?.success) {
                    throw new Error(result?.error || `Request failed with status ${response.status}`);
                }

                const updatedInventory = Array.isArray(result.npc?.inventory) ? result.npc.inventory : [];
                currentNpcInventory = updatedInventory;
                renderNpcInventory(updatedInventory);
                window.refreshParty?.();
            } catch (error) {
                console.warn('Failed to update NPC equipment:', error);
                alert(`Failed to update equipment: ${error.message || error}`);
            }
        }

        function renderNpcInventory(items = []) {
            if (!npcInventoryGrid || !npcInventoryEmpty || !npcInventoryCount) {
                return;
            }

            const safeItems = Array.isArray(items) ? items : [];
            const filterValueRaw = typeof npcInventoryFilterInput?.value === 'string'
                ? npcInventoryFilterInput.value.trim().toLowerCase()
                : '';
            const equippedOnlyActive = Boolean(npcInventoryEquippedOnlyRadio?.checked);
            const equippableOnlyActive = Boolean(npcInventoryEquippableOnlyRadio?.checked);
            const nonEquippableOnlyActive = Boolean(npcInventoryNonEquippableOnlyRadio?.checked);

            // If both equippable-only and non-equippable-only are checked, treat as no equippable filter (show all)
            const applyEquippableFilter = !(equippableOnlyActive && nonEquippableOnlyActive);

            const normalizeSlotLabel = (value) => {
                if (value === undefined || value === null) {
                    return null;
                }
                const text = typeof value === 'string' ? value.trim() : String(value).trim();
                if (!text || text.toLowerCase() === 'n/a') {
                    return null;
                }
                return text;
            };

            const getItemSlotInfo = (item) => {
                const slotTypeValueRaw = typeof item?.slot === 'string' && item.slot.trim()
                    ? item.slot.trim()
                    : (typeof item?.metadata?.slot === 'string' && item.metadata.slot.trim()
                        ? item.metadata.slot.trim()
                        : null);
                const equippedSlot = normalizeSlotLabel(item?.equippedSlot);
                const rawSlot = normalizeSlotLabel(slotTypeValueRaw);
                const slotLabel = equippedSlot || rawSlot || null;
                const canModifyEquipment = Boolean(slotTypeValueRaw || equippedSlot);
                return {
                    slotTypeValueRaw,
                    equippedSlot,
                    rawSlot,
                    slotLabel,
                    canModifyEquipment
                };
            };

            const slotMap = new Map();
            if (npcInventorySlotFilter) {
                safeItems.forEach(item => {
                    const slotInfo = getItemSlotInfo(item);
                    const candidates = [
                        slotInfo.slotLabel,
                        slotInfo.rawSlot,
                        slotInfo.equippedSlot,
                        normalizeSlotLabel(item?.slot),
                        normalizeSlotLabel(item?.metadata?.slot)
                    ].filter(Boolean);
                    for (const candidate of candidates) {
                        const normalized = candidate.toLowerCase();
                        if (!slotMap.has(normalized)) {
                            slotMap.set(normalized, candidate);
                        }
                    }
                });

                const slotEntries = Array.from(slotMap.entries())
                    .sort((a, b) => a[1].localeCompare(b[1], undefined, { sensitivity: 'base' }));
                const signature = JSON.stringify(slotEntries.map(([value]) => value));
                if (npcInventorySlotFilter.dataset.optionSignature !== signature) {
                    npcInventorySlotFilter.innerHTML = '';
                    const allOption = document.createElement('option');
                    allOption.value = '';
                    allOption.textContent = 'All slots';
                    npcInventorySlotFilter.appendChild(allOption);
                    slotEntries.forEach(([value, label]) => {
                        const option = document.createElement('option');
                        option.value = value;
                        option.textContent = label;
                        npcInventorySlotFilter.appendChild(option);
                    });
                    npcInventorySlotFilter.dataset.optionSignature = signature;
                    if (npcInventorySlotFilter.value && !slotMap.has(npcInventorySlotFilter.value)) {
                        npcInventorySlotFilter.value = '';
                    }
                }
            }

            const filteredItems = safeItems.filter(item => {
                const slotInfo = getItemSlotInfo(item);
                const isEquipped = Boolean(item?.isEquipped || item?.equippedSlot);

                if (npcInventorySlotFilter && npcInventorySlotFilter.value) {
                    const normalizedSlotFilter = npcInventorySlotFilter.value.toLowerCase();
                    const slotCandidates = [slotInfo.slotLabel, slotInfo.rawSlot, slotInfo.equippedSlot]
                        .map(value => (typeof value === 'string' ? value.trim().toLowerCase() : null))
                        .filter(Boolean);
                    if (!slotCandidates.includes(normalizedSlotFilter)) {
                        return false;
                    }
                }

                if (equippedOnlyActive && !isEquipped) {
                    return false;
                }

                if (applyEquippableFilter) {
                    if (equippableOnlyActive && !slotInfo.canModifyEquipment) {
                        return false;
                    }
                    if (nonEquippableOnlyActive && slotInfo.canModifyEquipment) {
                        return false;
                    }
                }

                if (!filterValueRaw) {
                    return true;
                }

                const haystack = [
                    item?.name,
                    item?.description,
                    item?.thingType,
                    item?.rarity,
                    item?.slot,
                    item?.metadata?.slot,
                    item?.metadata?.properties,
                    slotInfo.canModifyEquipment ? 'equippable' : 'non-equippable'
                ];
                return haystack.some(value => typeof value === 'string' && value.toLowerCase().includes(filterValueRaw));
            });

            npcInventoryGrid.innerHTML = '';
            const filtersApplied = Boolean(filterValueRaw)
                || equippedOnlyActive
                || (applyEquippableFilter && (equippableOnlyActive || nonEquippableOnlyActive));

            npcInventoryCount.textContent = filtersApplied
                ? `${filteredItems.length} of ${safeItems.length} ${safeItems.length === 1 ? 'item' : 'items'}`
                : `${safeItems.length} ${safeItems.length === 1 ? 'item' : 'items'}`;

            if (!filteredItems.length) {
                npcInventoryGrid.style.display = 'none';
                npcInventoryEmpty.textContent = safeItems.length === 0
                    ? npcInventoryEmptyDefaultText
                    : 'No items match your filters.';
                npcInventoryEmpty.style.display = 'block';
            } else {
                npcInventoryGrid.style.display = 'flex';
                npcInventoryEmpty.textContent = npcInventoryEmptyDefaultText;
                npcInventoryEmpty.style.display = 'none';
            }

            filteredItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'location-entity-card inventory-card';

                const equipped = Boolean(item?.isEquipped || item?.equippedSlot);
                if (equipped) {
                    card.classList.add('is-equipped');
                }

                const slotInfo = getItemSlotInfo(item);

                const icon = document.createElement('div');
                icon.className = 'inventory-icon';
                renderEntityImage({
                    element: icon,
                    entityType: 'thing',
                    entityId: item.id,
                    imageId: item.imageId || null,
                    altText: item.name || 'Inventory item',
                    placeholderIcon: item.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ',
                    placeholderClass: 'location-entity-placeholder'
                });

                const name = document.createElement('div');
                name.className = 'inventory-name';
                name.textContent = item.name || 'Unknown Item';
                applyRarityClass(name, item.rarity);

                const equippedSlot = slotInfo.equippedSlot;
                const slotTypeValueRaw = slotInfo.slotTypeValueRaw;
                const rawSlot = slotInfo.rawSlot;
                const slotLabel = slotInfo.slotLabel;
                const canModifyEquipment = slotInfo.canModifyEquipment;

                const slotBadge = document.createElement('div');
                slotBadge.className = 'inventory-slot-tag';
                if (slotLabel) {
                    slotBadge.textContent = slotLabel;
                }

                let equipToggle = null;
                if (canModifyEquipment) {
                    equipToggle = document.createElement('button');
                    equipToggle.type = 'button';
                    equipToggle.className = 'inventory-equip-toggle';
                    equipToggle.textContent = equipped ? 'Unequip' : 'Equip';

                    equipToggle.addEventListener('click', (event) => {
                        event.stopPropagation();
                        event.preventDefault();
                        if (!currentNpcInventoryNpcId) {
                            return;
                        }
                        equipToggle.disabled = true;
                        setNpcItemEquipped(currentNpcInventoryNpcId, item, !equipped, {
                            slotName: equippedSlot || null,
                            slotType: slotTypeValueRaw || null
                        })
                            .finally(() => {
                                equipToggle.disabled = false;
                            });
                    });
                }

                card.appendChild(icon);
                card.appendChild(name);
                if (slotLabel) {
                    card.appendChild(slotBadge);
                }
                if (equipToggle) {
                    card.appendChild(equipToggle);
                }

                registerThingContextMenu(card, item, { context: 'npc-inventory', npcId: currentNpcInventoryNpcId });

                bindThingTooltip(card, item);

                npcInventoryGrid.appendChild(card);
            });

            try {
                document.dispatchEvent(new Event('inventory:updated'));
            } catch (_) {}
        }

        async function showNpcDispositionModal(npc) {
            if (!npc || !npcDispositionModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            currentNpcDispositionId = npc.id || null;
            currentNpcDispositionData = null;
            updateNpcDispositionSummary(null);
            setNpcDispositionStatus('', null);
            if (npcDispositionLoading) {
                npcDispositionLoading.removeAttribute('hidden');
            }
            if (npcDispositionList) {
                npcDispositionList.innerHTML = '';
                npcDispositionList.setAttribute('aria-busy', 'true');
            }
            if (npcDispositionEmpty) {
                npcDispositionEmpty.setAttribute('hidden', '');
            }
            if (npcDispositionSaveBtn) {
                npcDispositionSaveBtn.disabled = true;
            }

            npcModalBackdrop.removeAttribute('hidden');
            npcDispositionModal.removeAttribute('hidden');
            npcDispositionModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcDispositionModalTitle) {
                const titleName = npc.name || 'NPC';
                npcDispositionModalTitle.textContent = `${formatPossessiveName(titleName, 'NPC')} Dispositions`;
            }
            scrollModalToTop(npcDispositionModal);

            try {
                const response = await fetch(`/api/npcs/${encodeURIComponent(npc.id)}/dispositions`, {
                    cache: 'no-store'
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const payload = {
                    npc: data.npc || { id: npc.id, name: npc.name || 'NPC' },
                    player: data.player || null,
                    range: {
                        min: Number.isFinite(data.range?.min) ? data.range.min : null,
                        max: Number.isFinite(data.range?.max) ? data.range.max : null,
                        typicalStep: Number.isFinite(data.range?.typicalStep) ? data.range.typicalStep : null,
                        typicalBigStep: Number.isFinite(data.range?.typicalBigStep) ? data.range.typicalBigStep : null
                    },
                    dispositions: Array.isArray(data.dispositions)
                        ? data.dispositions.map(entry => ({
                            ...entry,
                            value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                            originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                        }))
                        : []
                };

                currentNpcDispositionData = payload;
                if (npcDispositionModalTitle) {
                    const resolvedName = payload.npc?.name || npc.name || 'NPC';
                    npcDispositionModalTitle.textContent = `${formatPossessiveName(resolvedName, 'NPC')} Dispositions`;
                }
                updateNpcDispositionSummary(payload);
                renderNpcDispositionEntries(payload);
                setNpcDispositionStatus('', null);
                updateCachedNpcDispositions(npc.id, payload);
            } catch (error) {
                console.warn('Failed to load NPC dispositions:', error);
                currentNpcDispositionData = null;
                updateNpcDispositionSummary({
                    npc: { name: npc.name || 'NPC' },
                    player: null,
                    range: {}
                });
                if (npcDispositionModalTitle) {
                    const resolvedName = npc.name || 'NPC';
                    npcDispositionModalTitle.textContent = `${formatPossessiveName(resolvedName, 'NPC')} Dispositions`;
                }
                if (npcDispositionList) {
                    npcDispositionList.innerHTML = '';
                }
                if (npcDispositionEmpty) {
                    npcDispositionEmpty.removeAttribute('hidden');
                }
                setNpcDispositionStatus(`Failed to load dispositions: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (npcDispositionList) {
                    npcDispositionList.removeAttribute('aria-busy');
                }
                if (npcDispositionLoading) {
                    npcDispositionLoading.setAttribute('hidden', '');
                }
                setNpcDispositionDirty();
            }
        }

        async function submitNpcDispositions(event) {
            if (event) {
                event.preventDefault();
            }

            if (!currentNpcDispositionData || !currentNpcDispositionId) {
                setNpcDispositionStatus('No disposition changes to save.', null);
                setNpcDispositionDirty();
                return;
            }

            const updates = currentNpcDispositionData.dispositions
                .filter(entry => entry.value !== entry.originalValue)
                .map(entry => ({ key: entry.key, value: entry.value }));

            if (!updates.length) {
                setNpcDispositionStatus('No changes to save.', null);
                setNpcDispositionDirty();
                return;
            }

            setNpcDispositionStatus('Saving disposition changes‚Ä¶', null);
            if (npcDispositionSaveBtn) {
                npcDispositionSaveBtn.disabled = true;
            }

            try {
                const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcDispositionId)}/dispositions`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ dispositions: updates })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const payload = {
                    npc: data.npc || currentNpcDispositionData.npc,
                    player: data.player || currentNpcDispositionData.player,
                    range: {
                        min: Number.isFinite(data.range?.min) ? data.range.min : currentNpcDispositionData.range?.min ?? null,
                        max: Number.isFinite(data.range?.max) ? data.range.max : currentNpcDispositionData.range?.max ?? null,
                        typicalStep: Number.isFinite(data.range?.typicalStep) ? data.range.typicalStep : currentNpcDispositionData.range?.typicalStep ?? null,
                        typicalBigStep: Number.isFinite(data.range?.typicalBigStep) ? data.range.typicalBigStep : currentNpcDispositionData.range?.typicalBigStep ?? null
                    },
                    dispositions: Array.isArray(data.dispositions)
                        ? data.dispositions.map(entry => ({
                            ...entry,
                            value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                            originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                        }))
                        : []
                };

                currentNpcDispositionData = payload;
                updateNpcDispositionSummary(payload);
                renderNpcDispositionEntries(payload);
                setNpcDispositionStatus(data.message || 'Dispositions updated successfully.', 'success');

                const updatedNpc = updateCachedNpcDispositions(currentNpcDispositionId, payload);
                if (updatedNpc && currentNpcViewId === currentNpcDispositionId) {
                    showNpcViewModal(updatedNpc);
                }

                closeNpcDispositionModal();
                document.body.classList.remove('modal-open');
            } catch (error) {
                console.warn('Failed to update NPC dispositions:', error);
                setNpcDispositionStatus(`Failed to update dispositions: ${error?.message || 'Unknown error'}`, 'error');
                if (npcDispositionSaveBtn) {
                    npcDispositionSaveBtn.disabled = false;
                }
            } finally {
                setNpcDispositionDirty();
            }
        }

        async function showNpcNeedsModal(target, options = {}) {
            if (!target || !npcNeedsModal || !npcModalBackdrop) {
                return;
            }

            const type = options.type || (target.isNPC ? 'npc' : 'player');
            const fallbackPlayerId = window.currentPlayerData && typeof window.currentPlayerData.id === 'string'
                ? window.currentPlayerData.id
                : null;
            const targetId = typeof target.id === 'string' && target.id
                ? target.id
                : (type === 'player' ? fallbackPlayerId : null);

            if (type === 'npc' && !targetId) {
                console.warn('Unable to open needs editor: NPC id missing');
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            currentNpcNeedsTargetId = targetId || null;
            currentNpcNeedsTargetType = type;
            currentNpcNeedsData = null;
            updateNpcNeedsSummary(null);
            setNpcNeedsStatus('', null);
            if (npcNeedsLoading) {
                npcNeedsLoading.removeAttribute('hidden');
            }
            if (npcNeedsList) {
                npcNeedsList.innerHTML = '';
                npcNeedsList.setAttribute('aria-busy', 'true');
            }
            if (npcNeedsEmpty) {
                npcNeedsEmpty.setAttribute('hidden', '');
            }
            if (npcNeedsSaveBtn) {
                npcNeedsSaveBtn.disabled = true;
            }

            npcModalBackdrop.removeAttribute('hidden');
            npcNeedsModal.removeAttribute('hidden');
            npcNeedsModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcNeedsModalTitle) {
                const fallbackLabel = type === 'player' ? 'Player' : 'Character';
                const displayName = target?.name || (type === 'player' && window.currentPlayerData?.name ? window.currentPlayerData.name : '') || fallbackLabel;
                npcNeedsModalTitle.textContent = `${formatPossessiveName(displayName, fallbackLabel)} Needs`;
            }
            scrollModalToTop(npcNeedsModal);

            const endpoint = type === 'player'
                ? '/api/player/needs'
                : `/api/npcs/${encodeURIComponent(targetId)}/needs`;

            try {
                const response = await fetch(endpoint, { cache: 'no-store' });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const normalizedNeeds = Array.isArray(data.needs)
                    ? data.needs.map(entry => ({
                        ...entry,
                        value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                        originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                    }))
                    : [];

                const payload = {
                    type,
                    targetId,
                    player: data.player || (type === 'player' ? { id: targetId, name: target.name || 'Player', isNPC: false } : null),
                    npc: data.npc || (type === 'npc' ? { id: targetId, name: target.name || 'NPC', isNPC: true } : null),
                    includePlayerOnly: data.includePlayerOnly !== undefined ? Boolean(data.includePlayerOnly) : type !== 'npc',
                    needs: normalizedNeeds
                };

                currentNpcNeedsData = payload;
                currentNpcNeedsTargetId = payload.npc?.id || payload.player?.id || targetId || null;
                if (npcNeedsModalTitle) {
                    const resolvedName = payload.npc?.name || payload.player?.name || target.name || (type === 'player' ? 'Player' : 'Character');
                    const fallbackLabel = type === 'player' ? 'Player' : 'Character';
                    npcNeedsModalTitle.textContent = `${formatPossessiveName(resolvedName, fallbackLabel)} Needs`;
                }
                updateNpcNeedsSummary(payload);
                renderNpcNeedsEntries(payload);
                setNpcNeedsStatus('', null);

                if (type === 'npc') {
                    updateCachedNpcNeeds(targetId, normalizedNeeds);
                } else {
                    if (window.currentPlayerData && (!targetId || window.currentPlayerData.id === targetId)) {
                        window.currentPlayerData = {
                            ...window.currentPlayerData,
                            needBars: normalizedNeeds.map(bar => ({ ...bar }))
                        };
                        updateChatPlayerPanel(window.currentPlayerData);
                        renderNeedBars(chatSidebarElements.needBars, window.currentPlayerData.needBars, {
                            includePlayerOnly: true,
                            variant: 'player'
                        });
                    }
                    if (window.currentNpcData instanceof Map && payload.player?.id) {
                        updateCachedNpcNeeds(payload.player.id, normalizedNeeds);
                    }
                }
            } catch (error) {
                console.warn('Failed to load needs:', error);
                currentNpcNeedsData = null;
                updateNpcNeedsSummary({
                    player: type === 'player' ? { name: target.name || 'Player' } : null,
                    npc: type === 'npc' ? { name: target.name || 'NPC' } : null
                });
                if (npcNeedsModalTitle) {
                    const fallbackLabel = type === 'player' ? 'Player' : 'Character';
                    const resolvedName = target.name || fallbackLabel;
                    npcNeedsModalTitle.textContent = `${formatPossessiveName(resolvedName, fallbackLabel)} Needs`;
                }
                if (npcNeedsList) {
                    npcNeedsList.innerHTML = '';
                }
                if (npcNeedsEmpty) {
                    npcNeedsEmpty.removeAttribute('hidden');
                }
                setNpcNeedsStatus(`Failed to load needs: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (npcNeedsList) {
                    npcNeedsList.removeAttribute('aria-busy');
                }
                if (npcNeedsLoading) {
                    npcNeedsLoading.setAttribute('hidden', '');
                }
                setNpcNeedsDirty();
            }
        }

        async function submitNpcNeeds(event) {
            if (event) {
                event.preventDefault();
            }

            if (!currentNpcNeedsData || !currentNpcNeedsTargetId) {
                setNpcNeedsStatus('No need changes to save.', null);
                setNpcNeedsDirty();
                return;
            }

            const updates = currentNpcNeedsData.needs
                .filter(entry => entry.value !== entry.originalValue)
                .map(entry => ({ id: entry.id, value: entry.value }));

            if (!updates.length) {
                setNpcNeedsStatus('No changes to save.', null);
                setNpcNeedsDirty();
                return;
            }

            setNpcNeedsStatus('Saving need changes‚Ä¶', null);
            if (npcNeedsSaveBtn) {
                npcNeedsSaveBtn.disabled = true;
            }

            const endpoint = currentNpcNeedsTargetType === 'player'
                ? '/api/player/needs'
                : `/api/npcs/${encodeURIComponent(currentNpcNeedsTargetId)}/needs`;

            try {
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ needs: updates })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const normalizedNeeds = Array.isArray(data.needs)
                    ? data.needs.map(entry => ({
                        ...entry,
                        value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                        originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                    }))
                    : [];

            const payload = {
                type: currentNpcNeedsTargetType,
                targetId: currentNpcNeedsTargetId,
                player: data.player || currentNpcNeedsData.player || null,
                npc: data.npc || currentNpcNeedsData.npc || null,
                    includePlayerOnly: data.includePlayerOnly !== undefined
                        ? Boolean(data.includePlayerOnly)
                        : currentNpcNeedsData.includePlayerOnly,
                    needs: normalizedNeeds
                };

                currentNpcNeedsData = payload;
                currentNpcNeedsTargetId = payload.npc?.id || payload.player?.id || currentNpcNeedsTargetId;
                updateNpcNeedsSummary(payload);
                renderNpcNeedsEntries(payload);
                setNpcNeedsStatus(data.message || 'Need bars updated successfully.', 'success');

                if (payload.type === 'npc') {
                    const npcId = payload.npc?.id || currentNpcNeedsTargetId;
                    const updatedNpc = updateCachedNpcNeeds(npcId, normalizedNeeds);
                    if (updatedNpc) {
                        if (currentNpcViewId === npcId) {
                            showNpcViewModal(updatedNpc);
                        }
                        window.refreshParty?.();
                        window.loadCurrentLocation?.();
                    }
                    closeNpcNeedsModal();
                    document.body.classList.remove('modal-open');
                } else {
                    const playerId = payload.player?.id || currentNpcNeedsTargetId;
                    if (window.currentPlayerData && window.currentPlayerData.id === playerId) {
                        window.currentPlayerData = {
                            ...window.currentPlayerData,
                            needBars: normalizedNeeds.map(bar => ({ ...bar }))
                        };
                        updateChatPlayerPanel(window.currentPlayerData);
                        renderNeedBars(chatSidebarElements.needBars, window.currentPlayerData.needBars, {
                            includePlayerOnly: true,
                            variant: 'player'
                        });
                    }
                    if (window.currentNpcData instanceof Map && playerId) {
                        updateCachedNpcNeeds(playerId, normalizedNeeds);
                    }
                    closeNpcNeedsModal();
                    document.body.classList.remove('modal-open');
                }
            } catch (error) {
                console.warn('Failed to update needs:', error);
                setNpcNeedsStatus(`Failed to update needs: ${error?.message || 'Unknown error'}`, 'error');
                if (npcNeedsSaveBtn) {
                    npcNeedsSaveBtn.disabled = false;
                }
            } finally {
                setNpcNeedsDirty();
            }
        }

        function showNpcInventoryModal(npc) {
            if (!npc || !npcInventoryModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            npcInventoryModal.setAttribute('aria-hidden', 'false');
            npcInventoryModal.removeAttribute('hidden');
            npcModalBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');
            if (npcInventoryModalTitle) {
                const titleName = npc.name || 'Character';
                npcInventoryModalTitle.textContent = `${formatPossessiveName(titleName, 'Character')} Inventory`;
            }
            scrollModalToTop(npcInventoryModal);

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());
            const npcId = npc.id || null;
            npcInventoryName.textContent = npc.name || 'Character';
            const items = Array.isArray(npc.inventory) ? npc.inventory : [];
            currentNpcInventory = items;
            currentNpcInventoryNpcId = npcId;
            if (npcInventoryFilterInput) {
                npcInventoryFilterInput.value = '';
            }
            if (npcInventorySlotFilter) {
                npcInventorySlotFilter.value = '';
            }
            if (npcInventoryShowAllRadio) {
                npcInventoryShowAllRadio.checked = true;
            }
            if (npcInventoryEquippedOnlyRadio) {
                npcInventoryEquippedOnlyRadio.checked = false;
            }
            if (npcInventoryEquippableOnlyRadio) {
                npcInventoryEquippableOnlyRadio.checked = false;
            }
            if (npcInventoryNonEquippableOnlyRadio) {
                npcInventoryNonEquippableOnlyRadio.checked = false;
            }
            renderNpcInventory(items);

            if (npcId) {
                (async () => {
                    try {
                        const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });
                        const data = await response.json().catch(() => ({}));
                        if (!response.ok || !data?.success || !data.npc) {
                            return;
                        }

                        npcDataCache.set(npcId, cloneActorRecord(data.npc) || { ...data.npc });
                        const freshItems = Array.isArray(data.npc.inventory) ? data.npc.inventory : [];
                        currentNpcInventory = freshItems;
                        currentNpcInventoryNpcId = npcId;
                        npcInventoryName.textContent = data.npc.name || npcInventoryName.textContent;
                        if (npcInventoryModalTitle) {
                            const titleName = data.npc.name || 'Character';
                            npcInventoryModalTitle.textContent = `${formatPossessiveName(titleName, 'Character')} Inventory`;
                        }
                        renderNpcInventory(freshItems);
                    } catch (error) {
                        console.warn('Failed to refresh NPC inventory before opening modal:', error);
                    }
                })();
            }
        }

        function formatTagValue(label, value) {
            if (value === undefined || value === null || value === '') {
                return '';
            }
            return `${label}: ${value}`;
        }

        function renderDefinitionList(container, emptyState, entries = []) {
            if (!container) {
                return;
            }
            container.innerHTML = '';
            if (!Array.isArray(entries) || entries.length === 0) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }
            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }
            entries.forEach(({ term, detail }) => {
                const dt = document.createElement('dt');
                dt.textContent = term;
                const dd = document.createElement('dd');
                dd.textContent = detail;
                container.appendChild(dt);
                container.appendChild(dd);
            });
        }

        function renderEquipmentList(container, emptyState, entries = []) {
            if (!container) {
                return;
            }

            container.innerHTML = '';
            const safeEntries = Array.isArray(entries) ? entries.filter(Boolean) : [];

            if (!safeEntries.length) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }

            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }

            safeEntries.forEach(entry => {
                const row = document.createElement('div');
                row.className = 'npc-view-equipment-row';

                const slotContainer = document.createElement('div');
                slotContainer.className = 'npc-view-equipment-slot';
                const slotName = document.createElement('div');
                slotName.className = 'npc-view-equipment-slot-name';
                slotName.textContent = entry.slotLabel || 'Slot';
                slotContainer.appendChild(slotName);

                if (entry.slotTypeLabel && entry.slotTypeLabel !== entry.slotLabel) {
                    const slotType = document.createElement('div');
                    slotType.className = 'npc-view-equipment-slot-type';
                    slotType.textContent = entry.slotTypeLabel;
                    slotContainer.appendChild(slotType);
                }

                const itemContainer = document.createElement('div');
                itemContainer.className = 'npc-view-equipment-item';

                if (entry.item && typeof entry.item === 'object') {
                    const card = document.createElement('div');
                    card.className = 'npc-view-equipment-item-card';

                    const icon = document.createElement('div');
                    icon.className = 'npc-view-equipment-icon';
                    const placeholderIcon = entry.item.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ';
                    renderEntityImage({
                        element: icon,
                        entityType: 'thing',
                        entityId: entry.item.id || null,
                        imageId: entry.item.imageId || null,
                        altText: entry.item.name || 'Equipped item',
                        placeholderIcon,
                        placeholderClass: 'npc-view-equipment-icon-placeholder'
                    });

                    const textWrapper = document.createElement('div');
                    textWrapper.className = 'npc-view-equipment-text';
                    const name = document.createElement('div');
                    name.className = 'npc-view-equipment-name';
                    name.textContent = entry.item.name || 'Unknown Item';
                    applyRarityClass(name, entry.item.rarity);
                    textWrapper.appendChild(name);

                    card.appendChild(icon);
                    card.appendChild(textWrapper);

                    if (entry.item && entry.item.id) {
                        registerThingContextMenu(card, entry.item, { context: 'npc-equipment', npcId: currentNpcViewId });
                    }

                    bindThingTooltip(card, entry.item);
                    itemContainer.appendChild(card);
                } else {
                    const empty = document.createElement('span');
                    empty.className = 'npc-view-equipment-empty';
                    empty.textContent = 'Empty';
                    itemContainer.appendChild(empty);
                }

                row.appendChild(slotContainer);
                row.appendChild(itemContainer);
                container.appendChild(row);
            });
        }

        function renderList(container, emptyState, items = [], options = {}) {
            if (!container) {
                return;
            }
            container.innerHTML = '';
            const safeItems = Array.isArray(items) ? items.filter(Boolean) : [];
            if (safeItems.length === 0) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }
            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }

            const { allowHTML = false } = options;
            safeItems.forEach(item => {
                const li = document.createElement('li');
                if (allowHTML) {
                    li.innerHTML = item;
                } else {
                    li.textContent = item;
                }
                container.appendChild(li);
            });
        }

        function showNpcViewModal(npc) {
            if (!npc || !npcViewModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            const latestNpc = npc && npc.id ? (npcDataCache.get(npc.id) || npc) : npc;
            currentNpcViewId = latestNpc?.id || npc?.id || null;

            npcModalBackdrop.removeAttribute('hidden');
            npcViewModal.removeAttribute('hidden');
            npcViewModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(npcViewModal);

            const name = latestNpc?.name || 'Unknown Character';
            const description = latestNpc?.description || latestNpc?.shortDescription || 'No description available.';
            const resolveTagValue = (...values) => {
                for (const value of values) {
                    if (value === undefined || value === null) {
                        continue;
                    }
                    if (typeof value === 'string') {
                        const trimmed = value.trim();
                        if (trimmed) {
                            return trimmed;
                        }
                    } else if (value !== '') {
                        return value;
                    }
                }
                return null;
            };
            const classLabel = resolveTagValue(latestNpc?.class, latestNpc?.className, latestNpc?.classLabel) || 'Unknown';
            const raceLabel = resolveTagValue(latestNpc?.race, latestNpc?.species, latestNpc?.raceName) || 'Unknown';
            const levelValue = Number.isFinite(Number(latestNpc?.level)) ? Number(latestNpc.level) : null;
            const healthValue = Number.isFinite(Number(latestNpc?.health)) ? Number(latestNpc.health) : null;
            const maxHealthValue = Number.isFinite(Number(latestNpc?.maxHealth)) ? Number(latestNpc.maxHealth) : null;
            const parseNonNegativeInt = (value) => {
                const parsed = Number.parseInt(value, 10);
                return Number.isFinite(parsed) && parsed >= 0 ? parsed : null;
            };

            if (npcViewModalTitle) {
                npcViewModalTitle.textContent = latestNpc?.name ? `${latestNpc.name} ¬∑ Overview` : 'Character Overview';
            }

            if (npcViewName) {
                npcViewName.textContent = name;
            }
            if (npcViewDescription) {
                npcViewDescription.textContent = description;
            }

            const updateTag = (element, label, value) => {
                if (!element) {
                    return;
                }
                if (value === undefined || value === null || value === '') {
                    element.textContent = '';
                    element.setAttribute('hidden', '');
                    return;
                }
                element.textContent = formatTagValue(label, value);
                element.removeAttribute('hidden');
            };

            updateTag(npcViewClass, 'Class', classLabel);
            updateTag(npcViewRace, 'Race', raceLabel);
            updateTag(npcViewLevel, 'Level', levelValue);

            if (npcViewHealth) {
                if (healthValue === null && maxHealthValue === null) {
                    npcViewHealth.textContent = '';
                    npcViewHealth.setAttribute('hidden', '');
                } else {
                    if (healthValue !== null && maxHealthValue !== null) {
                        npcViewHealth.textContent = `${healthValue}/${maxHealthValue}`;
                    } else if (healthValue !== null) {
                        npcViewHealth.textContent = `${healthValue}`;
                    } else {
                        npcViewHealth.textContent = `${maxHealthValue}`;
                    }
                    npcViewHealth.removeAttribute('hidden');
                }
            }

            if (npcViewCurrency) {
                const currencyValue = parseNonNegativeInt(latestNpc?.currency);
                if (currencyValue === null) {
                    npcViewCurrency.textContent = '';
                    npcViewCurrency.setAttribute('hidden', '');
                } else {
                    const currencyLabel = resolveCurrencyLabel();
                    npcViewCurrency.textContent = `Currency: ${currencyValue} ${currencyLabel}`;
                    npcViewCurrency.removeAttribute('hidden');
                }
            }

            if (npcViewExperience) {
                const experienceValue = parseNonNegativeInt(latestNpc?.experience);
                if (experienceValue === null) {
                    npcViewExperience.textContent = '';
                    npcViewExperience.setAttribute('hidden', '');
                } else {
                    npcViewExperience.textContent = `Experience: ${experienceValue}`;
                    npcViewExperience.removeAttribute('hidden');
                }
            }

            const dispositions = Array.isArray(latestNpc?.dispositionsTowardsPlayer)
                ? latestNpc.dispositionsTowardsPlayer.filter(entry => entry && entry.type)
                : [];
            if (npcViewDispositions && npcViewDispositionsList) {
                if (!dispositions.length) {
                    npcViewDispositions.setAttribute('hidden', '');
                    npcViewDispositions.removeAttribute('open');
                    npcViewDispositionsList.innerHTML = '';
                } else {
                    npcViewDispositions.removeAttribute('hidden');
                    npcViewDispositions.open = false;
                    npcViewDispositionsList.innerHTML = '';
                    dispositions.forEach(entry => {
                        const chip = document.createElement('span');
                        chip.className = 'npc-view-disposition-chip';
                        const numericValue = Number(entry.value);
                        const formattedValue = Number.isFinite(numericValue)
                            ? ` (${numericValue > 0 ? '+' : ''}${numericValue})`
                            : '';
                        chip.textContent = `${entry.type}: ${entry.intensityName || 'neutral'}${formattedValue}`;
                        npcViewDispositionsList.appendChild(chip);
                    });
                }
            }

            if (npcViewImage) {
                renderEntityImage({
                    element: npcViewImage,
                    entityType: latestNpc?.isNPC ? 'npc' : 'player',
                    entityId: latestNpc?.id || null,
                    imageId: latestNpc?.imageId || null,
                    altText: `${name} portrait`,
                    placeholderIcon: 'üé≠',
                    placeholderClass: 'npc-view-image-placeholder'
                });
            }

            const attributeEntries = [];
            if (latestNpc?.attributeInfo && typeof latestNpc.attributeInfo === 'object') {
                for (const [key, info] of Object.entries(latestNpc.attributeInfo)) {
                    const label = info?.label || formatAttributeName(key);
                    const rawValue = info?.modifiedValue !== undefined ? info.modifiedValue : info?.value;
                    const value = Number.isFinite(Number(rawValue)) ? Number(rawValue) : rawValue;
                    const rawModifier = info?.modifiedModifier !== undefined ? info.modifiedModifier : info?.modifier;
                    const modifier = Number.isFinite(Number(rawModifier)) ? Number(rawModifier) : null;
                    const parts = [];
                    if (value !== undefined && value !== null) {
                        parts.push(value);
                    }
                    if (modifier !== null) {
                        parts.push(`${modifier >= 0 ? '+' : ''}${modifier}`);
                    }
                    attributeEntries.push({ term: label, detail: parts.join(' ') || '‚Äî' });
                }
            } else if (latestNpc?.attributes && typeof latestNpc.attributes === 'object') {
                for (const [key, value] of Object.entries(latestNpc.attributes)) {
                    const label = formatAttributeName(key);
                    const detail = Number.isFinite(Number(value)) ? Number(value) : (value ?? '‚Äî');
                    attributeEntries.push({ term: label, detail });
                }
            }
            attributeEntries.sort((a, b) => a.term.localeCompare(b.term));
            renderDefinitionList(npcViewAttributes, npcViewAttributesEmpty, attributeEntries);

            const inventoryItems = Array.isArray(latestNpc?.inventory) ? latestNpc.inventory : [];
            const inventoryMap = new Map();
            inventoryItems.forEach(item => {
                if (item && item.id) {
                    inventoryMap.set(item.id, item);
                }
            });

            const equipmentEntries = [];
            if (latestNpc?.gear && typeof latestNpc.gear === 'object') {
                for (const [slotName, slotData] of Object.entries(latestNpc.gear)) {
                    if (!slotName && !slotData?.slotType) {
                        continue;
                    }

                    const slotTypeLabel = slotData?.slotType ? formatSlotTypeLabel(slotData.slotType) : '';
                    const resolvedSlotName = typeof slotName === 'string' && slotName.trim()
                        ? slotName.trim()
                        : '';
                    const slotLabel = resolvedSlotName || (slotTypeLabel ? `${slotTypeLabel} Slot` : 'Slot');

                    let resolvedItem = null;
                    if (slotData && slotData.itemId) {
                        resolvedItem = inventoryMap.get(slotData.itemId) || null;
                    }
                    if (!resolvedItem && slotData && typeof slotData.item === 'object') {
                        resolvedItem = slotData.item;
                    }
                    if (!resolvedItem && slotData && (slotData.itemName || slotData.itemId)) {
                        resolvedItem = {
                            id: slotData.itemId || null,
                            name: slotData.itemName || slotData.itemId || 'Unknown Item',
                            rarity: slotData.itemRarity || null,
                            thingType: slotData.itemType || null
                        };
                    }

                    equipmentEntries.push({
                        slotLabel,
                        slotTypeLabel,
                        item: resolvedItem
                    });
                }
            }
            equipmentEntries.sort((a, b) => a.slotLabel.localeCompare(b.slotLabel));
            renderEquipmentList(npcViewEquipment, npcViewEquipmentEmpty, equipmentEntries);

            const skillData = [];
            if (latestNpc?.skills) {
                if (Array.isArray(latestNpc.skills)) {
                    latestNpc.skills.forEach(entry => {
                        if (!entry) return;
                        if (typeof entry === 'string') {
                            skillData.push({ name: entry, rank: null });
                        } else if (entry.name) {
                            const rankValue = Number.isFinite(Number(entry.rank)) ? Number(entry.rank) : null;
                            skillData.push({ name: entry.name, rank: rankValue });
                        }
                    });
                } else if (latestNpc.skills && typeof latestNpc.skills === 'object') {
                    for (const [skillName, rank] of Object.entries(latestNpc.skills)) {
                        const rankValue = Number.isFinite(Number(rank)) ? Number(rank) : null;
                        skillData.push({ name: skillName, rank: rankValue });
                    }
                }
            }
            skillData.sort((a, b) => a.name.localeCompare(b.name));
            if (npcViewSkills) {
                npcViewSkills.innerHTML = '';
                if (!skillData.length) {
                    npcViewSkills.setAttribute('hidden', '');
                    if (npcViewSkillsEmpty) {
                        npcViewSkillsEmpty.removeAttribute('hidden');
                    }
                } else {
                    if (npcViewSkillsEmpty) {
                        npcViewSkillsEmpty.setAttribute('hidden', '');
                    }
                    const table = document.createElement('table');
                    table.className = 'npc-view-skills-table';
                    const tbody = document.createElement('tbody');
                    table.appendChild(tbody);

                    skillData.forEach((entry, index) => {
                        const row = document.createElement('tr');
                        if ((index % 2) === 1) {
                            row.classList.add('is-alt');
                        }

                        const nameCell = document.createElement('td');
                        nameCell.className = 'npc-view-skill-name';
                        nameCell.textContent = entry.name || 'Unknown Skill';

                        const rankCell = document.createElement('td');
                        rankCell.className = 'npc-view-skill-rank';
                        if (entry.rank !== null && entry.rank !== undefined) {
                            const numericRank = Number(entry.rank);
                            rankCell.textContent = Number.isFinite(numericRank)
                                ? `${numericRank > 0 ? '+' : ''}${numericRank}`
                                : `${entry.rank}`;
                        } else {
                            rankCell.textContent = '‚Äî';
                        }

                        row.appendChild(nameCell);
                        row.appendChild(rankCell);
                        tbody.appendChild(row);
                    });

                    npcViewSkills.appendChild(table);
                    npcViewSkills.removeAttribute('hidden');
                }
            }

            const abilityEntries = [];
            if (Array.isArray(latestNpc?.abilities)) {
                latestNpc.abilities.forEach(ability => {
                    if (!ability) return;
                    const label = ability.name || 'Ability';
                    const typeSuffix = ability.type ? ` (${ability.type})` : '';
                    const descriptionText = ability.description || ability.text || '';
                    const entry = `<strong>${escapeHtml(label)}${escapeHtml(typeSuffix)}</strong>${descriptionText ? `<span class="npc-view-list-description">${escapeHtml(descriptionText)}</span>` : ''}`;
                    abilityEntries.push(entry);
                });
            }
            renderList(npcViewAbilities, npcViewAbilitiesEmpty, abilityEntries, { allowHTML: true });

            const statusEntries = [];
            if (Array.isArray(latestNpc?.statusEffects)) {
                latestNpc.statusEffects.forEach(effect => {
                    if (!effect) return;
                    if (typeof effect === 'string') {
                        statusEntries.push(effect);
                        return;
                    }
                    const descriptionText = effect.description || effect.text || effect.name || '';
                    if (!descriptionText) {
                        return;
                    }
                    const durationText = Number.isFinite(Number(effect.duration))
                        ? ` (Duration ${Number(effect.duration)})`
                        : '';
                    statusEntries.push(`${descriptionText}${durationText}`);
                });
            }
            renderList(npcViewStatuses, npcViewStatusesEmpty, statusEntries);
        }

            document.addEventListener('keydown', (event) => {
                if (event.key !== 'Escape') {
                    return;
                }

                if (addNpcModal && !addNpcModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeAddNpcModal({ focusTrigger: true });
                    return;
                }

                if (newExitModal && !newExitModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNewExitModal();
                    return;
                }

                if (npcNeedsModal && !npcNeedsModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcNeedsModal();
                    return;
                }

                if (npcMemoriesModal && !npcMemoriesModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcMemoriesModal();
                    return;
                }

                if (npcGoalsModal && !npcGoalsModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcGoalsModal();
                    return;
                }

                if (npcDispositionModal && !npcDispositionModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcDispositionModal();
                    return;
                }

                if (thingEditModal && !thingEditModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeThingEditModal();
                    return;
                }

                if (npcViewModal && !npcViewModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcViewModal();
                    return;
                }

                if (npcInventoryModal && !npcInventoryModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcInventoryModal();
                    return;
                }

                if (npcEditModal && !npcEditModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcEditModal();
                    return;
                }

                if (summonNpcModal && !summonNpcModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeSummonNpcModal();
                    return;
                }

                if (summonThingModal && !summonThingModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeSummonThingModal();
                    return;
                }
        });

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');

            const hashPrefix = 'tab-';

            const activateTab = (tabName) => {
                if (!tabName) return;
                const targetButton = Array.from(tabButtons).find(btn => btn.dataset.tab === tabName);
                const targetPanel = document.getElementById(`tab-${tabName}`);
                if (!targetButton || !targetPanel) return;

                tabButtons.forEach(btn => {
                    const isActive = btn === targetButton;
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                });

                tabPanels.forEach(panel => {
                    const isActive = panel === targetPanel;
                    panel.toggleAttribute('hidden', !isActive);
                    panel.classList.toggle('active', isActive);
                });

                if (tabName === 'map') {
                    window.loadRegionMap?.();
                }
                if (tabName === 'party') {
                    window.refreshParty?.();
                }
            };

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.classList.contains('active')) {
                        return;
                    }
                    activateTab(button.dataset.tab);
                    const newHash = `#${hashPrefix}${button.dataset.tab}`;
                    if (window.location.hash !== newHash) {
                        window.location.hash = newHash;
                    }
                });
            });

            const applyHashTab = () => {
                const rawHash = window.location.hash ? window.location.hash.replace('#', '') : '';
                if (!rawHash) {
                    return;
                }

                if (rawHash.startsWith(hashPrefix)) {
                    const tabName = rawHash.substring(hashPrefix.length);
                    activateTab(tabName);
                } else {
                    activateTab(rawHash);
                }
            };

            applyHashTab();
            window.addEventListener('hashchange', applyHashTab);

            if (!window.location.hash) {
                const defaultButton = document.querySelector('.tab-button.active');
                const defaultTab = defaultButton ? defaultButton.dataset.tab : 'adventure';
                activateTab(defaultTab);
                window.location.hash = `#${hashPrefix}${defaultTab}`;
            }
        }

        function initLocationDisplay() {
            // Function to update location display
        const locationCache = {};

        function resolveDestinationNameStrict(exit) {
            if (!exit) {
                throw new Error('resolveDestinationNameStrict requires an exit object.');
            }

            const direct = typeof exit.destinationName === 'string' ? exit.destinationName.trim() : '';
            if (direct) {
                return direct;
            }

            const cached = exit.destination && typeof locationCache[exit.destination] === 'string'
                ? locationCache[exit.destination].trim()
                : '';
            if (cached) {
                return cached;
            }

            console.log('Attempting to resolve destination name for exit:', exit);
            throw new Error(`Exit ${exit.id || exit.destination || '<unknown>'} is missing a destination name.`);
        }
        const MOVE_PLAUSIBILITY_POLICY = (window.CHECK_MOVE_PLAUSIBILITY || 'never').toLowerCase();

        function isUnexploredRegionExit(exit) {
            return Boolean(exit?.destinationRegion && !exit.destinationRegionExpanded);
        }

        function isUnexploredLocationExit(exit) {
            if (!exit) {
                return false;
            }
            if (isUnexploredRegionExit(exit)) {
                return true;
            }
            return Boolean(exit.destinationIsRegionEntryStub || exit.destinationIsStub);
        }

        function shouldUseEventMove(exit) {
            switch (MOVE_PLAUSIBILITY_POLICY) {
                case 'always':
                    return true;
                case 'never':
                    return false;
                case 'unexplored_locations':
                    return isUnexploredLocationExit(exit);
                case 'unexplored_regions':
                    return isUnexploredRegionExit(exit);
                default:
                    return false;
            }
        }
            const locationOverlay = document.getElementById('locationOverlay');
            const locationOverlayText = document.getElementById('locationOverlayText');
            const locationNPCs = document.getElementById('locationNPCs');
            const locationScenery = document.getElementById('locationScenery');
            const locationItems = document.getElementById('locationItems');
            const npcDataCache = new Map();
            window.currentNpcData = npcDataCache;
            const npcMenuState = { openMenu: null, trigger: null, card: null };

            function closeNpcContextMenu() {
                if (npcMenuState.openMenu) {
                    npcMenuState.openMenu.classList.remove('is-open');
                }
                if (npcMenuState.trigger) {
                    npcMenuState.trigger.setAttribute('aria-expanded', 'false');
                }
                if (npcMenuState.card) {
                    npcMenuState.card.classList.remove('context-menu-open');
                }
                npcMenuState.openMenu = null;
                npcMenuState.trigger = null;
                npcMenuState.card = null;
                closeThingContextMenu();
            }

            function registerNpcContextMenu(card, npc) {
                if (!card || !npc || !npc.id) {
                    return;
                }

                const npcIdString = String(npc.id);
                if (card.dataset.npcMenuAttached === 'true' && card.dataset.npcId === npcIdString) {
                    return;
                }

                card.dataset.npcId = npcIdString;
                card.dataset.npcMenuAttached = 'true';

                const existingButton = card.querySelector('.npc-card-menu-button');
                const existingMenu = card.querySelector('.npc-card-menu');
                existingButton?.remove();
                existingMenu?.remove();

                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'npc-card-menu-button';
                button.setAttribute('aria-haspopup', 'true');
                button.setAttribute('aria-expanded', 'false');
                button.setAttribute('aria-label', `More actions for ${npc.name || 'NPC'}`);

                const icon = document.createElement('span');
                icon.setAttribute('aria-hidden', 'true');
                icon.textContent = '‚Ä¢‚Ä¢‚Ä¢';
                button.appendChild(icon);

                const menu = document.createElement('div');
                menu.className = 'npc-card-menu';

                const viewButton = document.createElement('button');
                viewButton.type = 'button';
                viewButton.className = 'npc-card-menu-item';
                viewButton.textContent = 'View';
                menu.appendChild(viewButton);

                let regenerateImageButton = null;
                const canRegeneratePortrait = npc && npc.imageId;
                if (canRegeneratePortrait) {
                    regenerateImageButton = document.createElement('button');
                    regenerateImageButton.type = 'button';
                    regenerateImageButton.className = 'npc-card-menu-item';
                    regenerateImageButton.textContent = 'Regenerate Image';
                    menu.appendChild(regenerateImageButton);
                }

                const editButton = document.createElement('button');
                editButton.type = 'button';
                editButton.className = 'npc-card-menu-item';
                editButton.textContent = 'Edit';
                menu.appendChild(editButton);

                const inventoryButton = document.createElement('button');
                inventoryButton.type = 'button';
                inventoryButton.className = 'npc-card-menu-item';
                inventoryButton.textContent = 'Inventory';
                menu.appendChild(inventoryButton);

                const needsButton = document.createElement('button');
                needsButton.type = 'button';
                needsButton.className = 'npc-card-menu-item';
                needsButton.textContent = 'Needs';
                menu.appendChild(needsButton);

                let teleportButton = null;
                let memoriesButton = null;
                let goalsButton = null;
                let recruitButton = null;
                let dismissButton = null;
                let dispositionButton = null;
                let killButton = null;
                let deleteButton = null;
                if (npc && npc.isPlayer) {
                    teleportButton = document.createElement('button');
                    teleportButton.type = 'button';
                    teleportButton.className = 'npc-card-menu-item';
                    teleportButton.textContent = 'Teleport';
                    menu.appendChild(teleportButton);
                } else if (npc && npc.isNPC) {
                    teleportButton = document.createElement('button');
                    teleportButton.type = 'button';
                    teleportButton.className = 'npc-card-menu-item';
                    teleportButton.textContent = 'Teleport';
                    menu.appendChild(teleportButton);

                    memoriesButton = document.createElement('button');
                    memoriesButton.type = 'button';
                    memoriesButton.className = 'npc-card-menu-item';
                    memoriesButton.textContent = 'Memories';
                    menu.appendChild(memoriesButton);

                    goalsButton = document.createElement('button');
                    goalsButton.type = 'button';
                    goalsButton.className = 'npc-card-menu-item';
                    goalsButton.textContent = 'Goals';
                    menu.appendChild(goalsButton);

                    const isInParty = Boolean(npc.isInPlayerParty);
                    if (isInParty) {
                        dismissButton = document.createElement('button');
                        dismissButton.type = 'button';
                        dismissButton.className = 'npc-card-menu-item';
                        dismissButton.textContent = 'Dismiss';
                        menu.appendChild(dismissButton);
                    } else {
                        recruitButton = document.createElement('button');
                        recruitButton.type = 'button';
                        recruitButton.className = 'npc-card-menu-item';
                        recruitButton.textContent = 'Force Recruit';
                        menu.appendChild(recruitButton);
                    }

                    dispositionButton = document.createElement('button');
                    dispositionButton.type = 'button';
                    dispositionButton.className = 'npc-card-menu-item';
                    dispositionButton.textContent = 'Dispositions';
                    menu.appendChild(dispositionButton);

                    killButton = document.createElement('button');
                    killButton.type = 'button';
                    killButton.className = 'npc-card-menu-item npc-card-menu-item--danger';
                    killButton.textContent = 'Kill';
                    menu.appendChild(killButton);

                    deleteButton = document.createElement('button');
                    deleteButton.type = 'button';
                    deleteButton.className = 'npc-card-menu-item npc-card-menu-item--danger';
                    deleteButton.textContent = 'Delete';
                    menu.appendChild(deleteButton);
                }

                button.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const wasOpen = npcMenuState.openMenu === menu;
                    closeNpcContextMenu();
                    if (!wasOpen) {
                        menu.classList.add('is-open');
                        button.setAttribute('aria-expanded', 'true');
                        npcMenuState.openMenu = menu;
                        npcMenuState.trigger = button;
                        npcMenuState.card = card;
                        card.classList.add('context-menu-open');
                    }
                });

                viewButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcViewModal(latestNpc);
                });

                editButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcEditModal(latestNpc);
                });

                if (regenerateImageButton) {
                    regenerateImageButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = { ...(npcDataCache.get(npc.id) || npc) };
                        const npcId = String(latestNpc?.id || '');
                        if (!npcId) {
                            console.warn('Unable to regenerate portrait: NPC identifier missing.');
                            return;
                        }

                        const entityType = latestNpc.isNPC ? 'npc' : 'player';
                        const previousImageId = latestNpc.imageId || null;
                        const placeholderAlt = latestNpc.name || 'Character portrait';

                        applyEntityImagePlaceholder(entityType, npcId);

                        const baseNpcRecord = {
                            ...latestNpc,
                            imageId: null,
                            pendingImageJobId: null
                        };
                        npcDataCache.set(npc.id, baseNpcRecord);
                        if (!latestNpc.isNPC) {
                            window.currentPlayerData = {
                                ...(window.currentPlayerData || {}),
                                imageId: null
                            };
                        }

                        const clientId = window.AIRPG_CLIENT_ID || null;
                        const requestBody = clientId ? { clientId } : {};

                        try {
                            const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}/portrait`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(requestBody)
                            });
                            const data = await response.json().catch(() => ({}));

                            if (!response.ok) {
                                throw new Error(data?.error || `HTTP ${response.status}`);
                            }

                            if (data?.skipped) {
                                npcDataCache.set(npc.id, { ...latestNpc });
                                if (!latestNpc.isNPC) {
                                    window.currentPlayerData = {
                                        ...(window.currentPlayerData || {}),
                                        imageId: previousImageId || null
                                    };
                                }
                                renderEntityImages(entityType, npcId, {
                                    imageId: previousImageId,
                                    force: false,
                                    altText: placeholderAlt
                                });
                                return;
                            }

                            if (!data?.success && !data?.existingJob) {
                                throw new Error(data?.error || 'Portrait request was not accepted');
                            }

                            const pendingJobId = data?.imageGeneration?.jobId || data?.jobId || null;
                            npcDataCache.set(npc.id, {
                                ...baseNpcRecord,
                                pendingImageJobId: pendingJobId
                            });

                            renderEntityImages(entityType, npcId, {
                                imageId: null,
                                force: true,
                                altText: placeholderAlt
                            });
                        } catch (error) {
                            console.warn('Failed to regenerate NPC portrait:', error);
                            npcDataCache.set(npc.id, { ...latestNpc });
                            if (!latestNpc.isNPC) {
                                window.currentPlayerData = {
                                    ...(window.currentPlayerData || {}),
                                    imageId: previousImageId || null
                                };
                            }
                            renderEntityImages(entityType, npcId, {
                                imageId: previousImageId,
                                force: false,
                                altText: placeholderAlt
                            });
                        }
                    });
                }

                inventoryButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcInventoryModal(latestNpc);
                });

                needsButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    const type = npc.isNPC ? 'npc' : 'player';
                    try {
                        await showNpcNeedsModal(latestNpc, { type });
                    } catch (error) {
                        console.warn('Failed to open needs editor:', error);
                    }
                });

                if (teleportButton) {
                    teleportButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        try {
                            const latestNpc = npcDataCache.get(npc.id) || npc;
                            await showTeleportLocationModal(null, {
                                npcId: latestNpc.id,
                                npc: latestNpc,
                                card,
                                locationId: window.lastRenderedLocation?.id || null
                            });
                        } catch (error) {
                            console.warn('Failed to open teleport modal:', error);
                            alert(`Unable to teleport character: ${error?.message || error}`);
                        }
                    });
                }

                if (memoriesButton) {
                    memoriesButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = npcDataCache.get(npc.id) || npc;
                        showNpcMemoriesModal(latestNpc);
                    });
                }

                if (goalsButton) {
                    goalsButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = npcDataCache.get(npc.id) || npc;
                        showNpcGoalsModal(latestNpc);
                    });
                }

                if (recruitButton) {
                    recruitButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                        const latestNpc = npcDataCache?.get(npc.id) || npc;
                        try {
                            await recruitNpcToParty(latestNpc, { card });
                        } catch (error) {
                            console.warn('Failed to recruit NPC:', error);
                            alert(`Failed to recruit NPC: ${error?.message || 'Unknown error'}`);
                        }
                    });
                }

                if (dismissButton) {
                    dismissButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                        const latestNpc = npcDataCache?.get(npc.id) || npc;
                        try {
                            await dismissNpcFromParty(latestNpc, { card });
                        } catch (error) {
                            console.warn('Failed to dismiss NPC from party:', error);
                            alert(`Failed to dismiss NPC: ${error?.message || 'Unknown error'}`);
                        }
                    });
                }

                if (dispositionButton) {
                    dispositionButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = npcDataCache.get(npc.id) || npc;
                        await showNpcDispositionModal(latestNpc);
                    });
                }

                if (killButton) {
                    killButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();

                        const cachedNpc = npcDataCache.get(npc.id) || npc;
                        const npcName = cachedNpc?.name || 'this NPC';
                        const confirmation = window.confirm(`Kill ${npcName}? This will set their health to zero and mark them as dead.`);
                        if (!confirmation) {
                            return;
                        }

                        showLocationOverlay('Killing character...');
                        try {
                            const response = await fetch(`/api/npcs/${encodeURIComponent(npc.id)}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ health: 0, isDead: true })
                            });
                            const result = await response.json().catch(() => ({}));
                            if (!response.ok || !result?.success) {
                                throw new Error(result?.error || `HTTP ${response.status}`);
                            }

                            const updatedNpc = result?.npc || { ...(cachedNpc || {}), health: 0, isDead: true };
                            npcDataCache.set(npc.id, updatedNpc);
                            card?.classList.add('is-dead');

                            window.refreshParty?.();
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } catch (error) {
                            console.warn('Failed to kill NPC:', error);
                            alert(`Failed to kill NPC: ${error?.message || 'Unknown error'}`);
                        } finally {
                            hideLocationOverlay();
                        }
                    });
                }

                if (deleteButton) {
                    deleteButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();

                        const cachedNpc = npcDataCache.get(npc.id) || npc;
                        const npcName = cachedNpc?.name || 'this NPC';
                        const confirmation = window.confirm(`Delete ${npcName}? This cannot be undone.`);
                        if (!confirmation) {
                            return;
                        }

                        const fallbackLocationId = cachedNpc?.locationId || cachedNpc?.currentLocation || npc.currentLocation || lastRenderedLocation?.id || null;

                        showLocationOverlay('Removing character...');
                        try {
                            const response = await fetch(`/api/npcs/${encodeURIComponent(npc.id)}`, {
                                method: 'DELETE'
                            });
                            const result = await response.json().catch(() => ({}));
                            if (!response.ok || !result?.success) {
                                throw new Error(result?.error || `HTTP ${response.status}`);
                            }

                            npcDataCache.delete(npc.id);

                            const targetLocationId = result?.locationId || fallbackLocationId;
                            let refreshed = false;

                            if (targetLocationId) {
                                try {
                                    const refreshedResp = await fetch(`/api/locations/${encodeURIComponent(targetLocationId)}`);
                                    const refreshedData = await refreshedResp.json().catch(() => ({}));
                                    if (refreshedResp.ok && refreshedData?.success && refreshedData.location) {
                                        await window.updateLocationDisplay(refreshedData.location);
                                        refreshed = true;
                                    }
                                } catch (refreshError) {
                                    console.warn('Failed to refresh location after NPC deletion:', refreshError);
                                }
                            }

                            if (!refreshed && lastRenderedLocation) {
                                if (Array.isArray(lastRenderedLocation.npcs)) {
                                    lastRenderedLocation.npcs = lastRenderedLocation.npcs.filter(entry => entry.id !== npc.id);
                                }
                                if (Array.isArray(lastRenderedLocation.npcIds)) {
                                    lastRenderedLocation.npcIds = lastRenderedLocation.npcIds.filter(id => id !== npc.id);
                                }
                                await window.updateLocationDisplay(lastRenderedLocation);
                            } else if (!refreshed && card && card.parentElement) {
                                card.remove();
                            }

                            window.refreshParty?.();
                        } catch (error) {
                            console.warn('Failed to delete NPC:', error);
                            alert(`Failed to delete NPC: ${error?.message || 'Unknown error'}`);
                        } finally {
                            hideLocationOverlay();
                        }
                    });
                }

                menu.addEventListener('click', (event) => event.stopPropagation());
                card.addEventListener('click', () => {
                    if (npcMenuState.openMenu) {
                        closeNpcContextMenu();
                    }
                });

                card.appendChild(button);
                card.appendChild(menu);
            }

            window.registerNpcContextMenu = registerNpcContextMenu;

            document.addEventListener('click', () => {
                if (npcMenuState.openMenu) {
                    closeNpcContextMenu();
                }
            });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeNpcContextMenu();
                }
            });

            function showLocationOverlay(message = 'Loading location...') {
                try {
                    window.floatingTooltipController?.hide?.();
                } catch (_) {
                    // Tooltip controller may not be initialized yet.
                }
                if (locationOverlay) {
                    locationOverlay.classList.add('show');
                    locationOverlay.setAttribute('aria-busy', 'true');
                    if (locationOverlayText && message) {
                        locationOverlayText.textContent = message;
                    }
                }
            }

            function hideLocationOverlay() {
                if (locationOverlay) {
                    locationOverlay.classList.remove('show');
                    locationOverlay.setAttribute('aria-busy', 'false');
                }
            }

            if (typeof window !== 'undefined') {
                window.showLocationOverlay = showLocationOverlay;
                window.hideLocationOverlay = hideLocationOverlay;
            }

        function setLocationEditStatus(message = '', type = null) {
            if (!locationEditStatus) {
                return;
            }
            locationEditStatus.textContent = message || '';
            locationEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                locationEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                locationEditStatus.classList.add('is-success');
            }
        }

        const UNKNOWN_LEVEL_DISPLAY = '‚Äî';

        function updateLocationAbsoluteLevelDisplay(value) {
            if (!locationEditAbsoluteLevel) {
                return;
            }
            if (Number.isFinite(value)) {
                const normalized = Math.max(1, Math.round(value));
                locationEditAbsoluteLevel.textContent = String(normalized);
            } else {
                locationEditAbsoluteLevel.textContent = UNKNOWN_LEVEL_DISPLAY;
            }
        }

        function openLocationEditModal() {
            if (!locationEditModal || !lastRenderedLocation) {
                return;
            }
            const name = lastRenderedLocation.name || '';
            const description = lastRenderedLocation.description || '';
            const numericLevel = Number.isFinite(lastRenderedLocation.baseLevel)
                ? lastRenderedLocation.baseLevel
                : null;

            if (locationEditNameInput) {
                locationEditNameInput.value = name;
            }
            if (locationEditDescriptionInput) {
                locationEditDescriptionInput.value = description;
            }
            if (locationEditLevelInput) {
                locationEditLevelInput.value = numericLevel ?? '';
            }
            updateLocationAbsoluteLevelDisplay(numericLevel);

            setLocationEditStatus('', null);
            locationEditModal.removeAttribute('hidden');
            locationEditModal.setAttribute('aria-hidden', 'false');
            locationEditModal.classList.add('is-open');
            setTimeout(() => {
                locationEditNameInput?.focus();
            }, 50);
        }

        function closeLocationEditModal() {
            if (!locationEditModal) {
                return;
            }
            locationEditModal.setAttribute('hidden', '');
            locationEditModal.setAttribute('aria-hidden', 'true');
            locationEditModal.classList.remove('is-open');
            setLocationEditStatus('', null);
            updateLocationAbsoluteLevelDisplay(null);
        }

        async function submitLocationEditForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!locationEditForm || !lastRenderedLocation || !lastRenderedLocation.id) {
                setLocationEditStatus('No active location to edit.', 'error');
                return;
            }

            const payload = {};
            const nameValue = locationEditNameInput?.value ?? '';
            payload.name = nameValue.trim() || null;

            const descriptionValue = locationEditDescriptionInput?.value ?? '';
            if (!descriptionValue.trim()) {
                setLocationEditStatus('Description cannot be empty.', 'error');
                locationEditDescriptionInput?.focus();
                return;
            }
            payload.description = descriptionValue.trim();

            const levelValue = Number(locationEditLevelInput?.value ?? NaN);
            if (!Number.isFinite(levelValue) || levelValue < 1) {
                setLocationEditStatus('Level must be a positive number.', 'error');
                locationEditLevelInput?.focus();
                return;
            }
            payload.level = Math.max(1, Math.round(levelValue));

            setLocationEditStatus('Saving changes...', null);
            if (locationEditSaveBtn) {
                locationEditSaveBtn.disabled = true;
            }
            showLocationOverlay('Updating location...');

            try {
                const response = await fetch(`/api/locations/${encodeURIComponent(lastRenderedLocation.id)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setLocationEditStatus('Location updated.', 'success');
                closeLocationEditModal();

                if (data.location) {
                    lastRenderedLocation = JSON.parse(JSON.stringify(data.location));
                    await window.updateLocationDisplay(data.location);
                } else {
                    await window.loadCurrentLocation?.();
                }
            } catch (error) {
                console.warn('Failed to update location:', error);
                setLocationEditStatus(`Failed to update location: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (locationEditSaveBtn) {
                    locationEditSaveBtn.disabled = false;
                }
                hideLocationOverlay();
            }
        }

        const summonNpcOptionIndex = new Map();
        const summonThingOptionIndex = new Map();

        function resetSummonSelect(selectElement, placeholderLabel) {
            if (!selectElement) {
                return;
            }
            selectElement.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = placeholderLabel;
            option.disabled = true;
            option.selected = true;
            option.hidden = true;
            selectElement.appendChild(option);
            selectElement.value = '';
        }

        function setSummonNpcStatus(message = '', type = null) {
            if (!summonNpcStatus) {
                return;
            }
            summonNpcStatus.textContent = message || '';
            summonNpcStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                summonNpcStatus.classList.add('is-error');
            } else if (type === 'success') {
                summonNpcStatus.classList.add('is-success');
            }
        }

        function setSummonThingStatus(message = '', type = null) {
            if (!summonThingStatus) {
                return;
            }
            summonThingStatus.textContent = message || '';
            summonThingStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                summonThingStatus.classList.add('is-error');
            } else if (type === 'success') {
                summonThingStatus.classList.add('is-success');
            }
        }

        async function loadSummonActorDirectory() {
            const response = await fetch('/api/players', { cache: 'no-store' });
            const data = await response.json().catch(() => ({}));
            if (!response.ok || !data?.success || !Array.isArray(data.players)) {
                throw new Error(data?.error || `HTTP ${response.status}`);
            }

            const directory = {
                list: [],
                map: new Map()
            };

            data.players.forEach(entry => {
                if (!entry || !entry.id) {
                    return;
                }
                directory.list.push(entry);
                directory.map.set(entry.id, entry);
            });

            return directory;
        }

        async function gatherSummonResources() {
            const [actorDirectory, locationOptions] = await Promise.all([
                loadSummonActorDirectory(),
                loadTeleportLocationOptions()
            ]);

            const locationLabelMap = new Map();
            if (Array.isArray(locationOptions)) {
                locationOptions.forEach(option => {
                    if (option && option.id) {
                        locationLabelMap.set(option.id, option.label || option.id);
                    }
                });
            }

            return { actorDirectory, locationLabelMap };
        }

        async function gatherSummonNpcOptions() {
            const currentLocationId = lastRenderedLocation?.id || null;
            if (!currentLocationId) {
                throw new Error('No active location loaded.');
            }

            const { actorDirectory, locationLabelMap } = await gatherSummonResources();
            const options = [];

            for (const npc of actorDirectory.list) {
                if (!npc || !npc.id || !npc.isNPC) {
                    continue;
                }
                const name = typeof npc.name === 'string' ? npc.name.trim() : '';
                if (!name) {
                    continue;
                }
                if (npc.isDead) {
                    continue;
                }
                const locationIdRaw = typeof npc.locationId === 'string' ? npc.locationId.trim() : '';
                if (locationIdRaw && locationIdRaw === currentLocationId) {
                    continue;
                }
                const locationName = locationIdRaw
                    ? (locationLabelMap.get(locationIdRaw) || `Location ${locationIdRaw}`)
                    : 'Unknown location';
                options.push({
                    id: npc.id,
                    name,
                    locationId: locationIdRaw || null,
                    locationName,
                    raw: npc
                });
            }

            options.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
            return options;
        }

        async function gatherSummonThingOptions() {
            const currentLocationId = lastRenderedLocation?.id || null;
            if (!currentLocationId) {
                throw new Error('No active location loaded.');
            }

            const { actorDirectory, locationLabelMap } = await gatherSummonResources();
            const response = await fetch('/api/things', { cache: 'no-store' });
            const data = await response.json().catch(() => ({}));
            if (!response.ok || !data?.success || !Array.isArray(data.things)) {
                throw new Error(data?.error || `HTTP ${response.status}`);
            }

            const options = [];
            const seenIds = new Set();

            data.things.forEach(thing => {
                if (!thing || !thing.id || seenIds.has(thing.id)) {
                    return;
                }
                const name = typeof thing.name === 'string' ? thing.name.trim() : '';
                if (!name) {
                    return;
                }
                const type = typeof thing.thingType === 'string' ? thing.thingType.trim().toLowerCase() : '';
                if (type !== 'item' && type !== 'scenery') {
                    return;
                }

                const metadata = thing.metadata && typeof thing.metadata === 'object' ? thing.metadata : {};
                const locationIdRaw = typeof metadata.locationId === 'string' ? metadata.locationId.trim() : '';
                if (locationIdRaw && locationIdRaw === currentLocationId) {
                    return;
                }

                const ownerIdRaw = typeof metadata.ownerId === 'string' ? metadata.ownerId.trim()
                    : (typeof metadata.ownerID === 'string' ? metadata.ownerID.trim() : '');
                const ownerNameMeta = typeof metadata.ownerName === 'string' ? metadata.ownerName.trim()
                    : (typeof metadata.owner === 'string' ? metadata.owner.trim() : '');
                let ownerName = ownerNameMeta || null;
                if (ownerIdRaw && actorDirectory.map.has(ownerIdRaw)) {
                    ownerName = actorDirectory.map.get(ownerIdRaw).name || ownerName || ownerIdRaw;
                } else if (!ownerName && ownerIdRaw) {
                    ownerName = ownerIdRaw;
                }

                let originLabel = 'Unknown location';
                if (locationIdRaw) {
                    originLabel = locationLabelMap.get(locationIdRaw) || `Location ${locationIdRaw}`;
                } else if (ownerName) {
                    originLabel = `${ownerName}'s inventory`;
                }

                const typeLabel = type === 'scenery' ? 'Scenery' : 'Item';
                options.push({
                    id: thing.id,
                    name,
                    type: typeLabel,
                    locationId: locationIdRaw || null,
                    ownerId: ownerIdRaw || null,
                    ownerName: ownerName || null,
                    originLabel,
                    raw: thing
                });
                seenIds.add(thing.id);
            });

            options.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
            return options;
        }

        async function applySummonLocationUpdate(payload) {
            if (!payload || !payload.id) {
                return false;
            }
            if (!window.lastRenderedLocation || window.lastRenderedLocation.id !== payload.id) {
                return false;
            }
            try {
                await window.updateLocationDisplay?.(payload);
                window.lastRenderedLocation = JSON.parse(JSON.stringify(payload));
                return true;
            } catch (error) {
                console.warn('Failed to apply location update:', error);
                return false;
            }
        }

        async function openSummonNpcModal() {
            if (!summonNpcModal) {
                alert('Summon NPC dialog is unavailable.');
                return;
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                alert('No location is currently loaded.');
                return;
            }

            summonNpcOptionIndex.clear();
            resetSummonSelect(summonNpcSelect, 'Select an NPC');
            if (summonNpcSelect) {
                summonNpcSelect.disabled = true;
            }
            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = true;
            }
            setSummonNpcStatus('Loading NPCs...', null);

            summonNpcModal.removeAttribute('hidden');
            summonNpcModal.setAttribute('aria-hidden', 'false');
            summonNpcModal.classList.add('is-open');
            requestAnimationFrame(() => {
                summonNpcSelect?.focus();
            });

            try {
                const options = await gatherSummonNpcOptions();

                if (!options.length) {
                    setSummonNpcStatus('No NPCs are available to summon.', 'error');
                    return;
                }

                const fragment = document.createDocumentFragment();
                options.forEach(option => {
                    summonNpcOptionIndex.set(option.id, option);
                    const opt = document.createElement('option');
                    opt.value = option.id;
                    opt.textContent = `${option.name} ‚Äî ${option.locationName}`;
                    opt.dataset.locationId = option.locationId || '';
                    opt.dataset.locationName = option.locationName || '';
                    fragment.appendChild(opt);
                });

                if (summonNpcSelect) {
                    summonNpcSelect.appendChild(fragment);
                    summonNpcSelect.disabled = false;
                    summonNpcSelect.value = '';
                }

                setSummonNpcStatus('', null);
            } catch (error) {
                console.warn('Failed to load summon NPC options:', error);
                setSummonNpcStatus(`Failed to load NPCs: ${error?.message || error}`, 'error');
            }
        }

        function closeSummonNpcModal() {
            if (!summonNpcModal) {
                return;
            }
            summonNpcModal.setAttribute('hidden', '');
            summonNpcModal.setAttribute('aria-hidden', 'true');
            summonNpcModal.classList.remove('is-open');
            setSummonNpcStatus('', null);
            summonNpcOptionIndex.clear();
            resetSummonSelect(summonNpcSelect, 'Select an NPC');
            if (summonNpcSelect) {
                summonNpcSelect.disabled = true;
            }
            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = true;
            }
        }

        async function openSummonThingModal() {
            if (!summonThingModal) {
                alert('Summon item dialog is unavailable.');
                return;
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                alert('No location is currently loaded.');
                return;
            }

            summonThingOptionIndex.clear();
            resetSummonSelect(summonThingSelect, 'Select an item');
            if (summonThingSelect) {
                summonThingSelect.disabled = true;
            }
            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = true;
            }
            setSummonThingStatus('Loading items...', null);

            summonThingModal.removeAttribute('hidden');
            summonThingModal.setAttribute('aria-hidden', 'false');
            summonThingModal.classList.add('is-open');
            requestAnimationFrame(() => {
                summonThingSelect?.focus();
            });

            try {
                const options = await gatherSummonThingOptions();

                if (!options.length) {
                    setSummonThingStatus('No items or scenery are available to summon.', 'error');
                    return;
                }

                const fragment = document.createDocumentFragment();
                options.forEach(option => {
                    summonThingOptionIndex.set(option.id, option);
                    const opt = document.createElement('option');
                    opt.value = option.id;
                    opt.textContent = `${option.name} ‚Äî ${option.type} ¬∑ ${option.originLabel}`;
                    opt.dataset.origin = option.originLabel || '';
                    fragment.appendChild(opt);
                });

                if (summonThingSelect) {
                    summonThingSelect.appendChild(fragment);
                    summonThingSelect.disabled = false;
                    summonThingSelect.value = '';
                }

                setSummonThingStatus('', null);
            } catch (error) {
                console.warn('Failed to load summon item options:', error);
                setSummonThingStatus(`Failed to load items: ${error?.message || error}`, 'error');
            }
        }

        function closeSummonThingModal() {
            if (!summonThingModal) {
                return;
            }
            summonThingModal.setAttribute('hidden', '');
            summonThingModal.setAttribute('aria-hidden', 'true');
            summonThingModal.classList.remove('is-open');
            setSummonThingStatus('', null);
            summonThingOptionIndex.clear();
            resetSummonSelect(summonThingSelect, 'Select an item');
            if (summonThingSelect) {
                summonThingSelect.disabled = true;
            }
            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = true;
            }
        }

        function handleSummonNpcSelectionChange() {
            if (!summonNpcSelect) {
                return;
            }
            const npcId = summonNpcSelect.value;
            if (!npcId || !summonNpcOptionIndex.has(npcId)) {
                if (summonNpcConfirmBtn) {
                    summonNpcConfirmBtn.disabled = true;
                }
                return;
            }
            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = false;
            }
            setSummonNpcStatus('', null);
        }

        function handleSummonThingSelectionChange() {
            if (!summonThingSelect) {
                return;
            }
            const thingId = summonThingSelect.value;
            if (!thingId || !summonThingOptionIndex.has(thingId)) {
                if (summonThingConfirmBtn) {
                    summonThingConfirmBtn.disabled = true;
                }
                return;
            }
            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = false;
            }
            setSummonThingStatus('', null);
        }

        async function submitSummonNpcForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!summonNpcSelect) {
                return;
            }
            const npcId = summonNpcSelect.value;
            if (!npcId || !summonNpcOptionIndex.has(npcId)) {
                setSummonNpcStatus('Select an NPC to summon.', 'error');
                return;
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                setSummonNpcStatus('No location is currently loaded.', 'error');
                return;
            }

            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = true;
            }
            setSummonNpcStatus('Summoning NPC...', null);

            let overlayVisible = false;
            try {
                showLocationOverlay('Summoning NPC...');
                overlayVisible = true;
            } catch (_) {
                // Ignore overlay errors
            }

            try {
                const optionEntry = summonNpcOptionIndex.get(npcId);
                const npcRecord = optionEntry?.raw
                    ? (cloneActorRecord(optionEntry.raw) || { ...optionEntry.raw })
                    : { id: npcId };

                await teleportNpcToLocation(npcRecord, lastRenderedLocation.id, {
                    originLocationId: optionEntry?.locationId || null
                });

                closeSummonNpcModal();
            } catch (error) {
                console.warn('Failed to summon NPC:', error);
                setSummonNpcStatus(`Failed to summon NPC: ${error?.message || error}`, 'error');
            } finally {
                if (overlayVisible) {
                    hideLocationOverlay();
                }
                if (summonNpcConfirmBtn && summonNpcModal?.classList.contains('is-open')) {
                    summonNpcConfirmBtn.disabled = false;
                }
            }
        }

        async function submitSummonThingForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!summonThingSelect) {
                return;
            }
            const thingId = summonThingSelect.value;
            const entry = thingId ? summonThingOptionIndex.get(thingId) : null;
            if (!entry) {
                setSummonThingStatus('Select an item or scenery to summon.', 'error');
                return;
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                setSummonThingStatus('No location is currently loaded.', 'error');
                return;
            }

            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = true;
            }
            setSummonThingStatus('Summoning item...', null);

            let overlayVisible = false;
            try {
                showLocationOverlay('Summoning item...');
                overlayVisible = true;
            } catch (_) {
                // Ignore overlay errors
            }

            try {
                const teleportResult = await teleportThingToLocation(entry.raw, lastRenderedLocation.id, {
                    context: 'general',
                    originLocationId: entry.locationId || null
                });

                let locationUpdated = false;
                if (teleportResult?.previousLocation) {
                    locationUpdated = await applySummonLocationUpdate(teleportResult.previousLocation) || locationUpdated;
                }
                if (teleportResult?.destination) {
                    locationUpdated = await applySummonLocationUpdate(teleportResult.destination) || locationUpdated;
                }

                if (!locationUpdated && typeof window.loadCurrentLocation === 'function') {
                    try {
                        await window.loadCurrentLocation();
                    } catch (refreshError) {
                        console.warn('Failed to refresh location after item summon:', refreshError);
                    }
                }

                closeSummonThingModal();
            } catch (error) {
                console.warn('Failed to summon item:', error);
                setSummonThingStatus(`Failed to summon item: ${error?.message || error}`, 'error');
            } finally {
                if (overlayVisible) {
                    hideLocationOverlay();
                }
                if (summonThingConfirmBtn && summonThingModal?.classList.contains('is-open')) {
                    summonThingConfirmBtn.disabled = false;
                }
            }
        }

        function setRegionEditStatus(message = '', type = null) {
            if (!regionEditStatus) {
                return;
            }
            regionEditStatus.textContent = message || '';
            regionEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                regionEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                regionEditStatus.classList.add('is-success');
            }
        }

        function populateRegionParentOptions(options = [], selectedId = null) {
            if (!regionEditParentSelect) {
                return;
            }
            regionEditParentSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'None';
            regionEditParentSelect.appendChild(defaultOption);

            (options || []).forEach(option => {
                if (!option || !option.id) {
                    return;
                }
               const opt = document.createElement('option');
                opt.value = option.id;
                opt.textContent = option.name || option.id;
                if (option.id === selectedId) {
                    opt.selected = true;
                }
                regionEditParentSelect.appendChild(opt);
            });
        }

        async function openRegionEditModal() {
            if (!regionEditModal || !lastRenderedLocation) {
                return;
            }
            const regionId = lastRenderedLocation.regionId
                || lastRenderedLocation.stubMetadata?.regionId
                || null;

            if (!regionId) {
                alert('No region is associated with the current location.');
                return;
            }

            editingRegionId = regionId;
            if (regionEditForm) {
                regionEditForm.reset();
            }
            populateRegionParentOptions([], null);
            if (regionEditSaveBtn) {
                regionEditSaveBtn.disabled = true;
            }
            setRegionEditStatus('Loading region‚Ä¶', null);
            if (regionEditAverageLevelInput) {
                regionEditAverageLevelInput.value = '';
            }

            regionEditModal.removeAttribute('hidden');
            regionEditModal.setAttribute('aria-hidden', 'false');
            regionEditModal.classList.add('is-open');

            try {
                const response = await fetch(`/api/regions/${encodeURIComponent(regionId)}`);
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success || !data.region) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                if (regionEditNameInput) {
                    regionEditNameInput.value = data.region.name || '';
                }
                if (regionEditDescriptionInput) {
                    regionEditDescriptionInput.value = data.region.description || '';
                }
                if (regionEditAverageLevelInput) {
                    const averaged = Number.isFinite(data.region.averageLevel)
                        ? Math.max(1, Math.round(data.region.averageLevel))
                        : '';
                    regionEditAverageLevelInput.value = averaged;
                }
                populateRegionParentOptions(data.parentOptions || [], data.region.parentRegionId || null);
                setRegionEditStatus('', null);
                if (regionEditSaveBtn) {
                    regionEditSaveBtn.disabled = false;
                }
                setTimeout(() => {
                    regionEditNameInput?.focus();
                }, 50);
            } catch (error) {
                console.warn('Failed to load region for editing:', error);
                setRegionEditStatus(`Failed to load region: ${error?.message || 'Unknown error'}`, 'error');
                if (regionEditSaveBtn) {
                    regionEditSaveBtn.disabled = true;
                }
                if (regionEditAverageLevelInput) {
                    regionEditAverageLevelInput.value = '';
                }
            }
        }

        function closeRegionEditModal() {
            if (!regionEditModal) {
                return;
            }
            regionEditModal.setAttribute('hidden', '');
            regionEditModal.setAttribute('aria-hidden', 'true');
            regionEditModal.classList.remove('is-open');
            setRegionEditStatus('', null);
            if (regionEditForm) {
                regionEditForm.reset();
            }
            if (regionEditSaveBtn) {
                regionEditSaveBtn.disabled = false;
            }
            editingRegionId = null;
            if (regionEditAverageLevelInput) {
                regionEditAverageLevelInput.value = '';
            }
        }

        async function submitRegionEditForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!regionEditForm) {
                return;
            }
            if (!editingRegionId) {
                setRegionEditStatus('No region is currently selected for editing.', 'error');
                return;
            }

            const nameValue = regionEditNameInput?.value ?? '';
            if (!nameValue.trim()) {
                setRegionEditStatus('Region name cannot be empty.', 'error');
                regionEditNameInput?.focus();
                return;
            }

            const descriptionValue = regionEditDescriptionInput?.value ?? '';
            if (!descriptionValue.trim()) {
                setRegionEditStatus('Region description cannot be empty.', 'error');
                regionEditDescriptionInput?.focus();
                return;
            }

            const averageLevelRaw = regionEditAverageLevelInput?.value ?? '';
            if (!averageLevelRaw.toString().trim()) {
                setRegionEditStatus('Region average level is required.', 'error');
                regionEditAverageLevelInput?.focus();
                return;
            }
            const averageLevelValue = Number(averageLevelRaw);
            if (!Number.isFinite(averageLevelValue) || averageLevelValue < 1) {
                setRegionEditStatus('Average level must be a positive number.', 'error');
                regionEditAverageLevelInput?.focus();
                return;
            }
            const normalizedAverageLevel = Math.max(1, Math.min(20, Math.round(averageLevelValue)));
            if (regionEditAverageLevelInput) {
                regionEditAverageLevelInput.value = normalizedAverageLevel;
            }

            const parentValueRaw = regionEditParentSelect?.value ?? '';
            const payload = {
                name: nameValue.trim(),
                description: descriptionValue.trim(),
                parentRegionId: parentValueRaw && parentValueRaw.trim() ? parentValueRaw.trim() : null,
                averageLevel: normalizedAverageLevel
            };

            setRegionEditStatus('Saving changes‚Ä¶', null);
            if (regionEditSaveBtn) {
                regionEditSaveBtn.disabled = true;
            }

            try {
                const response = await fetch(`/api/regions/${encodeURIComponent(editingRegionId)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success || !data.region) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setRegionEditStatus('Region updated successfully.', 'success');
                newExitOptionsCache = null;
                newExitRegionsById = new Map();
                ensureNewExitOptionsLoaded(true).catch(error => {
                    console.warn('Failed to refresh exit options after region edit:', error);
                });

                const mapTab = document.querySelector('[data-tab="map"]');
                if (mapTab && mapTab.classList.contains('active')) {
                    const mapContainer = document.getElementById('mapContainer');
                    const activeRegionId = mapContainer?.dataset?.regionId || null;
                    if (!activeRegionId || activeRegionId === editingRegionId) {
                        try {
                            await window.loadRegionMap?.(activeRegionId || editingRegionId || null);
                        } catch (mapError) {
                            console.warn('Failed to refresh map after region edit:', mapError);
                        }
                    }
                }

                closeRegionEditModal();
            } catch (error) {
                console.warn('Failed to update region:', error);
                setRegionEditStatus(`Failed to update region: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (regionEditSaveBtn) {
                    regionEditSaveBtn.disabled = false;
                }
            }
        }

        async function regenerateLocationImage() {
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                alert('No location is currently loaded.');
                return;
            }
            if (locationImageRegenerateButton && locationImageRegenerateButton.disabled) {
                alert('Image generation is disabled.');
                return;
            }

            const locationId = String(lastRenderedLocation.id);
            const placeholderAlt = lastRenderedLocation.name || 'Location image';

            applyEntityImagePlaceholder('location', locationId);
            lastRenderedLocation.imageId = null;
            lastRenderedLocation.pendingImageJobId = null;

            const payload = {
                entityType: 'location',
                entityId: locationId,
                force: true
            };

            const clientId = window.AIRPG_CLIENT_ID || null;
            if (clientId) {
                payload.clientId = clientId;
            }

            try {
                const response = await fetch('/api/images/request', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                if (data?.skipped) {
                    renderEntityImages('location', locationId, {
                        imageId: lastRenderedLocation.imageId || null,
                        force: false,
                        altText: placeholderAlt
                    });
                    alert('Image regeneration was skipped.');
                    return;
                }

                if (data?.imageId) {
                    lastRenderedLocation.imageId = data.imageId;
                }
                if (data?.jobId) {
                    lastRenderedLocation.pendingImageJobId = data.jobId;
                }

                renderEntityImages('location', locationId, {
                    imageId: null,
                    force: true,
                    altText: placeholderAlt
                });
            } catch (error) {
                console.warn('Failed to regenerate location image:', error);
                alert(`Failed to regenerate image: ${error?.message || 'Unknown error'}`);
                renderEntityImages('location', locationId, {
                    imageId: lastRenderedLocation.imageId || null,
                    force: false,
                    altText: placeholderAlt
                });
            }
        }

        if (locationImageMenuButton) {
            locationImageMenuButton.addEventListener('click', (event) => {
                event.stopPropagation();
                toggleLocationImageMenu();
            });
        }

        if (locationImageEditButton) {
            locationImageEditButton.addEventListener('click', (event) => {
                event.stopPropagation();
                closeLocationImageMenu();
                openLocationEditModal();
            });
        }

        if (locationRegionEditButton) {
            locationRegionEditButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu();
                await openRegionEditModal();
            });
        }

        if (locationSummonNpcButton) {
            locationSummonNpcButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu();
                await openSummonNpcModal();
            });
        }

        if (locationSummonThingButton) {
            locationSummonThingButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu();
                await openSummonThingModal();
            });
        }

        if (locationImageRegenerateButton) {
            locationImageRegenerateButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu();
                await regenerateLocationImage();
            });
        }

        document.addEventListener('click', (event) => {
            if (!locationImageMenuOpen) {
                return;
            }
            if (locationImageWrapper && locationImageWrapper.contains(event.target)) {
                return;
            }
            closeLocationImageMenu();
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && locationImageMenuOpen) {
                closeLocationImageMenu();
            }
        });

        if (locationEditCancelBtn) {
            locationEditCancelBtn.addEventListener('click', () => closeLocationEditModal());
        }
        if (locationEditCloseBtn) {
            locationEditCloseBtn.addEventListener('click', () => closeLocationEditModal());
        }
        if (locationEditForm) {
            locationEditForm.addEventListener('submit', submitLocationEditForm);
        }

        if (summonNpcCancelBtn) {
            summonNpcCancelBtn.addEventListener('click', () => closeSummonNpcModal());
        }
        if (summonNpcCloseBtn) {
            summonNpcCloseBtn.addEventListener('click', () => closeSummonNpcModal());
        }
        if (summonNpcForm) {
            summonNpcForm.addEventListener('submit', submitSummonNpcForm);
        }
        if (summonNpcSelect) {
            summonNpcSelect.addEventListener('change', handleSummonNpcSelectionChange);
        }

        if (summonThingCancelBtn) {
            summonThingCancelBtn.addEventListener('click', () => closeSummonThingModal());
        }
        if (summonThingCloseBtn) {
            summonThingCloseBtn.addEventListener('click', () => closeSummonThingModal());
        }
        if (summonThingForm) {
            summonThingForm.addEventListener('submit', submitSummonThingForm);
        }
        if (summonThingSelect) {
            summonThingSelect.addEventListener('change', handleSummonThingSelectionChange);
        }

        if (locationEditLevelInput) {
            locationEditLevelInput.addEventListener('input', () => {
                const raw = locationEditLevelInput.value;
                const hasValue = typeof raw === 'string' && raw.trim() !== '';
                const parsed = hasValue ? Number(raw) : null;
                const normalized = Number.isFinite(parsed) ? parsed : null;
                updateLocationAbsoluteLevelDisplay(normalized);
            });
        }

        if (regionEditCancelBtn) {
            regionEditCancelBtn.addEventListener('click', () => closeRegionEditModal());
        }
        if (regionEditCloseBtn) {
            regionEditCloseBtn.addEventListener('click', () => closeRegionEditModal());
        }
        if (regionEditForm) {
            regionEditForm.addEventListener('submit', submitRegionEditForm);
        }

        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeLocationEditModal();
                closeRegionEditModal();
            }
        });

        window.updateLocationDisplay = async function(location) {
                const locationName = document.getElementById('locationName');
                const locationTooltip = document.getElementById('locationTooltip');
                const locationHint = document.getElementById('locationHint');
                const locationLevel = document.getElementById('locationLevel');
                const locationImage = document.getElementById('locationImage');
        const locationExitsList = document.getElementById('locationExitsList');
                const tooltipController = window.floatingTooltipController;

                if (tooltipController && typeof tooltipController.hide === 'function') {
                    tooltipController.hide();
                }

                closeNpcContextMenu();
                npcDataCache.clear();

                const maybeLoadThingDetails = async (loc) => {
                    if (!loc) {
                        return [];
                    }
                    let resolvedThings = Array.isArray(loc.things) ? [...loc.things] : [];
                    if (resolvedThings.length === 0 && Array.isArray(loc.thingIds) && loc.thingIds.length > 0) {
                        const fetched = await Promise.all(loc.thingIds.map(fetchThingDetails));
                        resolvedThings = fetched.filter(Boolean);
                        if (resolvedThings.length > 0) {
                            loc.things = resolvedThings;
                        }
                    }
                    return resolvedThings;
                };

                if (location) {
                    const locationDescriptionHtml = location.description || 'No description available.';
                    const locationDescriptionText = locationDescriptionHtml
                        .replace(/<[^>]+>/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim() || 'No description available.';

                    locationName.textContent = location.name || 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = locationDescriptionHtml;
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        const awaitingImage = !location.imageId;
                        if (awaitingImage) {
                            locationHint.textContent = locationImageGenerationEnabled
                                ? 'Generating location image...'
                                : 'Location image generation is disabled.';
                        } else {
                            locationHint.textContent = location.description
                                ? 'Hover over the location image for a description.'
                                : 'No description available for this location yet.';
                        }
                    }
                    locationLevel.textContent = `Level: ${location.baseLevel || '?'}`;
                    locationCache[location.id] = location.name || location.description || location.id;
                    
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        const placeholderMarkup = locationImageGenerationEnabled
                            ? '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>'
                            : '<div class="location-placeholder"></div>';

                        const finalizeTooltip = () => {
                            if (existingTooltip && !existingTooltip.isConnected) {
                                locationImage.appendChild(existingTooltip);
                            }
                        };

                        const renderPromise = renderEntityImage({
                            element: locationImage,
                            entityType: 'location',
                            entityId: location.id,
                            imageId: location.imageId || null,
                            altText: location.name || 'Location image',
                            placeholderIcon: 'üèûÔ∏è',
                            placeholderClass: 'location-placeholder',
                            placeholderMarkup,
                            enableLightbox: true
                        });

                        finalizeTooltip();

                        if (renderPromise && typeof renderPromise.then === 'function') {
                            renderPromise.then(result => {
                                finalizeTooltip();
                                if (result?.imageId && locationHint) {
                                    locationHint.textContent = location.description ? 'Hover over the location image for a description.' : 'No description available for this location yet.';
                                }
                                const imageUrl = result?.imageUrl || (result?.imageId ? `/generated-images/${result.imageId}.png` : null);
                                updateAdventureBackground(imageUrl);
                            }).catch(() => {
                                finalizeTooltip();
                                if (locationHint) {
                                    locationHint.textContent = 'Image unavailable.';
                                }
                                updateAdventureBackground(null);
                            });
                        } else {
                            const fallbackUrl = location.imageId ? `/generated-images/${location.imageId}.png` : null;
                            updateAdventureBackground(fallbackUrl);
                        }

                        if (locationDescriptionText) {
                            locationImage.setAttribute('aria-label', locationDescriptionText);
                        } else {
                            locationImage.removeAttribute('aria-label');
                        }

                        if (tooltipController && typeof tooltipController.show === 'function') {
                            locationImage.onmouseenter = (event) => {
                                tooltipController.show(locationDescriptionHtml, event, { allowHTML: true });
                            };
                            locationImage.onmousemove = (event) => {
                                tooltipController.move(event);
                            };
                            locationImage.onmouseleave = () => {
                                tooltipController.hide();
                            };
                        } else {
                            locationImage.onmouseenter = null;
                            locationImage.onmousemove = null;
                            locationImage.onmouseleave = null;
                        }
                    }

                    if (newExitButton) {
                        newExitButton.disabled = false;
                    }
                    if (addNpcButton) {
                        addNpcButton.disabled = false;
                    }
                    if (addThingButton) {
                        addThingButton.disabled = false;
                    }
                    if (locationExitsList) {
                        const rawExitEntries = Object.entries(location.exits || {});
                        if (rawExitEntries.length === 0) {
                            locationExitsList.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                        } else {
                            const currentRegionId = location.regionId
                                || location.stubMetadata?.regionId
                                || null;

                            const localExitEntries = [];
                            const regionExitEntries = [];

                            rawExitEntries.forEach(([key, exit]) => {
                                if (!exit || !exit.destination) {
                                    return;
                                }

                                console.log(exit);

                                const destinationRegionId = exit.destinationRegion || null;
                                const regionMatchesCurrent = Boolean(destinationRegionId && currentRegionId && destinationRegionId === currentRegionId);

                                const isRegionExit = Boolean(destinationRegionId && !regionMatchesCurrent);
                                const targetList = isRegionExit ? regionExitEntries : localExitEntries;
                                targetList.push({ key, exit, destinationRegionId, isRegionExit });
                            });

                            const orderedExitEntries = [...localExitEntries, ...regionExitEntries];

                            if (!orderedExitEntries.length) {
                                locationExitsList.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                            } else {
                                locationExitsList.innerHTML = '';
                                orderedExitEntries.forEach(({ key, exit, destinationRegionId, isRegionExit }) => {
                                    const exitId = typeof exit.id === 'string' && exit.id.trim() ? exit.id.trim() : null;
                                    const container = document.createElement('div');
                                    container.className = 'exit-item';
                                    container.dataset.direction = key;
                                    if (exitId) {
                                        container.dataset.exitId = exitId;
                                    }

                                    const travelButton = document.createElement('button');
                                    travelButton.type = 'button';
                                    travelButton.className = 'exit-button';
                                    const destinationName = resolveDestinationNameStrict(exit);
                                    const isVehicle = Boolean(exit.isVehicle);
                                    const vehiclePrefix = isVehicle
                                        ? `${exit.vehicleType ? `${exit.vehicleType}` : 'Vehicle'} to `
                                        : '';

                                    if (isRegionExit || exit.destinationIsRegionEntryStub) {
                                        travelButton.classList.add('region-exit');
                                        const regionName = (typeof exit.destinationRegionName === 'string' && exit.destinationRegionName.trim())
                                            ? exit.destinationRegionName.trim()
                                            : destinationName;
                                        const locationName = destinationName;
                                        if (exit.destinationRegionExpanded) {
                                            travelButton.textContent = `${vehiclePrefix}${regionName}: ${locationName}`;
                                            travelButton.classList.add('region-exit-expanded');
                                        } else {
                                            travelButton.textContent = `${vehiclePrefix}Unexplored Region: ${regionName}`;
                                            travelButton.classList.add('region-exit-unexplored');
                                        }
                                        if (destinationRegionId) {
                                            travelButton.dataset.regionId = destinationRegionId;
                                        }
                                    } else {
                                        travelButton.textContent = destinationName;
                                    }

                                    travelButton.dataset.destinationId = exit.destination;
                                    const destinationIsStub = Boolean(exit.destinationIsStub);
                                    const isExplored = !destinationIsStub && (!isRegionExit || Boolean(exit.destinationRegionExpanded));
                                    travelButton.classList.add(isExplored ? 'exit-button--explored' : 'exit-button--unexplored');
                                    travelButton.addEventListener('click', () => moveToLocation({
                                        exit,
                                        direction: key,
                                        originLocationId: location.id
                                    }));
                                    container.appendChild(travelButton);

                                    if (exitId) {
                                        const friendlyName = destinationName;

                                        const editButton = document.createElement('button');
                                        editButton.type = 'button';
                                        editButton.className = 'exit-edit-button';
                                        editButton.textContent = '‚úèÔ∏è';
                                        editButton.setAttribute('aria-label', `Edit exit: ${friendlyName}`);
                                        editButton.title = `Edit exit: ${friendlyName}`;

                                        editButton.addEventListener('click', (event) => {
                                            event.preventDefault();
                                            event.stopPropagation();
                                            openNewExitModal({
                                                mode: 'edit',
                                                exit: { ...exit },
                                                exitId,
                                                direction: key,
                                                locationId: location.id
                                            });
                                        });

                                        container.appendChild(editButton);

                                        const deleteButton = document.createElement('button');
                                        deleteButton.type = 'button';
                                        deleteButton.className = 'exit-delete-button';
                                        deleteButton.textContent = 'üóëÔ∏è';

                                        deleteButton.setAttribute('aria-label', `Delete exit: ${friendlyName}`);
                                        deleteButton.title = `Delete exit: ${friendlyName}`;

                                        deleteButton.addEventListener('click', async (event) => {
                                            event.preventDefault();
                                            event.stopPropagation();

                                            const confirmed = window.confirm(`Delete exit "${friendlyName}"? This cannot be undone.`);
                                            if (!confirmed) {
                                                return;
                                            }

                                            deleteButton.disabled = true;
                                            try {
                                                const response = await fetch(`/api/locations/${encodeURIComponent(location.id)}/exits/${encodeURIComponent(exitId)}`, {
                                                    method: 'DELETE',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({ clientId: window.AIRPG_CLIENT_ID || null })
                                                });
                                                const data = await response.json().catch(() => null);
                                                if (!response.ok || !data?.success) {
                                                    throw new Error(data?.error || `HTTP ${response.status}`);
                                                }
                                                if (data.location && typeof window.updateLocationDisplay === 'function') {
                                                    await window.updateLocationDisplay(data.location);
                                                }
                                            } catch (error) {
                                                console.warn('Failed to delete exit:', error);
                                                alert(`Failed to delete exit: ${error.message || error}`);
                                            } finally {
                                                deleteButton.disabled = false;
                                            }
                                        });

                                        container.appendChild(deleteButton);
                                    }

                                    locationExitsList.appendChild(container);
                                });
                            }
                        }
                    }

                    if (locationNPCs) {
                        const npcs = Array.isArray(location.npcs) ? location.npcs : [];
                        if (npcs.length === 0) {
                            locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                        } else {
                            locationNPCs.innerHTML = '';
                            npcs.forEach(npc => {
                                const previous = npc?.id ? npcDataCache.get(npc.id) : null;

                                const card = document.createElement('div');
                                card.className = 'location-entity-card is-npc';

                                const portrait = document.createElement('div');
                                portrait.className = 'location-entity-icon';

                                const portraitImage = document.createElement('div');
                                portraitImage.className = 'location-entity-image';
                                portrait.appendChild(portraitImage);

                                const { bar: npcHealthBar, fill: npcHealthFill } = createHealthBar('npc-health-bar');
                                npcHealthFill.classList.add('npc-health-bar-fill');
                                portrait.appendChild(npcHealthBar);

                                const npcNeedBars = document.createElement('div');
                                npcNeedBars.className = 'npc-need-bars need-bars';
                                portrait.appendChild(npcNeedBars);

                                renderEntityImage({
                                    element: portraitImage,
                                    entityType: npc.isNPC ? 'npc' : 'player',
                                    entityId: npc.id,
                                    imageId: npc.imageId || null,
                                    altText: npc.name || 'NPC portrait',
                                    placeholderIcon: 'üé≠',
                                    placeholderClass: 'location-entity-placeholder'
                                });

                                if (npcHealthBar) {
                                    if (npc?.name) {
                                        npcHealthBar.setAttribute('aria-label', `${npc.name} health`);
                                    } else {
                                        npcHealthBar.removeAttribute('aria-label');
                                    }
                                }

                                updateHealthBar(npcHealthBar, npcHealthFill, npc?.health, npc?.maxHealth);

                                renderNeedBars(
                                    npcNeedBars,
                                    Array.isArray(npc?.needBars) ? npc.needBars : [],
                                    {
                                        includePlayerOnly: false,
                                        variant: 'npc',
                                        compact: true
                                    }
                                );

                                applyNpcDeathStyling(card, portrait, npc);

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = npc.name || 'Unknown NPC';
                                if (npc.isHostileToPlayer) {
                                    nameEl.classList.add('is-hostile');
                                }

                                card.appendChild(portrait);
                                card.appendChild(nameEl);
                                const npcDescriptionText = (npc.description || 'No description provided.')
                                    .replace(/<[^>]+>/g, ' ')
                                    .replace(/\s+/g, ' ')
                                    .trim() || 'No description provided.';
                                if (npcDescriptionText) {
                                    card.setAttribute('aria-label', npcDescriptionText);
                                }
                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        tooltipController.show(npcDescriptionText, event);
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }

                                locationNPCs.appendChild(card);

                                if (npc && npc.id) {
                                    if (typeof registerNpcContextMenu === 'function') {
                                        registerNpcContextMenu(card, npc);
                                    }
                                    triggerHealthChangeEffect(portrait, previous, npc);
                                    npcDataCache.set(npc.id, cloneActorRecord(npc) || { ...npc });
                                }
                            });
                        }
                    }

                    if (locationScenery || locationItems) {
                        const things = await maybeLoadThingDetails(location);
                        const sceneryThings = things.filter(thing => thing.thingType === 'scenery');
                        const itemThings = things.filter(thing => thing.thingType !== 'scenery');

                        const renderThingCollection = (container, collection, emptyMessage) => {
                            if (!container) {
                                return;
                            }
                            if (!collection.length) {
                                container.innerHTML = `<div class="location-thing-empty">${emptyMessage}</div>`;
                                return;
                            }

                            container.innerHTML = '';
                            collection.forEach(thing => {
                                const card = document.createElement('div');
                                card.className = `location-entity-card ${thing.thingType === 'scenery' ? 'is-scenery' : 'is-item'}`;

                                const icon = document.createElement('div');
                                icon.className = 'location-entity-icon';
                                const placeholderIcon = thing.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ';
                                renderEntityImage({
                                    element: icon,
                                    entityType: 'thing',
                                    entityId: thing.id,
                                    imageId: thing.imageId || null,
                                    altText: thing.name || 'Location item',
                                    placeholderIcon,
                                    placeholderClass: 'location-entity-placeholder'
                                });

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = thing.name || 'Unknown Object';
                                applyRarityClass(nameEl, thing.rarity);

                                card.appendChild(icon);
                                card.appendChild(nameEl);

                                registerThingContextMenu(card, thing, { context: 'location', locationId: location.id });

                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        const tooltipContent = formatThingTooltip(thing);
                                        tooltipController.show(tooltipContent, event, { allowHTML: true });
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }

                                container.appendChild(card);
                            });
                        };

                        renderThingCollection(locationScenery, sceneryThings, 'No notable scenery present.');
                        renderThingCollection(locationItems, itemThings, 'No notable items present.');
                    }

                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}

                    hideLocationOverlay();
                    const locationSnapshot = location ? JSON.parse(JSON.stringify(location)) : null;
                    lastRenderedLocation = locationSnapshot;
                    try {
                        window.AIRPG_LAST_LOCATION_ID = locationSnapshot?.id || null;
                        window.AIRPG_LAST_LOCATION = locationSnapshot
                            ? JSON.parse(JSON.stringify(locationSnapshot))
                            : null;
                    } catch (_) {
                        // Ignore failures to persist location snapshot globally
                    }
                } else {
                    locationName.textContent = 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = 'Your current location will appear here when you start exploring.';
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        locationHint.textContent = 'Hover over the location image for a description.';
                    }
                    locationLevel.textContent = 'Level: ?';
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        locationImage.innerHTML = locationImageGenerationEnabled
                            ? '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>'
                            : '<div class="location-placeholder"></div>';
                        if (existingTooltip) {
                            locationImage.appendChild(existingTooltip);
                        }
                        locationImage.removeAttribute('aria-label');
                        locationImage.onmouseenter = null;
                        locationImage.onmousemove = null;
                        locationImage.onmouseleave = null;
                    }
                    if (locationNPCs) {
                        locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                    }
                    if (locationScenery) {
                        locationScenery.innerHTML = '<div class="location-thing-empty">No notable scenery present.</div>';
                    }
                    if (locationItems) {
                        locationItems.innerHTML = '<div class="location-thing-empty">No notable items present.</div>';
                    }
                    if (locationExitsList) {
                        locationExitsList.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                    }
                    if (newExitButton) {
                        newExitButton.disabled = true;
                    }
                    if (addNpcButton) {
                        addNpcButton.disabled = true;
                    }
                    if (addThingButton) {
                        addThingButton.disabled = true;
                    }
                    npcDataCache.clear();
                    closeNpcContextMenu();
                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}
                    hideLocationOverlay();
                    lastRenderedLocation = null;
                    try {
                        window.AIRPG_LAST_LOCATION_ID = null;
                        window.AIRPG_LAST_LOCATION = null;
                    } catch (_) {
                        // Ignore failures to clear location snapshot
                    }
                    updateAdventureBackground(null);
                }
            };

            document.addEventListener('floatingTooltip:ready', () => {
                if (lastRenderedLocation) {
                    window.updateLocationDisplay(lastRenderedLocation);
                }
            });

            async function moveToLocation(moveRequest) {
                const exit = moveRequest?.exit;
                if (!exit || !exit.destination) {
                    return;
                }

                const originLocationId = (moveRequest && typeof moveRequest.originLocationId === 'string')
                    ? moveRequest.originLocationId
                    : null;
                const directionKey = (moveRequest && typeof moveRequest.direction === 'string' && moveRequest.direction.trim())
                    ? moveRequest.direction.trim()
                    : null;

                const destinationName = resolveDestinationNameStrict(exit);
                const regionName = exit.destinationRegion
                    ? (typeof exit.destinationRegionName === 'string' ? exit.destinationRegionName.trim() || null : null)
                    : null;
                const playerName = (window.currentPlayerData?.name || '').toString().trim();
                if (!playerName) {
                    throw new Error('Player name is missing when preparing travel narration for exit traversal.');
                }

                const message = `${playerName} moved to ${destinationName}.`;

                let overlayShown = false;
                const showMoveOverlay = () => {
                    if (!overlayShown) {
                        overlayShown = true;
                        showLocationOverlay(`Moving to ${destinationName}...`);
                    }
                };

        const useEventMove = shouldUseEventMove(exit);

        if (useEventMove) {
            showMoveOverlay();
            if (!window.AIRPG_CHAT || typeof window.AIRPG_CHAT.dispatchAutomatedMessage !== 'function') {
                        console.error('AIRPG chat client not available; cannot dispatch move command.');
                        hideLocationOverlay();
                        alert('Unable to queue move command via chat.');
                        return;
                    }

                    const travelMetadata = {
                        mode: 'event',
                        eventDriven: true,
                        exit: {
                            exitId: (typeof exit.id === 'string' && exit.id.trim()) ? exit.id.trim() : null,
                            originLocationId: originLocationId || null,
                            direction: directionKey,
                            destinationId: exit.destination || null,
                            destinationRegionId: exit.destinationRegion || null,
                            destinationIsStub: Boolean(exit.destinationIsStub),
                            destinationIsRegionEntryStub: Boolean(exit.destinationIsRegionEntryStub),
                            isVehicle: Boolean(exit.isVehicle),
                            vehicleType: typeof exit.vehicleType === 'string' ? exit.vehicleType.trim() : null,
                            destinationName,
                            regionName
                        }
                    };
                    try {
                        showMoveOverlay();
                        await window.AIRPG_CHAT.dispatchAutomatedMessage(message, {
                            travel: true,
                            travelMetadata
                        });
                    } catch (error) {
                        console.error('Failed to dispatch move via chat:', error);
                        hideLocationOverlay();
                        alert('Failed to queue move command via chat.');
                    }
            return;
        }

        if (window.AIRPG_CHAT && typeof window.AIRPG_CHAT.dispatchAutomatedMessage === 'function') {
            try {
                showMoveOverlay();
                await window.AIRPG_CHAT.dispatchAutomatedMessage(`# ${message}`, { travel: true });
            } catch (error) {
                console.error('Failed to dispatch move via chat:', error);
                hideLocationOverlay();
                alert('Failed to queue move command via chat.');
                return;
            }
        }

        await performDirectMove(exit.destination, destinationName);
    }

            async function performDirectMove(destinationId, destinationName) {
                if (!destinationId) {
                    return;
                }

                const resolvedDestinationName = (destinationName && destinationName.toString().trim()) || null;
                if (!resolvedDestinationName) {
                    throw new Error('Destination name is required for direct move.');
                }

                showLocationOverlay(`Moving to ${resolvedDestinationName}...`);
                try {
                    const response = await fetch('/api/player/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ destinationId })
                    });

                    const result = await response.json();
                    if (result.success && result.location) {
                        if (typeof result.location.name === 'string' && result.location.name.trim()) {
                            locationCache[result.location.id] = result.location.name.trim();
                        }
                        if (Array.isArray(result.location.exits)) {
                            result.location.exits.forEach(exit => {
                                if (exit.destination && typeof exit.destinationName === 'string' && exit.destinationName.trim()) {
                                    locationCache[exit.destination] = exit.destinationName.trim();
                                }
                            });
                        } else if (result.location.exits) {
                            Object.values(result.location.exits).forEach(exit => {
                                if (exit?.destination && typeof exit.destinationName === 'string' && exit.destinationName.trim()) {
                                    locationCache[exit.destination] = exit.destinationName.trim();
                                }
                            });
                        }
                        await window.updateLocationDisplay(result.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    } else if (result.error) {
                        hideLocationOverlay();
                        alert(`Move failed: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Move failed:', error);
                    hideLocationOverlay();
                    alert(`Move failed: ${error.message}`);
                }
            }

            // Load current player location on page load
            showLocationOverlay('Loading current location...');
            loadCurrentLocation().finally(() => hideLocationOverlay());
        }

        function initFloatingTooltipController() {
            const floatingTooltip = document.getElementById('inventoryTooltip');

            if (!floatingTooltip) {
                window.floatingTooltipController = null;
                return;
            }

            const hideTooltip = () => {
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            };

            const positionTooltip = (event) => {
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            };

            const controller = {
                show(content, event, options = {}) {
                    if (!content || !event) {
                        return;
                    }
                    const { allowHTML = false } = options;
                    if (allowHTML) {
                        floatingTooltip.innerHTML = content;
                    } else {
                        floatingTooltip.textContent = content;
                    }
                    floatingTooltip.removeAttribute('hidden');
                    floatingTooltip.classList.add('visible');
                    positionTooltip(event);
                },
                move(event) {
                    if (floatingTooltip.hasAttribute('hidden')) {
                        return;
                    }
                    positionTooltip(event);
                },
                hide() {
                    hideTooltip();
                }
            };

            window.floatingTooltipController = controller;

            floatingTooltip.addEventListener('mouseleave', hideTooltip);
            window.addEventListener('scroll', hideTooltip, { passive: true });

            try {
                document.dispatchEvent(new CustomEvent('floatingTooltip:ready'));
            } catch (_) {
                // CustomEvent may not be available in older environments; ignore.
            }
        }

        function initPlayerOverviewSync() {
            async function refreshPlayerOverview() {
                try {
                    const response = await fetch('/api/player');
                    const data = await response.json();
                    if (data.success && data.player) {
                        updateChatPlayerPanel(data.player);
                        if (Array.isArray(data.player.partyMembers)) {
                            renderChatPartyPanel(data.player.partyMembers);
                        }
                    }
                } catch (error) {
                    console.warn('Failed to refresh player overview:', error);
                }
            }

            window.refreshInventory = refreshPlayerOverview;
            window.updateInventoryDisplay = refreshPlayerOverview;
            refreshPlayerOverview();
        }

        function initPartyDisplay() {
            const partyGrid = document.getElementById('partyMembers');
            const emptyState = document.getElementById('partyEmpty');
            const countLabel = document.getElementById('partyCount');
            const floatingTooltip = document.getElementById('partyTooltip');
            const partyPanel = document.querySelector('.party-panel');

            const statOrder = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'];
            const statLabels = {
                strength: 'STR',
                dexterity: 'DEX',
                constitution: 'CON',
                intelligence: 'INT',
                wisdom: 'WIS',
                charisma: 'CHA'
            };

            function hideTooltip() {
                if (!floatingTooltip) return;
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            }

            function positionTooltip(event) {
                if (!floatingTooltip) return;
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            }

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            function renderParty(members = []) {
                if (!partyGrid || !emptyState || !countLabel) {
                    return;
                }

                const safeMembers = Array.isArray(members)
                    ? members.filter(member => member && typeof member === 'object')
                    : [];
                partyGrid.innerHTML = '';
                hideTooltip();

                countLabel.textContent = `${safeMembers.length} ${safeMembers.length === 1 ? 'member' : 'members'}`;
                emptyState.style.display = safeMembers.length ? 'none' : 'block';
                partyGrid.style.display = safeMembers.length ? 'flex' : 'none';

                const previousSnapshots = new Map();
                if (npcDataCache instanceof Map) {
                    safeMembers.forEach(member => {
                        if (member?.id && npcDataCache.has(member.id)) {
                            previousSnapshots.set(member.id, npcDataCache.get(member.id));
                        }
                    });
                }

                renderChatPartyPanel(safeMembers);

                safeMembers.forEach(member => {
                    if (!member) {
                        return;
                    }

                    const previous = member?.id ? previousSnapshots.get(member.id) : null;

                    const card = document.createElement('div');
                    card.className = 'party-card';
                    if (member?.id) {
                        card.dataset.npcId = member.id;
                    }

                    const portrait = document.createElement('div');
                    portrait.className = 'party-portrait';

                    const portraitImage = document.createElement('div');
                    portraitImage.className = 'party-portrait-image';
                    portrait.appendChild(portraitImage);

                    const { bar: portraitHealthBar, fill: portraitHealthFill } = createHealthBar('npc-health-bar');
                    portraitHealthFill.classList.add('npc-health-bar-fill');
                    portrait.appendChild(portraitHealthBar);

                    const portraitNeedBars = document.createElement('div');
                    portraitNeedBars.className = 'npc-need-bars need-bars';
                    portrait.appendChild(portraitNeedBars);

                    renderEntityImage({
                        element: portraitImage,
                        entityType: member.isNPC ? 'npc' : 'player',
                        entityId: member.id,
                        imageId: member.imageId || null,
                        altText: member.name || 'Party member portrait',
                        placeholderIcon: 'üé≠',
                        placeholderClass: 'party-portrait-placeholder'
                    });

                    if (portraitHealthBar) {
                        if (member?.name) {
                            portraitHealthBar.setAttribute('aria-label', `${member.name} health`);
                        } else {
                            portraitHealthBar.removeAttribute('aria-label');
                        }
                    }

                    updateHealthBar(portraitHealthBar, portraitHealthFill, member?.health, member?.maxHealth);

                    renderNeedBars(
                        portraitNeedBars,
                        Array.isArray(member?.needBars) ? member.needBars : [],
                        {
                            includePlayerOnly: false,
                            variant: 'npc'
                        }
                    );

                    applyNpcDeathStyling(card, portrait, member);

                    const name = document.createElement('div');
                    name.className = 'party-name';
                    name.textContent = member.name || 'Unknown';

                    const role = document.createElement('div');
                    role.className = 'party-role';
                    const parts = [];
                    if (member.class) parts.push(member.class);
                    if (member.race) parts.push(member.race);
                    role.textContent = parts.join(' ¬∑ ') || 'Companion';

                    const meta = document.createElement('div');
                    meta.className = 'party-meta';
                    const levelText = typeof member.level === 'number' ? `Level ${member.level}` : 'Level ?';
                    meta.textContent = `${levelText}${member.isNPC ? ' ¬∑ NPC' : ''}`;

                    const stats = document.createElement('div');
                    stats.className = 'party-stats';
                    const attrs = member.attributes || {};
                    statOrder.forEach(key => {
                        const value = attrs[key] !== undefined ? attrs[key] : '‚Äî';
                        const stat = document.createElement('div');
                        stat.className = 'party-stat';
                        stat.innerHTML = `<span>${statLabels[key]}</span><strong>${value}</strong>`;
                        stats.appendChild(stat);
                    });

                    const description = member.description || member.shortDescription || 'No description provided.';

                    card.addEventListener('mouseenter', (event) => {
                        if (!floatingTooltip || !description) return;
                        floatingTooltip.textContent = description;
                        floatingTooltip.removeAttribute('hidden');
                        floatingTooltip.classList.add('visible');
                        positionTooltip(event);
                    });

                    card.addEventListener('mousemove', (event) => {
                        if (!floatingTooltip || floatingTooltip.hasAttribute('hidden')) return;
                        positionTooltip(event);
                    });

                    card.addEventListener('mouseleave', () => {
                        hideTooltip();
                    });

                    card.appendChild(portrait);
                    card.appendChild(name);
                    card.appendChild(role);
                    card.appendChild(meta);
                    card.appendChild(stats);

                    partyGrid.appendChild(card);

                    if (member && member.id) {
                        if (typeof registerNpcContextMenu === 'function') {
                            registerNpcContextMenu(card, member);
                        }
                        triggerHealthChangeEffect(portrait, previous, member);
                        npcDataCache.set(member.id, cloneActorRecord(member) || { ...member });
                    }
                });
            }

            window.updatePartyDisplay = renderParty;

            async function refreshParty() {
                try {
                    const response = await fetch('/api/player/party');
                    const data = await response.json();
                    if (data.success && Array.isArray(data.members)) {
                        renderParty(data.members);
                    } else {
                        renderParty([]);
                    }
                } catch (error) {
                    console.warn('Failed to refresh party members:', error);
                    renderParty([]);
                }
            }

            window.refreshParty = refreshParty;
            refreshParty();

            if (partyPanel) {
                partyPanel.addEventListener('scroll', hideTooltip);
            }
            window.addEventListener('scroll', hideTooltip, { passive: true });
        }

        async function loadCurrentLocation() {
            console.log('Loading current player location...');
            try {
                const response = await fetch('/api/player', { cache: 'no-store' });
                const result = await response.json();
                
                if (result.success && result.player) {
                    updateChatPlayerPanel(result.player);
                    if (Array.isArray(result.player.partyMembers)) {
                        renderChatPartyPanel(result.player.partyMembers);
                    }
                }

                const locationId = result.player?.locationId || result.player?.currentLocation || null;
                if (result.success && result.player && locationId) {
                    // Fetch location details
                    console.log("Fetching location details for ID:", locationId);
                    const cacheBuster = Date.now();
                    const locationResponse = await fetch(`/api/locations/${locationId}?_=${cacheBuster}`, {
                        cache: 'no-store'
                    });
                    const locationResult = await locationResponse.json();
                    
                    console.log("Current location data:", locationResult.location);

                    if (locationResult.success && locationResult.location) {
                        console.log("Updating location display");
                        await window.updateLocationDisplay(locationResult.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    }
                }
            } catch (error) {
                console.log('Could not load current location:', error);
                hideLocationOverlay();
            }
        }

        window.loadCurrentLocation = loadCurrentLocation;

        function initSaveLoadButtons() {
            const saveGameBtn = document.getElementById('saveGameBtn');
            const loadGameBtn = document.getElementById('loadGameBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            
            saveGameBtn.addEventListener('click', async function() {
                try {
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Saving...';
                    
                    const response = await fetch('/api/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> Saved!';
                        alert(`Game saved successfully!\n\nSave: ${result.saveName}`);
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Save Failed';
                        alert(`Save failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Save Failed';
                    alert(`Save failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üíæ</span> Save Game';
                    }, 2000);
                }
            });

            loadGameBtn.addEventListener('click', async function() {
                this.disabled = true;
                this.innerHTML = '<span>‚è≥</span> Loading...';
                loadGameTriggerButton = this;
                try {
                    openLoadGameModal({ initialSource: 'saves' });
                    await refreshLoadGameList('saves');
                } catch (error) {
                    setLoadGameStatus(`Failed to load ${getLoadGameSourceLabel({ source: 'saves', plural: true })}: ${error.message}`, 'error');
                } finally {
                    this.disabled = false;
                    this.innerHTML = '<span>üìÇ</span> Load Game';
                }
            });

            if (newGameBtn) {
            newGameBtn.addEventListener('click', async function() {
                try {
                    const confirmation = confirm('Start a new game? This will clear your current progress.\n\nYou can optionally enter a custom player name and description.');
                    if (!confirmation) return;
                    
                    // Get optional player details
                    const playerName = prompt('Enter your character name (or leave blank for "Adventurer"):') || 'Adventurer';
                    const playerDescription = prompt('Enter your character description (optional):') || 'A brave soul embarking on a new adventure.';
                    
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Creating...';
                    
                    const response = await fetch('/api/new-game', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            playerName: playerName,
                            playerDescription: playerDescription
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> New Game Started!';
                        alert(`New game created successfully!\n\nPlayer: ${result.player.name}\nStarting Location: ${result.startingLocation.name}\n\nYour adventure begins now!`);
                        window.location.reload();
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Failed';
                        alert(`New game creation failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Failed';
                    alert(`New game creation failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üÜï</span> New Game';
                    }, 2000);
                }
            });
            }
        }
    </script>
</body>
</html>
