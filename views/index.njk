<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title | default("AI RPG Chat") }}</title>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/map.css">
    {% if modStyles %}{% for mod in modStyles %}{% for style in mod.styles %}
    <link rel="stylesheet" href="{{ style }}">
    {% endfor %}{% endfor %}{% endif %}
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI RPG Chat Interface ü§ñ</h1>
            {% include "_navigation.njk" %}
        </div>
        
        <div class="main-content">
            <div class="tab-bar" role="tablist">
                <button class="tab-button active" id="tab-adventure-tab" data-tab="adventure" role="tab" aria-selected="true" aria-controls="tab-adventure">Adventure</button>
                <button class="tab-button" id="tab-map-tab" data-tab="map" role="tab" aria-selected="false" aria-controls="tab-map">Map</button>
                <button class="tab-button" id="tab-world-map-tab" data-tab="world-map" role="tab" aria-selected="false" aria-controls="tab-world-map">World Map</button>
                <button class="tab-button" id="tab-character-tab" data-tab="character" role="tab" aria-selected="false" aria-controls="tab-character">Character</button>
                <button class="tab-button" id="tab-quests-tab" data-tab="quests" role="tab" aria-selected="false" aria-controls="tab-quests">Quests</button>
                <button class="tab-button" id="tab-factions-tab" data-tab="factions" role="tab" aria-selected="false" aria-controls="tab-factions">Factions</button>
                <button class="tab-button" id="tab-party-tab" data-tab="party" role="tab" aria-selected="false" aria-controls="tab-party">Party</button>
            </div>

            <div class="tab-panels">
                <section class="tab-panel active" id="tab-adventure" role="tabpanel" aria-labelledby="tab-adventure-tab">
                    <div class="adventure-background" id="adventureBackground" aria-hidden="true"></div>
                    <div class="adventure-content">
                        <div class="location-block">
                            <div class="container">
                                <div class="location-header">
                                    <h4>üìç <span class="location-name" id="locationName">Unknown Location</span></h4>
                                </div>
                                <div class="location-content" id="locationContent">
                                    <div class="location-image-wrapper" id="locationImageWrapper">
                                        <div class="location-image" id="locationImage">
                                            <div class="location-placeholder">
                                                <!-- Nothing in here on initial load -->
                                            </div>
                                            <div class="location-tooltip" id="locationTooltip">Your current location will appear here when you start exploring.</div>
                                        </div>
                                        <button type="button" class="location-image-menu-button" id="locationImageMenuButton" aria-haspopup="true" aria-expanded="false" aria-label="Location options">‚Ä¢‚Ä¢‚Ä¢</button>
                                        <div class="location-image-menu" id="locationImageMenu" hidden>
                                            <button type="button" class="location-image-menu-item" id="locationImageEditButton">Edit Location</button>
                                            <button type="button" class="location-image-menu-item" id="locationRegionEditButton">Edit Region</button>
                                            <button type="button" class="location-image-menu-item" id="locationSummonNpcButton">Summon NPC</button>
                                            <button type="button" class="location-image-menu-item" id="locationSummonThingButton">Summon Item/Scenery</button>
                                            <button type="button" class="location-image-menu-item" id="locationImageRegenerateButton">Regenerate Image</button>
                                        </div>
                                    </div>
                                    <div class="location-info" id="locationInfo">
                                        <div class="location-details" id="locationDetails">
                                            <span class="location-level" id="locationLevel">Level: ?</span>
                                        </div>
                                        <div class="location-hint" id="locationHint">Hover over the location image for a description.</div>
                                        <details class="location-section location-exits" open>
                                            <summary>Exits</summary>
                                            <div class="location-exits-content" id="locationExits">
                                                <div class="location-exits-list" id="locationExitsList">
                                                    <div class="no-exits">No exits discovered yet.</div>
                                                </div>
                                            <button type="button" class="location-exit-add-button" id="newExitButton" disabled>üö™ New Exit</button>
                                        </div>
                                    </details>
                                    <details class="location-section location-npcs" open>
                                        <summary>NPCs</summary>
                                        <div class="location-npc-content">
                                            <div class="location-entity-grid" id="locationNPCs">
                                                <div class="location-npc-empty">No notable NPCs present.</div>
                                            </div>
                                            <button type="button" class="location-npc-add-button" id="addNpcButton" disabled>üë§ Add NPC</button>
                                        </div>
                                    </details>
                                        <details class="location-section location-things" open>
                                            <summary>Items &amp; Scenery</summary>
                                            <div class="location-thing-content">
                                                <div class="location-thing-category">
                                                    <h5 class="location-thing-heading">Scenery</h5>
                                                    <div class="location-entity-grid" id="locationScenery">
                                                        <div class="location-thing-empty">No notable scenery present.</div>
                                                    </div>
                                                    <button type="button" class="location-npc-add-button location-thing-add-button" id="craftSceneryButton" disabled>üî® Craft Scenery</button>
                                                </div>
                                                <div class="location-thing-category">
                                                    <h5 class="location-thing-heading">Items</h5>
                                                    <div class="location-entity-grid" id="locationItems">
                                                        <div class="location-thing-empty">No notable items present.</div>
                                                    </div>
                                                    <button type="button" class="location-npc-add-button location-thing-add-button" id="craftItemButton" disabled>üõ†Ô∏è Craft Item</button>
                                                </div>
                                                <button type="button" class="location-npc-add-button location-thing-add-button" id="addThingButton" disabled>‚ú® New Item/Scenery</button>
                                            </div>
                                        </details>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="chat-wrapper">
                            <div class="chat-container">
                                <div class="chat-log" id="chatLog">
                                    {% if chatHistory and chatHistory.length > 0 %}
                                        {% for message in chatHistory %}
                                            {% if message.type == 'event-summary' %}
                                                {% set summaryTitle = message.summaryTitle or (message.content.split('\n')[0]) %}
                                                {% set summaryItems = message.summaryItems or [] %}
                                                <div class="message event-summary-batch">
                                                    <div class="message-sender">{{ summaryTitle }}</div>
                                                    <div>
                                                        <ul class="event-summary-list">
                                                            {% if summaryItems | length %}
                                                                {% for item in summaryItems %}
                                                                    {% if item.text %}
                                                                        <li>
                                                                            <span class="event-summary-icon">{{ item.icon or '‚Ä¢' }}</span>
                                                                            {{ item.text }}
                                                                        </li>
                                                                    {% endif %}
                                                                {% endfor %}
                                                            {% else %}
                                                                {% set lines = message.content.split('\n') %}
                                                                {% for line in lines %}
                                                                    {% if not loop.first %}
                                                                        {% set trimmed = line | trim %}
                                                                        {% if trimmed %}
                                                                            <li>{{ trimmed }}</li>
                                                                        {% endif %}
                                                                    {% endif %}
                                                                {% endfor %}
                                                            {% endif %}
                                                        </ul>
                                                    </div>
                                                    <div class="message-timestamp">{{ (message.timestamp or '') | replace('T', ' ') | replace('Z', '') }}</div>
                                                </div>
                                            {% else %}
                                                <div class="message {{ 'user-message' if message.role == 'user' else 'ai-message' }}">
                                                    <div class="message-sender">
                                                        {% if message.role == 'user' %}
                                                            üë§ You
                                                        {% else %}
                                                            ü§ñ AI Game Master
                                                        {% endif %}
                                                    </div>
                                                    <div>{{ message.content }}</div>
                                                    <div class="message-timestamp">{{ message.timestamp | replace('T', ' ') | replace('Z', '') }}</div>
                                                </div>
                                            {% endif %}
                                        {% endfor %}
                                    {% else %}
                                        <div class="message ai-message">
                                            <div class="message-sender">ü§ñ AI Game Master</div>
                                            <div>Welcome to the AI RPG! I'm your Game Master. Configure your AI settings above and then click the <strong>New Game</strong> link in the upper right.</div>
                                        </div>
                                    {% endif %}
                                </div>

                                <div class="input-area">
                                    <textarea class="message-input" id="messageInput" placeholder="Type your message here..." rows="2"></textarea>
                                    <button class="send-button" id="sendButton">Send</button>
                                </div>
                            </div>

                            <aside class="chat-sidebar" aria-label="Player and party overview">
                                <section class="chat-player-section">
                                    <h3 class="chat-sidebar-heading" id="chatPlayerName">Player</h3>
                                    <div class="chat-player-card" id="chatPlayerCard">
                                        <div class="chat-player-portrait" id="chatPlayerPortrait">
                                            <div class="chat-player-points-indicator" id="chatPlayerPointsIndicator" hidden aria-hidden="true">
                                                <span class="chat-player-points-indicator-mark" aria-hidden="true">!</span>
                                            </div>
                                            <div class="chat-player-portrait-image" id="chatPlayerPortraitImage">
                                                <div class="chat-player-placeholder" aria-hidden="true">üßô</div>
                                            </div>
                                            <div class="health-bar chat-health-bar" id="chatPlayerHealthBar" aria-hidden="true">
                                                <div class="health-bar-fill chat-health-bar-fill" id="chatPlayerHealthBarFill"></div>
                                            </div>
                                        </div>
                                        <div class="player-need-bars need-bars" id="chatPlayerNeedBars" hidden></div>
                                        <div class="chat-player-actions" id="chatPlayerActions">
                                            <button type="button" class="chat-player-action-button" id="chatPlayerViewButton" disabled>
                                                <span class="chat-player-action-icon" aria-hidden="true">üëÅÔ∏è</span>
                                                <span class="chat-player-action-label">View</span>
                                            </button>
                                            <button type="button" class="chat-player-action-button" id="chatPlayerInventoryButton" disabled>
                                                <span class="chat-player-action-icon" aria-hidden="true">üéí</span>
                                                <span class="chat-player-action-label">Inventory</span>
                                            </button>
                                        </div>
                                        <div class="chat-player-details">
                                            <div class="chat-player-meta">
                                                <span class="chat-player-level" id="chatPlayerLevel">Level ?</span>
                                                <span class="chat-player-archetype" id="chatPlayerArchetype">Class ¬∑ Race</span>
                                            </div>
                                            <div class="chat-player-health" id="chatPlayerHealth">HP: ? / ?</div>
                                            <div class="chat-player-health" id="chatPlayerExperience">Exp: ? / 100</div>
                                            <div class="chat-player-health" id="chatPlayerCurrency">Coins: ?</div>
                                            <p class="chat-player-description" id="chatPlayerDescription">No description available.</p>
                                        </div>
                                    </div>
                                </section>

                                <section class="chat-party-section">
                                    <div class="chat-party-header">
                                        <h3 class="chat-sidebar-heading">Party</h3>
                                        <span class="chat-party-count" id="chatPartyCount">0</span>
                                    </div>
                                    <div class="chat-party-empty" id="chatPartyEmpty">No companions are currently travelling with you.</div>
                                    <div class="location-entity-grid chat-party-grid" id="chatPartyMembers"></div>
                                </section>
                            </aside>
                        </div>
                    </div>
                </section>

                <section class="tab-panel" id="tab-map" role="tabpanel" aria-labelledby="tab-map-tab" hidden>
                    <div class="map-panel">
                        <div class="map-header">
                            <h2 id="mapTitle" class="map-title">Region Map</h2>
                        </div>
                        <div id="mapContainer" class="map-placeholder" aria-live="polite"></div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-world-map" role="tabpanel" aria-labelledby="tab-world-map-tab" hidden>
                    <div class="map-panel world-map-panel">
                        <div class="map-header">
                            <h2 id="worldMapTitle" class="map-title">World Map</h2>
                            <button type="button"
                                    class="map-action-button"
                                    id="worldMapReloadButton"
                                    aria-label="Reload world map">
                                Reload
                            </button>
                        </div>
                        <div id="worldMapContainer" class="map-placeholder" aria-live="polite"></div>
                    </div>
                </section>
                <div class="map-location-context-menu location-image-menu" id="mapLocationContextMenu" hidden>
                    <button type="button" class="location-image-menu-item" id="mapLocationMenuEditButton">Edit Location</button>
                    <button type="button" class="location-image-menu-item" id="mapLocationMenuRegionButton">Edit Region</button>
                    <button type="button" class="location-image-menu-item" id="mapLocationMenuSummonNpcButton">Summon NPC</button>
                    <button type="button" class="location-image-menu-item" id="mapLocationMenuSummonThingButton">Summon Item/Scenery</button>
                    <button type="button" class="location-image-menu-item" id="mapLocationMenuRegenerateImageButton">Regenerate Image</button>
                </div>
                <section class="tab-panel" id="tab-character" role="tabpanel" aria-labelledby="tab-character-tab" hidden>
                    <div class="config-content character-panel">
                        <div class="config-section">
                            <h2>Basic Information</h2>
                            <form id="player-stats-form" class="player-stats-form">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label for="player-name">Character Name</label>
                                        <input type="text"
                                               id="player-name"
                                               name="name"
                                               value="{{ player.name if player else '' }}"
                                               placeholder="Enter character name"
                                               required>
                                        <span class="help-text">Your character's name as it appears in the game</span>
                                    </div>

                                    <div class="form-group">
                                        <label for="player-level">Level</label>
                                        <input type="number"
                                               id="player-level"
                                               name="level"
                                               value="{{ player.level if player else 1 }}"
                                               min="1"
                                               required>
                                        <span class="help-text">Character level (1-20)</span>
                                    </div>

                                    <div class="form-group full-width">
                                        <label for="player-description">Description</label>
                                        <textarea id="player-description"
                                                  name="description"
                                                  rows="3"
                                                  placeholder="Describe your character's appearance, personality, and background">{{ player.description if player else '' }}</textarea>
                                        <span class="help-text">A detailed description of your character</span>
                                    </div>
                                </div>
                            </form>
                        </div>

                        <div class="config-section">
                            <h2>Health &amp; Vitality</h2>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label for="player-health">Current Health</label>
                                    <input type="number"
                                           id="player-health"
                                           name="health"
                                           value="{{ player.health if player else 25 }}"
                                           min="0"
                                           max="999"
                                           form="player-stats-form">
                                    <span class="help-text">Current hit points</span>
                                </div>

                                <div class="form-group">
                                    <label>Maximum Health</label>
                                    <div id="player-max-health-display" class="form-static-value">{{ player.maxHealth if player else 'Automatically calculated' }}</div>
                                    <span class="help-text">Calculated automatically from level and health attribute.</span>
                                </div>
                            </div>
                        </div>

                        <div class="config-section">
                            <div class="npc-edit-section-header">
                                <h2>Status Effects</h2>
                                <button type="button" class="npc-edit-add-btn" id="playerStatusEffectAddBtn">Add Effect</button>
                            </div>
                            <div id="playerStatusEffectsList" class="thing-edit-status-effects"></div>
                        </div>

                        <div class="config-section">
                            <h2>Primary Attributes</h2>
                            <div class="attributes-grid">
                                {% set attributes = player.attributeInfo if player else {} %}
                                {% set defaultAttributes = [
                                    { key: 'strength', label: 'Strength', abbr: 'STR', description: 'Physical power and muscle' },
                                    { key: 'dexterity', label: 'Dexterity', abbr: 'DEX', description: 'Agility and reflexes' },
                                    { key: 'constitution', label: 'Constitution', abbr: 'CON', description: 'Health and stamina' },
                                    { key: 'intelligence', label: 'Intelligence', abbr: 'INT', description: 'Mental acuity and reasoning' },
                                    { key: 'wisdom', label: 'Wisdom', abbr: 'WIS', description: 'Insight and perception' },
                                    { key: 'charisma', label: 'Charisma', abbr: 'CHA', description: 'Charm and influence' }
                                ] %}

                                {% for attr in defaultAttributes %}
                                <div class="attribute-group">
                                    <div class="attribute-header">
                                        <label for="attr-{{ attr.key }}">{{ attr.label }}</label>
                                        <span class="attribute-abbr">{{ attr.abbr }}</span>
                                    </div>
                                    <div class="attribute-input-group">
                                        <input type="number"
                                               id="attr-{{ attr.key }}"
                                               name="attributes.{{ attr.key }}"
                                               value="{{ attributes[attr.key].value if attributes[attr.key] else 10 }}"
                                               min="3"
                                               max="18"
                                               form="player-stats-form"
                                               class="attribute-input">
                                        <span class="attribute-modifier" data-attr="{{ attr.key }}">
                                            +{{ ((attributes[attr.key].value if attributes[attr.key] else 10) - 10) // 2 }}
                                        </span>
                                    </div>
                                    <span class="help-text">{{ attr.description }}</span>
                                </div>
                                {% endfor %}
                        </div>
                    </div>

                        {% if availableSkills and availableSkills|length %}
                        <div class="config-section">
                            <h2>Skills</h2>
                            <div class="skill-pool-display">
                                <span class="status-label">Unspent Skill Points:</span>
                                <span class="status-value" id="unspentSkillPointsDisplay">{{ player.unspentSkillPoints if player else 0 }}</span>
                            </div>
                            <div class="skills-grid readonly">
                                {% set sortedSkills = availableSkills | sort(false, false, 'name') %}
                                {% for skill in sortedSkills %}
                                {% set skillValue = player.skills[skill.name] if player and player.skills and skill.name in player.skills else 1 %}
                                <div class="skill-card readonly">
                                    <div class="skill-header">
                                        <span class="skill-name">{{ skill.name }}</span>
                                        {% if skill.attribute %}<span class="skill-attribute">{{ skill.attribute }}</span>{% endif %}
                                    </div>
                                    <div class="skill-value">
                                        Rank: <span class="skill-rank" data-skill-name="{{ skill.name }}">{{ skillValue }}</span>
                                        {% if player %}
                                        <button type="button"
                                                class="btn btn-secondary small skill-increase-btn"
                                                data-skill-name="{{ skill.name }}"
                                                aria-label="Increase {{ skill.name }}">
                                            ‚ûï
                                        </button>
                                        {% endif %}
                                    </div>
                                    {% if skill.description %}
                                    <div class="skill-description">{{ skill.description }}</div>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}

                        <div class="config-section" id="abilitiesSection">
                            <h2>Abilities</h2>
                            <div class="abilities-grid" id="abilitiesList">
                                {% if player and player.abilities %}
                                    {% for ability in player.abilities %}
                                        <div class="ability-card ability-type-{{ ability.type | default('Passive') | lower }}">
                                            <div class="ability-header">
                                                <span class="ability-name">{{ ability.name }}</span>
                                                <span class="ability-meta">{{ ability.type | default('Passive') }}{% if ability.level %} ‚Ä¢ Level {{ ability.level }}{% endif %}</span>
                                            </div>
                                            {% if ability.description %}
                                            <div class="ability-description">{{ ability.description }}</div>
                                            {% endif %}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                            <div class="abilities-empty" id="abilitiesEmpty" {% if player and player.abilities and player.abilities|length %}hidden{% endif %}>
                                No special abilities unlocked yet.
                            </div>
                        </div>

                        {% if player %}
                        <div class="config-section">
                            <h2>Current Status</h2>
                            <div class="status-display">
                                <div class="status-item">
                                    <span class="status-label">Alive:</span>
                                    <span class="status-value {{ 'alive' if player.alive else 'dead' }}">
                                        {{ 'Yes' if player.alive else 'No' }}
                                    </span>
                                </div>
                                {% set playerLocationId = player.locationId or player.currentLocation %}
                                {% if playerLocationId %}
                                <div class="status-item">
                                    <span class="status-label">Location:</span>
                                    <span class="status-value">{{ playerLocationId }}</span>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                        {% endif %}

                        <div class="form-actions">
                            <button type="submit" form="player-stats-form" class="btn btn-primary">
                                <span>üíæ</span> Save Character
                            </button>
                            {% if player %}
                            <button type="button" id="reset-stats" class="btn btn-secondary">
                                <span>üîÑ</span> Reset to Defaults
                            </button>
                            {% endif %}
                        </div>

                        <div id="status-message" class="status-message" style="display: none;"></div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-quests" role="tabpanel" aria-labelledby="tab-quests-tab" hidden>
                    <div class="quest-panel">
                        <div class="quest-panel-header">
                            <div>
                                <h2>Active Quests</h2>
                                <p class="quest-panel-subtitle">Track your current objectives and rewards at a glance.</p>
                            </div>
                            <span class="quest-count-badge" id="questActiveCount">0</span>
                        </div>
                        <div class="quest-accordion" id="questAccordion" role="list"></div>
                        <div class="quest-empty" id="questEmpty">No active quests yet. Venture forth to discover new adventures!</div>
                        <div class="quest-divider" aria-hidden="true"></div>
                        <div class="quest-completed">
                            <div class="quest-completed-header">
                                <h3>Completed Quests</h3>
                                <span class="quest-count-compact" id="questCompletedCount">0</span>
                            </div>
                            <div class="quest-accordion quest-accordion--compact" id="questCompletedAccordion" role="list"></div>
                            <div class="quest-empty quest-empty--secondary" id="questCompletedEmpty">You have not completed any quests yet.</div>
                        </div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-factions" role="tabpanel" aria-labelledby="tab-factions-tab" hidden>
                    <div class="factions-panel">
                        <aside class="factions-sidebar">
                            <div class="factions-sidebar-header">
                                <div>
                                    <h2>Factions</h2>
                                    <p class="factions-subtitle">View, edit, and organize faction dynamics.</p>
                                </div>
                                <button type="button" class="btn btn-primary" id="factionAddButton">+ New</button>
                            </div>
                            <div class="faction-list" id="factionList"></div>
                            <div class="faction-empty" id="factionEmpty">No factions created yet.</div>
                        </aside>
                        <section class="faction-detail">
                            <div class="faction-detail-placeholder" id="factionDetailPlaceholder">Select a faction to view or edit.</div>
                            <form id="factionForm" class="faction-form" hidden>
                                <div class="faction-detail-header">
                                    <div>
                                        <h2 id="factionDetailTitle">Faction</h2>
                                        <div class="faction-detail-meta" id="factionDetailMeta"></div>
                                    </div>
                                    <div class="faction-detail-actions">
                                        <button type="button" class="btn btn-secondary" id="factionDeleteButton">Delete</button>
                                        <button type="submit" class="btn btn-primary" id="factionSaveButton">Save Changes</button>
                                    </div>
                                </div>

                                <div class="config-section">
                                    <h2>Basics</h2>
                                    <div class="form-grid">
                                        <div class="form-group">
                                            <label for="factionName">Name</label>
                                            <input type="text" id="factionName" name="name" required>
                                            <span class="help-text">Unique name used across the world.</span>
                                        </div>
                                        <div class="form-group">
                                            <label for="factionHomeRegion">Home Region</label>
                                            <input type="text" id="factionHomeRegion" name="homeRegionName">
                                            <span class="help-text">Optional region name or theme anchor.</span>
                                        </div>
                                        <div class="form-group full-width">
                                            <label for="factionShortDescription">Short Description</label>
                                            <textarea id="factionShortDescription" name="shortDescription" rows="2" placeholder="One-sentence summary."></textarea>
                                            <span class="help-text">Quick summary used in overviews.</span>
                                        </div>
                                        <div class="form-group full-width">
                                            <label for="factionDescription">Description</label>
                                            <textarea id="factionDescription" name="description" rows="4" placeholder="Longer faction overview."></textarea>
                                            <span class="help-text">Full description, goals, and context.</span>
                                        </div>
                                        <div class="form-group full-width">
                                            <label for="factionTags">Tags</label>
                                            <textarea id="factionTags" name="tags" rows="2" placeholder="ideology, archetype, focus"></textarea>
                                            <span class="help-text">Separate with commas or new lines.</span>
                                        </div>
                                        <div class="form-group full-width">
                                            <label for="factionGoals">Goals</label>
                                            <textarea id="factionGoals" name="goals" rows="3" placeholder="Primary goals and ambitions."></textarea>
                                            <span class="help-text">Separate with commas or new lines.</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="config-section">
                                    <div class="faction-section-header">
                                        <h2>Assets</h2>
                                        <button type="button" class="btn btn-secondary small" id="factionAssetAddButton">Add Asset</button>
                                    </div>
                                    <div class="faction-assets" id="factionAssetsList"></div>
                                </div>

                                <div class="config-section">
                                    <h2>Player Standing</h2>
                                    <div class="form-grid">
                                        <div class="form-group">
                                            <label for="factionStandingValue">Standing Value</label>
                                            <input type="number" id="factionStandingValue" name="standing" step="1" placeholder="0">
                                            <span class="help-text">Leave blank to remove standing entry.</span>
                                        </div>
                                        <div class="form-group">
                                            <label for="factionStandingTier">Resolved Tier</label>
                                            <div id="factionStandingTier" class="form-static-value">‚Äî</div>
                                            <span class="help-text">Computed from reputation tiers.</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="config-section">
                                    <h2>Relations</h2>
                                    <div class="faction-relations" id="factionRelationsList"></div>
                                </div>

                                <div class="config-section">
                                    <div class="faction-section-header">
                                        <h2>Reputation Tiers</h2>
                                        <button type="button" class="btn btn-secondary small" id="factionTierAddButton">Add Tier</button>
                                    </div>
                                    <div class="faction-tiers" id="factionTiersList"></div>
                                </div>
                            </form>
                        </section>
                    </div>
                </section>
                <section class="tab-panel" id="tab-party" role="tabpanel" aria-labelledby="tab-party-tab" hidden>
                    <div class="party-panel">
                        <div class="party-header">
                            <h2>Party Members</h2>
                            <span class="party-count" id="partyCount">0 members</span>
                        </div>
                        <div class="party-grid" id="partyMembers"></div>
                        <div class="party-empty" id="partyEmpty">No companions are currently travelling with you.</div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <div id="locationOverlay" class="overlay-backdrop" aria-live="polite" aria-busy="false" aria-label="Loading location">
        <div class="overlay-content">
            <div class="spinner" role="status" aria-hidden="true"></div>
            <div class="overlay-text" id="locationOverlayText">Exploring...</div>
        </div>
    </div>

    <div id="npcModalBackdrop" class="modal-backdrop" hidden></div>
    <div id="questEditBackdrop" class="modal-backdrop" hidden></div>
    <div id="questEditModal" class="modal quest-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="questEditTitle">Edit Quest</h2>
                <button type="button" class="modal__close" id="questEditCloseBtn" aria-label="Close quest editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body">
                <form id="questEditForm" class="quest-edit-form">
                    <div class="form-group">
                        <label for="questEditName">Name</label>
                        <input type="text" id="questEditName" name="name" required>
                    </div>
                    <div class="form-group">
                        <label for="questEditDescription">Description</label>
                        <textarea id="questEditDescription" name="description" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="questEditSecretNotes">Secret Notes</label>
                        <textarea id="questEditSecretNotes" name="secretNotes" rows="2"></textarea>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="questEditRewardCurrency">Reward Currency</label>
                            <input type="number" id="questEditRewardCurrency" name="rewardCurrency" min="0" step="1">
                        </div>
                        <div class="form-group">
                            <label for="questEditRewardXp">Reward XP</label>
                            <input type="number" id="questEditRewardXp" name="rewardXp" min="0" step="1">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="questEditRewardItems">Reward Items (comma or newline separated)</label>
                        <textarea id="questEditRewardItems" name="rewardItems" rows="2"></textarea>
                    </div>
                    <div class="form-group">
                        <div class="quest-edit-objective-header">
                            <label>Objectives</label>
                            <button type="button" id="questEditAddObjective" class="btn btn-secondary btn-sm">Add Objective</button>
                        </div>
                        <div id="questEditObjectives" class="quest-edit-objectives"></div>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">Save Quest</button>
                        <button type="button" id="questEditCancel" class="btn btn-secondary">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <div id="npcInventoryModal" class="modal npc-inventory-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcInventoryModalTitle">Character Inventory</h2>
                <button type="button" class="modal__close" id="npcInventoryCloseBtn" aria-label="Close NPC inventory">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-inventory-body">
                <div class="npc-inventory-header">
                    <h3 id="npcInventoryName">Character</h3>
                    <span class="inventory-count" id="npcInventoryCount">0 items</span>
                </div>
                <div class="npc-inventory-filters">
                    <div class="npc-inventory-filter-top-row">
                        <div class="npc-selection-filter npc-inventory-filter-input-wrapper">
                            <label class="sr-only" for="npcInventoryFilterInput">Filter items</label>
                            <input type="search" id="npcInventoryFilterInput" class="npc-selection-filter-input" placeholder="Filter items" aria-label="Filter items">
                        </div>
                        <div class="npc-inventory-filter-slot-wrapper">
                            <label class="sr-only" for="npcInventorySlotFilter">Filter by slot</label>
                            <select id="npcInventorySlotFilter" class="npc-inventory-slot-filter" aria-label="Filter by slot">
                                <option value="">All slots</option>
                            </select>
                        </div>
                    </div>
                    <div class="npc-inventory-filter-radios">
                        <label class="npc-inventory-filter-radio" for="npcInventoryShowAll">
                            <input type="radio" id="npcInventoryShowAll" name="npcInventoryItemFilter" value="all" checked>
                            <span>Show all</span>
                        </label>
                        <label class="npc-inventory-filter-radio" for="npcInventoryEquippedOnly">
                            <input type="radio" id="npcInventoryEquippedOnly" name="npcInventoryItemFilter" value="equipped">
                            <span>Equipped only</span>
                        </label>
                        <label class="npc-inventory-filter-radio" for="npcInventoryEquippableOnly">
                            <input type="radio" id="npcInventoryEquippableOnly" name="npcInventoryItemFilter" value="equippable">
                            <span>Equippable only</span>
                        </label>
                        <label class="npc-inventory-filter-radio" for="npcInventoryNonEquippableOnly">
                            <input type="radio" id="npcInventoryNonEquippableOnly" name="npcInventoryItemFilter" value="non-equippable">
                            <span>Non-equippable only</span>
                        </label>
                    </div>
                </div>
                <div class="npc-inventory-scroll">
                    <div class="inventory-grid" id="npcInventoryGrid"></div>
                </div>
                <div class="inventory-empty" id="npcInventoryEmpty">Inventory is empty.</div>
            </div>
        </div>
    </div>
    <div id="npcViewModal" class="modal npc-view-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcViewModalTitle">Character Overview</h2>
                <button type="button" class="modal__close" id="npcViewCloseBtn" aria-label="Close character overview">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-view-body">
                <div class="npc-view-summary">
                    <div class="npc-view-image" id="npcViewImage"></div>
                    <div class="npc-view-summary-text">
                        <h3 id="npcViewName">Unknown Character</h3>
                        <p id="npcViewDescription" class="npc-view-description">No description available.</p>
                        <div class="npc-view-tags" id="npcViewTags">
                            <span class="npc-view-tag" id="npcViewClass"></span>
                            <span class="npc-view-tag" id="npcViewRace"></span>
                            <span class="npc-view-tag" id="npcViewLevel"></span>
                        </div>
                        <div class="npc-view-health" id="npcViewHealth"></div>
                        <div class="npc-view-meta" id="npcViewCurrency" hidden></div>
                        <div class="npc-view-meta" id="npcViewExperience" hidden></div>
                    </div>
                </div>
                <div class="npc-view-sections">
                    <section class="npc-view-section" id="npcViewAttributesSection">
                        <h4>Attributes</h4>
                        <dl class="npc-view-attributes" id="npcViewAttributes"></dl>
                        <div class="npc-view-empty" id="npcViewAttributesEmpty">No attribute data available.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewEquipmentSection">
                        <h4>Equipment</h4>
                        <dl class="npc-view-equipment" id="npcViewEquipment"></dl>
                        <div class="npc-view-empty" id="npcViewEquipmentEmpty">No equipment equipped.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewSkillsSection">
                        <h4>Skills</h4>
                        <div class="npc-view-skills" id="npcViewSkills"></div>
                        <div class="npc-view-empty" id="npcViewSkillsEmpty">No skill data available.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewAbilitiesSection">
                        <h4>Abilities</h4>
                        <ul class="npc-view-list" id="npcViewAbilities"></ul>
                        <div class="npc-view-empty" id="npcViewAbilitiesEmpty">No abilities listed.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewStatusSection">
                        <h4>Status Effects</h4>
                        <ul class="npc-view-list" id="npcViewStatuses"></ul>
                        <div class="npc-view-empty" id="npcViewStatusesEmpty">No active status effects.</div>
                    </section>
                </div>
                <details class="npc-view-dispositions" id="npcViewDispositions" hidden>
                    <summary>Dispositions</summary>
                    <div class="npc-view-disposition-list" id="npcViewDispositionsList"></div>
                </details>
            </div>
        </div>
    </div>
    <div id="npcDispositionModal" class="modal npc-disposition-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcDispositionModalTitle">Adjust Dispositions</h2>
                <button type="button" class="modal__close" id="npcDispositionCloseBtn" aria-label="Close disposition editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="npcDispositionForm" class="modal__body npc-disposition-body" novalidate>
                <div class="npc-disposition-summary" id="npcDispositionSummary"></div>
                <div class="npc-disposition-loading" id="npcDispositionLoading" hidden>Loading dispositions‚Ä¶</div>
                <div class="npc-disposition-list" id="npcDispositionList">
                    <div class="npc-disposition-empty" id="npcDispositionEmpty">No disposition data available.</div>
                </div>
                <footer class="npc-disposition-footer">
                    <div class="npc-disposition-status" id="npcDispositionStatus" role="status" aria-live="polite"></div>
                    <div class="npc-disposition-actions">
                        <button type="button" class="npc-disposition-cancel" id="npcDispositionCancelBtn">Cancel</button>
                        <button type="submit" class="npc-disposition-save-btn" id="npcDispositionSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>
    <div id="npcNeedsModal" class="modal npc-needs-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcNeedsModalTitle">Adjust Needs</h2>
                <button type="button" class="modal__close" id="npcNeedsCloseBtn" aria-label="Close needs editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="npcNeedsForm" class="modal__body npc-needs-body" novalidate>
                <div class="npc-needs-summary" id="npcNeedsSummary"></div>
                <div class="npc-needs-loading" id="npcNeedsLoading" hidden>Loading needs‚Ä¶</div>
                <div class="npc-needs-list" id="npcNeedsList">
                    <div class="npc-needs-empty" id="npcNeedsEmpty">No need bars available.</div>
                </div>
                <footer class="npc-needs-footer">
                    <div class="npc-needs-status" id="npcNeedsStatus" role="status" aria-live="polite"></div>
                    <div class="npc-needs-actions">
                        <button type="button" class="npc-needs-cancel" id="npcNeedsCancelBtn">Cancel</button>
                        <button type="submit" class="npc-needs-save-btn" id="npcNeedsSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>
    <div id="craftingModalBackdrop" class="modal-backdrop" hidden></div>
    <div id="craftingModal" class="modal crafting-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog crafting-modal__dialog">
            <header class="modal__header">
                <h2 id="craftingModalTitle">Crafting Station</h2>
                <button type="button" class="modal__close" id="craftingModalCloseBtn" aria-label="Close crafting interface">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body crafting-modal__body">
                <div class="crafting-modal__content">
                    <section class="crafting-modal__inventory">
                        <div class="crafting-modal__section-header">
                            <h3>Player Inventory</h3>
                            <p class="crafting-modal__hint" id="craftingModalHint">Drag items into the slots to craft.</p>
                        </div>
                        <div class="npc-selection-filter npc-inventory-filter-input-wrapper crafting-inventory-filter">
                            <label class="sr-only" for="craftingInventoryFilterInput">Filter items</label>
                            <input type="search" id="craftingInventoryFilterInput" class="npc-selection-filter-input" placeholder="Filter items" aria-label="Filter items for crafting or processing">
                        </div>
                        <div id="craftingInventoryGrid" class="crafting-modal__inventory-grid"></div>
                        <div id="craftingInventoryEmpty" class="crafting-modal__empty">Player inventory is not available.</div>
                    </section>
                    <section class="crafting-modal__workspace">
                        <div class="crafting-modal__section-header">
                            <h3 id="craftingWorkspaceTitle">Crafting Slots</h3>
                        </div>
                        <div id="craftingSlots" class="crafting-modal__slots"></div>
                    </section>
                </div>
                <div class="crafting-modal__notes">
                    <label for="craftingNotesInput" class="sr-only">Crafting notes</label>
                    <textarea id="craftingNotesInput" class="crafting-modal__notes-input" rows="2" placeholder="Optionally, describe what you are trying to craft."></textarea>
                </div>
            </div>
            <footer class="modal__footer crafting-modal__footer">
                <button type="button" class="button button-secondary" id="craftingCancelButton">Cancel</button>
                <button type="button" class="button button-primary" id="craftingActionButton" disabled>Craft Items</button>
            </footer>
        </div>
    </div>
    <div id="salvageIntentBackdrop" class="modal-backdrop" hidden></div>
    <div id="salvageIntentModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="salvageIntentTitle">Salvage Goal</h2>
                <button type="button" class="modal__close" id="salvageIntentCloseBtn" aria-label="Close salvage dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body">
                <p id="salvageIntentMessage" class="modal__instruction">Optionally describe what you hope to recover. Leave blank to continue.</p>
                <label for="salvageIntentInput" class="sr-only">Desired outcome</label>
                <textarea id="salvageIntentInput" class="crafting-modal__notes-input" rows="2" placeholder="Optionally describe what you hope to recover."></textarea>
            </div>
            <footer class="modal__footer">
                <button type="button" class="button button-secondary" id="salvageIntentCancelBtn">Cancel</button>
                <button type="button" class="button button-primary" id="salvageIntentSubmitBtn">Continue</button>
            </footer>
        </div>
    </div>
    <div id="npcMemoriesModal" class="modal npc-memories-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcMemoriesModalTitle">Edit Memories</h2>
                <button type="button" class="modal__close" id="npcMemoriesCloseBtn" aria-label="Close memories editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-memories-body">
                <p class="npc-memories-help">Update the character's important memories. Drag the handle to reorder entries.</p>
                <div id="npcMemoriesList" class="npc-memories-list" role="list"></div>
                <button type="button" class="npc-memories-add" id="npcMemoriesAddBtn">Add Memory</button>
            </div>
            <footer class="modal__footer npc-memories-footer">
                <div id="npcMemoriesStatus" class="npc-memories-status" role="status" aria-live="polite"></div>
                <div class="npc-memories-actions">
                    <button type="button" class="npc-memories-cancel" id="npcMemoriesCancelBtn">Cancel</button>
                    <button type="button" class="npc-memories-save" id="npcMemoriesSaveBtn">Save</button>
                </div>
            </footer>
        </div>
    </div>
    <div id="npcGoalsModal" class="modal npc-goals-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcGoalsModalTitle">Edit Goals</h2>
                <button type="button" class="modal__close" id="npcGoalsCloseBtn" aria-label="Close goals editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-goals-body">
                <p class="npc-goals-help">Update the character's active goals. Drag the handle to reorder entries.</p>
                <div id="npcGoalsList" class="npc-goals-list" role="list"></div>
                <button type="button" class="npc-goals-add" id="npcGoalsAddBtn">Add Goal</button>
            </div>
            <footer class="modal__footer npc-goals-footer">
                <div id="npcGoalsStatus" class="npc-goals-status" role="status" aria-live="polite"></div>
                <div class="npc-goals-actions">
                    <button type="button" class="npc-goals-cancel" id="npcGoalsCancelBtn">Cancel</button>
                    <button type="button" class="npc-goals-save" id="npcGoalsSaveBtn">Save</button>
                </div>
            </footer>
        </div>
    </div>
    <div id="addNpcModal" class="modal add-npc-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="addNpcModalTitle">Add NPC</h2>
                <button type="button" class="modal__close" id="addNpcCloseBtn" aria-label="Close new NPC dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="addNpcForm" class="modal__body npc-edit-form add-npc-body" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="addNpcName">Name</label>
                        <input type="text" id="addNpcName" name="name" maxlength="120" autocomplete="off">
                    </div>
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="addNpcShortDescription">Short Description</label>
                        <input type="text" id="addNpcShortDescription" name="shortDescription" maxlength="140" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcRole">Role</label>
                        <input type="text" id="addNpcRole" name="role" maxlength="80" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcClass">Class</label>
                        <input type="text" id="addNpcClass" name="class" maxlength="80" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcRace">Race</label>
                        <input type="text" id="addNpcRace" name="race" maxlength="80" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcLevel">Level</label>
                        <input type="number" id="addNpcLevel" name="level" min="1" max="100" step="1" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="addNpcCurrency">Currency</label>
                        <input type="number" id="addNpcCurrency" name="currency" min="0" step="1" autocomplete="off">
                    </div>
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="addNpcIsHostile">
                            <input type="checkbox" id="addNpcIsHostile" name="isHostile">
                            Hostile NPC
                        </label>
                        <span class="npc-edit-help-text">Hostile NPCs will treat players as enemies.</span>
                    </div>
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="addNpcImage">Reference Image (optional)</label>
                        <input type="file" id="addNpcImage" name="image" accept="image/*">
                        <span class="npc-edit-help-text">Use an image to guide the NPC's appearance and vibe.</span>
                    </div>
                </div>
                <div class="npc-edit-section">
                    <label for="addNpcDescription">Description</label>
                    <textarea id="addNpcDescription" name="description" rows="4" placeholder="Optional: Describe appearance, personality, goals..."></textarea>
                </div>
                <div class="npc-edit-section">
                    <label for="addNpcNotes">Notes for generation</label>
                    <textarea id="addNpcNotes" name="notes" rows="3" placeholder="Optional: Extra instructions for the NPC generator"></textarea>
                </div>
                <footer class="npc-edit-footer">
                    <div class="npc-edit-status" id="addNpcStatus" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="addNpcCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="addNpcSaveBtn">Generate NPC</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="loadGameModal" class="modal load-game-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="loadGameModalTitle">Load Game</h2>
                <button type="button" class="modal__close" id="loadGameCloseBtn" aria-label="Close load game dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body load-game-body">
                <fieldset class="load-game-source-control">
                    <legend class="load-game-label">Save type</legend>
                    <label class="load-game-radio">
                        <input type="radio" name="loadGameSource" value="saves" checked>
                        Manual saves
                    </label>
                    <label class="load-game-radio">
                        <input type="radio" name="loadGameSource" value="autosaves">
                        Autosaves
                    </label>
                </fieldset>
                <label for="loadGameSelect" class="load-game-label">Choose a game</label>
                <select id="loadGameSelect" class="load-game-select" size="6" aria-describedby="loadGameStatus"></select>
                <div id="loadGameStatus" class="load-game-status" role="status" aria-live="polite"></div>
            </div>
            <div class="modal__actions load-game-actions">
                <button type="button" class="button button-secondary" id="loadGameCancelBtn">Cancel</button>
                <button type="button" class="button button-primary" id="loadGameConfirmBtn">Load Game</button>
            </div>
        </div>
    </div>
    <div id="newExitModal" class="modal new-exit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="newExitModalTitle">Add New Exit</h2>
                <button type="button" class="modal__close" id="newExitCloseBtn" aria-label="Close new exit dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="newExitForm" class="modal__body new-exit-body" novalidate>
                <div class="new-exit-field">
                    <label for="newExitRegion">Region</label>
                    <select id="newExitRegion" name="regionId">
                        <option value="">Create new region</option>
                    </select>
                </div>
                <div class="new-exit-field" id="newExitLocationGroup" hidden>
                    <label for="newExitLocation">Location</label>
                    <select id="newExitLocation" name="locationId">
                        <option value="">Create new location</option>
                    </select>
                </div>
                <div class="new-exit-field" id="newExitNameGroup">
                    <label for="newExitName">Exit Name</label>
                    <input type="text" id="newExitName" name="name" maxlength="120">
                </div>
                <div class="new-exit-field" id="newExitDescriptionGroup">
                    <label for="newExitDescription">Description</label>
                    <textarea id="newExitDescription" name="description" rows="3" placeholder="Optional: Describe what lies beyond this exit..."></textarea>
                </div>
                <div class="new-exit-field" id="newExitImageGroup">
                    <label for="newExitImage">Reference Image (optional)</label>
                    <input type="file" id="newExitImage" name="image" accept="image/*">
                    <span class="new-exit-help-text">Use an image to guide the new location or region.</span>
                </div>
                <div class="new-exit-field" id="newExitVehicleGroup">
                    <label for="newExitVehicle">Vehicle</label>
                    <input type="text" id="newExitVehicle" name="vehicle" placeholder="Optional: e.g. shuttle, portal, elevator">
                </div>
                <div class="new-exit-field" id="newExitRelativeLevelGroup" hidden>
                    <label for="newExitRelativeLevel">Relative Level</label>
                    <input type="number" id="newExitRelativeLevel" name="relativeLevel" min="-10" max="10" step="1" placeholder="0">
                </div>
                <div class="new-exit-field new-exit-field--checkbox" id="newExitChildRegionGroup" hidden>
                    <label class="modal-checkbox" for="newExitChildRegion">
                        <input type="checkbox" id="newExitChildRegion" name="childRegion">
                        <span>This region should inherit from the current region</span>
                    </label>
                    <p class="modal-checkbox-hint">When enabled, the new region stub is created as a child of your current region.</p>
                </div>
                <footer class="new-exit-footer">
                    <div class="new-exit-status" id="newExitStatus" role="status" aria-live="polite"></div>
                    <div class="new-exit-actions">
                        <button type="button" class="new-exit-cancel" id="newExitCancelBtn">Cancel</button>
                        <button type="submit" class="new-exit-save" id="newExitSaveBtn">Create Exit</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>
    <div id="npcEditModal" class="modal npc-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcEditModalTitle">Edit NPC</h2>
                <button type="button" class="modal__close" id="npcEditCloseBtn" aria-label="Close NPC editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="npcEditForm" class="modal__body" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field">
                        <label for="npcEditId">Character ID</label>
                        <input id="npcEditId" type="text" readonly>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditName">Name</label>
                        <input id="npcEditName" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="npcEditShortDescription">Short Description</label>
                        <input id="npcEditShortDescription" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditRace">Race</label>
                        <input id="npcEditRace" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditClass">Class</label>
                        <input id="npcEditClass" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditFaction">Faction</label>
                        <select id="npcEditFaction"></select>
                        <span class="npc-edit-help-text">Optional faction membership.</span>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditLevel">Level</label>
                        <input id="npcEditLevel" type="number" min="1" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditHealth">Health</label>
                        <input id="npcEditHealth" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditHealthAttribute">Health Bonus Attribute</label>
                        <select id="npcEditHealthAttribute"></select>
                    </div>
                    <div class="npc-edit-field npc-edit-field--readonly">
                        <label for="npcEditMaxHealth">Max Health</label>
                        <div id="npcEditMaxHealth" class="npc-edit-readonly-value">‚Äî</div>
                        <span class="npc-edit-help-text">Calculated automatically</span>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditUnspent">Unspent Skill Points</label>
                        <input id="npcEditUnspent" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditCurrency">Currency</label>
                        <input id="npcEditCurrency" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditExperience">Experience</label>
                        <input id="npcEditExperience" type="number" min="0" step="1">
                    </div>
                </div>

                <div class="npc-edit-section">
                    <label for="npcEditDescription">Description</label>
                    <textarea id="npcEditDescription" rows="4"></textarea>
                </div>

                <div class="npc-edit-section">
                    <h3>Personality</h3>
                    <div class="npc-edit-grid">
                        <div class="npc-edit-field">
                            <label for="npcEditPersonalityType">Type</label>
                            <input id="npcEditPersonalityType" type="text" autocomplete="off">
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="npcEditPersonalityTraits">Traits</label>
                            <textarea id="npcEditPersonalityTraits" rows="2"></textarea>
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="npcEditPersonalityNotes">Notes</label>
                            <textarea id="npcEditPersonalityNotes" rows="3"></textarea>
                        </div>
                    </div>
                </div>

                <div class="npc-edit-section">
                    <h3>Attributes</h3>
                    <div id="npcEditAttributes" class="npc-attribute-grid"></div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Skills</h3>
                        <button type="button" class="npc-edit-add-btn" id="npcAddSkillBtn">Add Skill</button>
                    </div>
                    <div id="npcEditSkills" class="npc-skill-list"></div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Abilities</h3>
                        <button type="button" class="npc-edit-add-btn" id="npcAddAbilityBtn">Add Ability</button>
                    </div>
                    <div id="npcEditAbilities" class="npc-ability-list"></div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Status Effects</h3>
                        <button type="button" class="npc-edit-add-btn" id="npcStatusEffectAddBtn">Add Effect</button>
                    </div>
                    <div id="npcEditStatusEffectsList" class="thing-edit-status-effects"></div>
                    <p class="npc-edit-hint">Intrinsic status effects only; gear effects are applied automatically.</p>
                </div>

                <div class="npc-edit-footer">
                    <div id="npcEditStatus" class="npc-edit-status" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="npcEditCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="npcEditSaveBtn">Save Changes</button>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <div id="thingEditModal" class="modal thing-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="thingEditModalTitle">Edit Item</h2>
                <button type="button" class="modal__close" id="thingEditCloseBtn" aria-label="Close item editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="thingEditForm" class="modal__body npc-edit-form" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field">
                        <label for="thingEditId">Item ID</label>
                        <input id="thingEditId" type="text" readonly>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditName">Name</label>
                        <input id="thingEditName" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditType">Type</label>
                        <select id="thingEditType">
                            <option value="item">Item</option>
                            <option value="scenery">Scenery</option>
                        </select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditRarity">Rarity</label>
                        <select id="thingEditRarity"></select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditItemDetail">Item Detail</label>
                        <input id="thingEditItemDetail" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditSlot">Slot</label>
                        <select id="thingEditSlot"></select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditLevel">Level</label>
                        <input id="thingEditLevel" type="number" min="1" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditImageId">Image ID</label>
                        <input id="thingEditImageId" type="text" autocomplete="off">
                    </div>
                </div>

                <div class="npc-edit-section">
                    <label for="thingEditDescription">Description</label>
                    <textarea id="thingEditDescription" rows="4"></textarea>
                </div>
                <div class="npc-edit-section" id="thingEditShortDescriptionGroup">
                    <label for="thingEditShortDescription">Short Description</label>
                    <input id="thingEditShortDescription" type="text" autocomplete="off">
                </div>
                <div class="npc-edit-section" id="thingEditNotesGroup" hidden>
                    <label for="thingEditNotes">Notes for generation</label>
                    <textarea id="thingEditNotes" rows="3" placeholder="Optional: Extra instructions for the item/scenery generator"></textarea>
                </div>

                <div class="npc-edit-section thing-edit-flags">
                    <h3>Item Properties</h3>
                    <div class="thing-toggle-grid">
                        <label class="thing-toggle">
                            <input type="checkbox" id="thingEditIsVehicle">
                            <div class="thing-toggle-details">
                                <span class="thing-toggle-label">Vehicle</span>
                                <span class="thing-toggle-hint">Usable for travel or transport (e.g., mounts, vehicles, teleport devices).</span>
                            </div>
                        </label>
                        <label class="thing-toggle">
                            <input type="checkbox" id="thingEditIsCraftingStation">
                            <div class="thing-toggle-details">
                                <span class="thing-toggle-label">Crafting Station</span>
                                <span class="thing-toggle-hint">Provides crafting interactions such as forges, workbenches, or labs.</span>
                            </div>
                        </label>
                        <label class="thing-toggle">
                            <input type="checkbox" id="thingEditIsProcessingStation">
                            <div class="thing-toggle-details">
                                <span class="thing-toggle-label">Processing Station</span>
                                <span class="thing-toggle-hint">Used to refine or process materials without crafting recipes.</span>
                            </div>
                        </label>
                        <label class="thing-toggle">
                            <input type="checkbox" id="thingEditIsHarvestable">
                            <div class="thing-toggle-details">
                                <span class="thing-toggle-label">Harvestable Resource</span>
                                <span class="thing-toggle-hint">Can be harvested repeatedly for materials or reagents.</span>
                            </div>
                        </label>
                        <label class="thing-toggle">
                            <input type="checkbox" id="thingEditIsSalvageable">
                            <div class="thing-toggle-details">
                                <span class="thing-toggle-label">Salvageable</span>
                                <span class="thing-toggle-hint">Can be broken down for parts or resources (consumed when salvaged).</span>
                            </div>
                        </label>
                    </div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Metadata</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingMetadataAddBtn">Add Entry</button>
                    </div>
                    <div id="thingEditMetadataList" class="thing-edit-metadata-list"></div>
                    <p class="npc-edit-hint">Use metadata for additional properties like value, weight, or lore tags.</p>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Attribute Bonuses</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingAttributeBonusAddBtn">Add Bonus</button>
                    </div>
                    <div id="thingEditAttributeBonusesList" class="thing-edit-bonus-list"></div>
                </div>

                <div class="npc-edit-section" id="thingOnHitSection">
                    <h3 id="thingOnHitTitle">On-Hit Status Effect</h3>
                    <div class="thing-edit-cause-effect">
                        <div class="npc-edit-field">
                            <label for="thingEditCauseStatusEffectName">Name</label>
                            <input id="thingEditCauseStatusEffectName" type="text" autocomplete="off">
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="thingEditCauseStatusEffectDescription">Description</label>
                            <textarea id="thingEditCauseStatusEffectDescription" rows="2"></textarea>
                        </div>
                        <div class="npc-edit-field">
                            <label for="thingEditCauseStatusEffectDuration">Duration</label>
                            <input id="thingEditCauseStatusEffectDuration" type="text" autocomplete="off" placeholder="e.g. 3 or permanent">
                        </div>
                    </div>
                    <div class="thing-modifier-section">
                        <div class="thing-modifier-header">
                            <h5>Modifiers</h5>
                            <button type="button" class="npc-edit-add-btn" id="thingCauseEffectTargetAddModifierBtn">Add Modifier</button>
                        </div>
                        <div id="thingCauseEffectTargetModifiers" class="thing-modifier-list"></div>
                    </div>
                </div>

                <div class="npc-edit-section" id="thingEquipSection">
                    <h3>On-Equip Status Effect</h3>
                    <div class="thing-edit-cause-effect">
                        <div class="npc-edit-field">
                            <label for="thingEditCauseStatusEffectEquipperName">Name</label>
                            <input id="thingEditCauseStatusEffectEquipperName" type="text" autocomplete="off">
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="thingEditCauseStatusEffectEquipperDescription">Description</label>
                            <textarea id="thingEditCauseStatusEffectEquipperDescription" rows="2"></textarea>
                        </div>
                    </div>
                    <div class="thing-modifier-section">
                        <div class="thing-modifier-header">
                            <h5>Modifiers</h5>
                            <button type="button" class="npc-edit-add-btn" id="thingCauseEffectEquipperAddModifierBtn">Add Modifier</button>
                        </div>
                        <div id="thingCauseEffectEquipperModifiers" class="thing-modifier-list"></div>
                    </div>
                </div>

                <div class="npc-edit-footer">
                    <div id="thingEditStatus" class="npc-edit-status" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="thingEditCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="thingEditSaveBtn">Save Changes</button>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <div id="inventoryTooltip" class="inventory-floating-tooltip" hidden></div>
    <div id="partyTooltip" class="inventory-floating-tooltip party-floating-tooltip" hidden></div>

    <div id="locationEditModal" class="modal location-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="locationEditModalTitle">Edit Location</h2>
                <button type="button" class="modal__close" id="locationEditCloseBtn" aria-label="Close location editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="locationEditForm" class="modal__body location-edit-form" novalidate>
                <div class="location-edit-field">
                    <label for="locationEditName">Location Name</label>
                    <input type="text" id="locationEditName" name="name" maxlength="160" autocomplete="off">
                </div>
                <div class="location-edit-field">
                    <label for="locationEditDescription">Description</label>
                    <textarea id="locationEditDescription" name="description" rows="6" required></textarea>
                </div>
                <div class="location-edit-field" id="locationEditShortDescriptionGroup">
                    <label for="locationEditShortDescription">Short Description</label>
                    <input type="text" id="locationEditShortDescription" name="shortDescription" autocomplete="off">
                </div>
                <div class="location-edit-field" id="locationEditRelativeLevelGroup" hidden>
                    <label for="locationEditRelativeLevel">Relative Level</label>
                    <input type="number" id="locationEditRelativeLevel" name="relativeLevel" min="-10" max="10" step="1" placeholder="0">
                </div>
                <div class="location-edit-field">
                    <label for="locationEditLevel">Level</label>
                    <input type="number" id="locationEditLevel" name="level" min="1" max="99" step="1" required>
                </div>
                <div class="location-edit-field">
                    <label for="locationEditFaction">Controlling Faction</label>
                    <select id="locationEditFaction"></select>
                </div>
                <div class="location-edit-field location-edit-field--static">
                    <span class="location-edit-label">Absolute Level</span>
                    <span id="locationEditAbsoluteLevel" class="location-edit-value">‚Äî</span>
                </div>
                <div class="location-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Status Effects</h3>
                        <button type="button" class="npc-edit-add-btn" id="locationStatusEffectAddBtn">Add Effect</button>
                    </div>
                    <div id="locationEditStatusEffectsList" class="thing-edit-status-effects"></div>
                </div>
                <footer class="location-edit-footer">
                    <div class="location-edit-status" id="locationEditStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel" id="locationEditCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save" id="locationEditSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="regionEditModal" class="modal region-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="regionEditModalTitle">Edit Region</h2>
                <button type="button" class="modal__close" id="regionEditCloseBtn" aria-label="Close region editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="regionEditForm" class="modal__body location-edit-form region-edit-form" novalidate>
                <div class="location-edit-field">
                    <label for="regionEditName">Region Name</label>
                    <input type="text" id="regionEditName" name="name" maxlength="160" required>
                </div>
                <div class="location-edit-field">
                    <label for="regionEditDescription">Description</label>
                    <textarea id="regionEditDescription" name="description" rows="6" required></textarea>
                </div>
                <div class="location-edit-field" id="regionEditShortDescriptionGroup">
                    <label for="regionEditShortDescription">Short Description</label>
                    <input type="text" id="regionEditShortDescription" name="shortDescription" autocomplete="off">
                </div>
                <div class="location-edit-field">
                    <label for="regionEditParent">Parent Region</label>
                    <select id="regionEditParent" name="parentRegionId">
                        <option value="">None</option>
                    </select>
                </div>
                <div class="location-edit-field">
                    <label for="regionEditAverageLevel">Average Level</label>
                    <input type="number" id="regionEditAverageLevel" name="averageLevel" min="1" step="1" required>
                </div>
                <div class="location-edit-field">
                    <label for="regionEditFaction">Controlling Faction</label>
                    <select id="regionEditFaction"></select>
                </div>
                <footer class="location-edit-footer region-edit-footer">
                    <div class="location-edit-status region-edit-status" id="regionEditStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel region-edit-cancel" id="regionEditCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save region-edit-save" id="regionEditSaveBtn">Save Changes</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="summonNpcModal" class="modal summon-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="summonNpcModalTitle">Summon NPC</h2>
                <button type="button" class="modal__close" id="summonNpcCloseBtn" aria-label="Close summon NPC dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="summonNpcForm" class="modal__body location-edit-form summon-modal-form" novalidate>
                <div class="location-edit-field">
                    <label for="summonNpcSelect">Select NPC</label>
                    <select id="summonNpcSelect" name="npcId" required disabled>
                        <option value="" disabled selected hidden>Select an NPC</option>
                    </select>
                </div>
                <footer class="location-edit-footer">
                    <div class="location-edit-status" id="summonNpcStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel" id="summonNpcCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save" id="summonNpcConfirmBtn" disabled>Summon</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="summonThingModal" class="modal summon-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="summonThingModalTitle">Summon Item or Scenery</h2>
                <button type="button" class="modal__close" id="summonThingCloseBtn" aria-label="Close summon item dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="summonThingForm" class="modal__body location-edit-form summon-modal-form" novalidate>
                <div class="location-edit-field">
                    <label for="summonThingSelect">Select Item or Scenery</label>
                    <select id="summonThingSelect" name="thingId" required disabled>
                        <option value="" disabled selected hidden>Select an item</option>
                    </select>
                </div>
                <footer class="location-edit-footer">
                    <div class="location-edit-status" id="summonThingStatus" role="status" aria-live="polite"></div>
                    <div class="location-edit-actions">
                        <button type="button" class="location-edit-cancel" id="summonThingCancelBtn">Cancel</button>
                        <button type="submit" class="location-edit-save" id="summonThingConfirmBtn" disabled>Summon</button>
                    </div>
                </footer>
            </form>
        </div>
    </div>

    <div id="imageLightbox" class="image-lightbox" hidden aria-hidden="true" tabindex="-1">
        <div class="image-lightbox__inner" role="dialog" aria-modal="true" aria-labelledby="imageLightboxCaption">
            <img id="imageLightboxImage" class="image-lightbox__image" alt="" src="" loading="lazy">
            <div id="imageLightboxCaption" class="image-lightbox__caption" hidden></div>
        </div>
    </div>

    <script src="/vendor/fitty.min.js"></script>
    <script src="/js/fitty-init.js"></script>
    <script src="/vendor/cytoscape.min.js"></script>
    <script src="/vendor/layout-base.js"></script>
    <script src="/vendor/cose-base.js"></script>
    <script src="/vendor/cytoscape-fcose.js"></script>
    <script src="/vendor/cytoscape-euler.js"></script>
    <script src="/js/cytoscape-convex-hull.js"></script>
    <script src="/js/lightbox.js"></script>
    <script src="/js/image-manager.js"></script>
    <script src="/js/currency-utils.js"></script>
    <script src="/vendor/nunjucks.js"></script>
    <script src="/vendor/markdown-it.min.js"></script>
    <script src="/js/chat.js"></script>
    <script defer src="/js/map.js"></script>
    <script defer src="/js/world-map.js"></script>
    <script defer src="/js/player-stats.js"></script>
    {% if modScripts %}{% for mod in modScripts %}{% for script in mod.scripts %}
    <script src="{{ script }}"></script>
    {% endfor %}{% endfor %}{% endif %}
    <script>
        window.currentSetting = {{ (currentSetting or {}) | dump | safe }};
        window.rarityDefinitions = {{ (rarityDefinitions or []) | dump | safe }};
        window.CHECK_MOVE_PLAUSIBILITY = {{ (checkMovePlausibility or 'never') | dump | safe }};
        window.availableSkillsList = {{ (availableSkills or []) | dump | safe }};
        window.needBarDefinitions = {{ (needBarDefinitions or []) | dump | safe }};
        window.__AIRPG_SAVE_METADATA__ = {{ (saveMetadata if saveMetadata is defined else null) | dump | safe }};
        if (!window.AIRPG_CONFIG || typeof window.AIRPG_CONFIG !== 'object') {
            window.AIRPG_CONFIG = {};
        }
        window.AIRPG_CONFIG.baseWeaponDamage = {{ (baseWeaponDamage if baseWeaponDamage is defined else null) | dump | safe }};
        window.AIRPG_CONFIG.clientMessageHistory = {{ clientMessageHistory | dump | safe }};
        const __knownSkillNameSet = new Set(
            (Array.isArray(window.availableSkillsList) ? window.availableSkillsList : [])
                .map(skill => {
                    if (!skill || typeof skill.name !== 'string') {
                        return null;
                    }
                    const trimmed = skill.name.trim();
                    return trimmed ? trimmed.toLowerCase() : null;
                })
                .filter(Boolean)
        );
        window.getKnownSkillNameSet = function () {
            return __knownSkillNameSet;
        };
        // Initialize with system prompt from server
        async function fetchLocationImageGenerationFlag() {
            try {
                const response = await fetch('/api/features/location-image-generation', { cache: 'no-store' });
                if (!response.ok) {
                    return;
                }
                const data = await response.json().catch(() => null);
                if (data && typeof data.enabled === 'boolean') {
                    locationImageGenerationEnabled = data.enabled;
                    window.locationImageGenerationEnabled = locationImageGenerationEnabled;
                }
            } catch (error) {
                console.warn('Failed to load location image generation flag:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            //window.systemPrompt = {{ systemPrompt | dump | safe }};
            window.locationImageGenerationEnabled = locationImageGenerationEnabled;
            await fetchLocationImageGenerationFlag();

            new AIRPGChat();
            
            // Add save/load functionality
            initSaveLoadButtons();
            
            // Initialize tabs
            initTabs();

            initFloatingTooltipController();
            // Initialize location display
            initLocationDisplay();
            initQuestPanel();
            initFactionPanel();
            initPlayerOverviewSync();
            initPartyDisplay();
            await maybePromptSummaryStyle();
        });

        const normalizeSummaryStyle = (value) => {
            const normalized = typeof value === 'string' ? value.trim().toLowerCase() : '';
            if (normalized === 'scene' || normalized === 'line') {
                return normalized;
            }
            return '';
        };

        const maybePromptSummaryStyle = async () => {
            if (window.__AIRPG_SUMMARY_STYLE_PROMPTED__) {
                return;
            }
            window.__AIRPG_SUMMARY_STYLE_PROMPTED__ = true;

            const metadata = window.__AIRPG_SAVE_METADATA__;
            if (!metadata || typeof metadata !== 'object') {
                return;
            }
            const currentStyle = normalizeSummaryStyle(metadata.summaryStyle);
            if (currentStyle) {
                return;
            }

            const message = [
                'This save is using the older line-by-line summaries.',
                '',
                'Switch to the new scene summaries? They are better and use fewer tokens,',
                'but creating them will take several minutes and use some long prompts.'
            ].join('\n');
            const accepted = window.confirm(message);
            const nextStyle = accepted ? 'scene' : 'line';

            try {
                const response = await fetch('/api/summaries/style', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ style: nextStyle })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    const errorMessage = data?.error || `HTTP ${response.status}`;
                    console.warn('Failed to update summary style:', errorMessage);
                    alert(`Failed to update summary style: ${errorMessage}`);
                    return;
                }
                metadata.summaryStyle = nextStyle;
                window.__AIRPG_SAVE_METADATA__ = metadata;
            } catch (error) {
                console.warn('Failed to update summary style:', error);
                alert(`Failed to update summary style: ${error?.message || error}`);
            }
        };

        function bindLightboxElement(element, dataProvider) {
            if (!element || !window.lightboxController) {
                return;
            }

            try {
                window.lightboxController.bind(element, dataProvider);
            } catch (error) {
                console.warn('Failed to bind lightbox:', error);
            }
        }

        const escapeHtml = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        };

        const tokenizeForMatch = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            const normalized = String(value)
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, ' ')
                .replace(/\s+/g, ' ');
            return normalized ? ` ${normalized} ` : '';
        };

        const runtimeConfig = (() => {
            if (window.__AIRPG_CONFIG__ && typeof window.__AIRPG_CONFIG__ === 'object') {
                return window.__AIRPG_CONFIG__;
            }
            if (window.AIRPG_CONFIG && typeof window.AIRPG_CONFIG === 'object') {
                return window.AIRPG_CONFIG;
            }
            if (window.AIRPG && typeof window.AIRPG.config === 'object') {
                return window.AIRPG.config;
            }
            if (window.config && typeof window.config === 'object') {
                return window.config;
            }
            return {};
        })();

        function renderImageBadgesOverlay(element, badges = null) {
            if (!element) {
                return;
            }
            const existing = element.querySelector('.entity-image-badges');
            if (existing) {
                existing.remove();
            }

            let normalized = [];
            if (Array.isArray(badges) && badges.length) {
                normalized = badges
                    .map(badge => {
                        if (typeof badge === 'string') {
                            const icon = badge.trim();
                            return icon ? { icon, label: '' } : null;
                        }
                        if (badge && typeof badge === 'object' && typeof badge.icon === 'string') {
                            const icon = badge.icon.trim();
                            if (!icon) {
                                return null;
                            }
                            return {
                                icon,
                                label: typeof badge.label === 'string' ? badge.label : '',
                                key: typeof badge.key === 'string' ? badge.key : null
                            };
                        }
                        return null;
                    })
                    .filter(Boolean);
            } else if (element?.dataset?.imageBadges) {
                try {
                    const stored = JSON.parse(element.dataset.imageBadges);
                    if (Array.isArray(stored)) {
                        normalized = stored
                            .map(entry => {
                            if (entry && typeof entry.icon === 'string') {
                                const icon = entry.icon.trim();
                                if (!icon) {
                                    return null;
                                }
                                return {
                                    icon,
                                    label: typeof entry.label === 'string' ? entry.label : '',
                                    key: typeof entry.key === 'string' ? entry.key : null
                                };
                            }
                            return null;
                        })
                        .filter(Boolean);
                    }
                } catch (_) {
                    normalized = [];
                }
            }

            if (!normalized.length) {
                return;
            }

            const overlay = document.createElement('div');
            overlay.className = 'entity-image-badges';
            const hasInteractiveBadges = normalized.some(entry =>
                entry.key === 'isCraftingStation'
                || entry.key === 'isProcessingStation'
                || entry.key === 'isSalvageable'
                || entry.key === 'isHarvestable'
            );
            if (hasInteractiveBadges) {
                overlay.classList.add('entity-image-badges--interactive');
            }
            normalized.forEach(badge => {
                const span = document.createElement('span');
                span.className = 'entity-image-badge';
                span.textContent = badge.icon;
                if (badge.label) {
                    span.title = badge.label;
                }
                if (badge.key) {
                    span.dataset.badgeKey = badge.key;
                }
                const isCraftingAction = badge.key === 'isCraftingStation';
                const isProcessingAction = badge.key === 'isProcessingStation';
                const isSalvageAction = badge.key === 'isSalvageable';
                const isHarvestAction = badge.key === 'isHarvestable';
                if (isCraftingAction || isProcessingAction || isSalvageAction || isHarvestAction) {
                    span.classList.add('entity-image-badge--action');
                    span.setAttribute('role', 'button');
                    span.setAttribute('tabindex', '0');
                    if (isSalvageAction || isHarvestAction) {
                        const activateBadge = (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            if (isHarvestAction) {
                                attemptHarvestFromBadge(element);
                            } else {
                                attemptSalvageFromBadge(element);
                            }
                        };
                        span.addEventListener('click', activateBadge);
                        span.addEventListener('keydown', (event) => {
                            if (event.key === 'Enter' || event.key === ' ') {
                                activateBadge(event);
                            }
                        });
                    } else {
                        const activateBadge = (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            openCraftingModalFromBadge(isProcessingAction ? 'isProcessingStation' : 'isCraftingStation', element);
                        };
                        span.addEventListener('click', activateBadge);
                        span.addEventListener('keydown', (event) => {
                            if (event.key === 'Enter' || event.key === ' ') {
                                activateBadge(event);
                            }
                        });
                    }
                }
                overlay.appendChild(span);
            });
            element.appendChild(overlay);
        }

        function renderEntityImage({
            element,
            entityType,
            entityId,
            imageId,
            altText,
            placeholderIcon = 'üñºÔ∏è',
            placeholderClass = 'image-placeholder',
            placeholderMarkup = null,
            enableLightbox = true,
            force = false,
            badges = null
        }) {
            if (!element) {
                return Promise.resolve(null);
            }

            const safeAltText = escapeHtml(altText || '');
            const computedPlaceholderMarkup = placeholderMarkup !== null
                ? placeholderMarkup
                : `<div class="${placeholderClass}">${placeholderIcon}</div>`;

            const normalizedBadges = Array.isArray(badges)
                ? badges
                    .map(badge => {
                        if (typeof badge === 'string') {
                            const icon = badge.trim();
                            return icon ? { icon, label: '' } : null;
                        }
                        if (badge && typeof badge === 'object' && typeof badge.icon === 'string') {
                            const icon = badge.icon.trim();
                            if (!icon) {
                                return null;
                            }
                            return {
                                icon,
                                label: typeof badge.label === 'string' ? badge.label : '',
                                key: typeof badge.key === 'string' ? badge.key : null
                            };
                        }
                        return null;
                    })
                    .filter(Boolean)
                : [];

            if (normalizedBadges.length) {
                try {
                    element.dataset.imageBadges = JSON.stringify(normalizedBadges);
                } catch (_) {
                    element.dataset.imageBadges = JSON.stringify(normalizedBadges.map(entry => ({ icon: entry.icon })));
                }
            } else {
                delete element.dataset.imageBadges;
            }

            const applyBadgesOverlay = () => {
                renderImageBadgesOverlay(element, normalizedBadges.length ? normalizedBadges : null);
            };

            const applyImageMarkup = (url) => {
                if (!url) {
                    element.innerHTML = computedPlaceholderMarkup;
                    applyBadgesOverlay();
                    return;
                }

                element.innerHTML = `<img src="${url}" alt="${safeAltText}" loading="lazy" onerror="this.parentElement.innerHTML='<div class=\\'${placeholderClass}\\' role=\\'img\\'>${placeholderIcon}</div>'">`;
                const img = element.querySelector('img');
                if (img && enableLightbox) {
                    img.dataset.lightboxImage = img.src;
                    img.dataset.lightboxAlt = altText || safeAltText || 'Image';
                    img.dataset.lightboxCaption = altText || '';
                    bindLightboxElement(img);
                }
                applyBadgesOverlay();
            };

            const setPlaceholder = () => {
                element.innerHTML = computedPlaceholderMarkup;
                applyBadgesOverlay();
            };

            element.dataset.imageEntityType = entityType || '';
            element.dataset.imageEntityId = entityId || '';
            element.dataset.imagePlaceholder = placeholderIcon || 'üñºÔ∏è';
            element.dataset.imagePlaceholderClass = placeholderClass || 'image-placeholder';
            if (placeholderMarkup !== null && placeholderMarkup !== undefined) {
                element.dataset.imagePlaceholderMarkup = placeholderMarkup;
            } else {
                delete element.dataset.imagePlaceholderMarkup;
            }
            element.dataset.imageAlt = altText || '';
            element.dataset.imageLightbox = enableLightbox ? 'true' : 'false';
            element.dataset.imageAuto = 'true';
            if (force) {
                element.dataset.imageForce = 'true';
            } else {
                delete element.dataset.imageForce;
            }

            element.dataset.imageProcessing = 'true';

            if (imageId) {
                element.dataset.imageId = imageId;
                applyImageMarkup(`/generated-images/${imageId}.png`);
            } else {
                delete element.dataset.imageId;
                setPlaceholder();
            }

            const finalize = (result) => {
                delete element.dataset.imageProcessing;
                element.dataset.imageInitialized = 'true';
                return result;
            };

            const manager = window.AIRPG?.imageManager;
            if (!manager || !entityType || !entityId) {
                return Promise.resolve(finalize(null));
            }

            return manager.ensureImage({
                entityType,
                entityId,
                existingImageId: imageId || null,
                force: Boolean(force)
            }).then(result => {
                if (result?.imageId) {
                    element.dataset.imageId = result.imageId;
                }

                const imageUrl = result?.imageUrl || (result?.imageId ? `/generated-images/${result.imageId}.png` : null);
                if (imageUrl) {
                    applyImageMarkup(imageUrl);
                } else if (!result?.skipped) {
                    setPlaceholder();
                }

                return finalize(result || null);
            }).catch(error => {
                console.warn(`Image generation failed for ${entityType} ${entityId}:`, error?.message || error);
                element.innerHTML = `<div class="${placeholderClass} error">${placeholderIcon}</div>`;
                return finalize(null);
            });
        }

        window.renderEntityImage = renderEntityImage;

        function getEntityImageElements(entityType, entityId) {
            const targetType = typeof entityType === 'string' ? entityType.trim() : '';
            const targetId = typeof entityId === 'string' ? entityId.trim() : '';
            if (!targetType || !targetId) {
                return [];
            }
            const all = Array.from(document.querySelectorAll('[data-image-entity-type]'));
            return all.filter(element => {
                const dataset = element?.dataset || {};
                return dataset.imageEntityType === targetType && dataset.imageEntityId === targetId;
            });
        }

        function setEntityImagePlaceholder(element) {
            if (!element) {
                return;
            }
            const dataset = element.dataset || {};
            const placeholderMarkup = dataset.imagePlaceholderMarkup;
            if (placeholderMarkup) {
                element.innerHTML = placeholderMarkup;
            } else {
                const placeholderIcon = dataset.imagePlaceholder || 'üñºÔ∏è';
                const placeholderClass = dataset.imagePlaceholderClass || 'image-placeholder';
                element.innerHTML = `<div class="${placeholderClass}">${placeholderIcon}</div>`;
            }
            element.dataset.imageId = '';
            element.dataset.imageProcessing = 'true';
            renderImageBadgesOverlay(element);
        }

        function applyEntityImagePlaceholder(entityType, entityId) {
            const elements = getEntityImageElements(entityType, String(entityId || ''));
            elements.forEach(setEntityImagePlaceholder);
            return elements;
        }

        function renderEntityImages(entityType, entityId, options = {}) {
            const elements = getEntityImageElements(entityType, String(entityId || ''));
            return elements.map(element => {
                const dataset = element.dataset || {};
                const altText = options.altText ?? dataset.imageAlt ?? '';
                const placeholderIcon = options.placeholderIcon ?? dataset.imagePlaceholder ?? 'üñºÔ∏è';
                const placeholderClass = options.placeholderClass ?? dataset.imagePlaceholderClass ?? 'image-placeholder';
                const hasPlaceholderOption = Object.prototype.hasOwnProperty.call(options, 'placeholderMarkup');
                const placeholderMarkup = hasPlaceholderOption
                    ? options.placeholderMarkup
                    : (dataset.imagePlaceholderMarkup ? dataset.imagePlaceholderMarkup : null);
                const enableLightbox = options.enableLightbox ?? (dataset.imageLightbox !== 'false');
                const force = options.force ?? false;
                const hasImageIdOption = Object.prototype.hasOwnProperty.call(options, 'imageId');
                const imageId = hasImageIdOption ? options.imageId : (dataset.imageId || null);

                return renderEntityImage({
                    element,
                    entityType,
                    entityId,
                    imageId: imageId || null,
                    altText,
                    placeholderIcon,
                    placeholderClass,
                    placeholderMarkup,
                    enableLightbox,
                    force
                });
            });
        }

        const adventureBackgroundElement = document.getElementById('adventureBackground');
        function updateAdventureBackground(imageUrl) {
            if (!adventureBackgroundElement) {
                return;
            }
            if (imageUrl) {
                adventureBackgroundElement.style.setProperty('--adventure-bg-image', `url("${imageUrl}")`);
                adventureBackgroundElement.classList.add('has-image');
            } else {
                adventureBackgroundElement.style.removeProperty('--adventure-bg-image');
                adventureBackgroundElement.classList.remove('has-image');
            }
        }

        function createHealthBar(additionalClassNames = '') {
            const bar = document.createElement('div');
            bar.className = ['health-bar', additionalClassNames].filter(Boolean).join(' ');
            bar.setAttribute('aria-hidden', 'true');

            const fill = document.createElement('div');
            fill.className = 'health-bar-fill';
            bar.appendChild(fill);

            return { bar, fill };
        }

        function applyNpcDeathStyling(card, portrait, npc) {
            if (!card || !portrait) {
                return;
            }

            const existingIndicator = portrait.querySelector('.npc-death-indicator');
            existingIndicator?.remove();

            const isDead = Boolean(npc?.isDead);
            card.classList.toggle('is-dead', isDead);

            if (!isDead) {
                return;
            }

            const indicator = document.createElement('div');
            indicator.className = 'npc-death-indicator';

            const icon = document.createElement('span');
            icon.className = 'npc-death-indicator__icon';
            icon.textContent = 'üíÄ';
            indicator.appendChild(icon);

            if (Number.isFinite(npc?.corpseCountdown)) {
                const countdown = document.createElement('span');
                countdown.className = 'npc-death-indicator__countdown';
                countdown.textContent = String(Math.max(0, npc.corpseCountdown));
                indicator.appendChild(countdown);
            }

            portrait.appendChild(indicator);
        }

        function escapeForSelector(value) {
            if (value === null || value === undefined) {
                return '';
            }
            if (window.CSS && typeof window.CSS.escape === 'function') {
                return window.CSS.escape(String(value));
            }
            return String(value).replace(/(["'\\])/g, '\\$1');
        }

        function updateNpcCorpseVisuals(updates = []) {
            if (!Array.isArray(updates) || !updates.length) {
                return;
            }

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            updates.forEach(entry => {
                if (!entry || !entry.npcId) {
                    return;
                }
                const npcId = entry.npcId;
                const countdown = Number.isFinite(entry.corpseCountdown) ? entry.corpseCountdown : entry.corpseCountdown ?? null;

                const cached = npcDataCache.get(npcId) || { id: npcId };
                cached.corpseCountdown = countdown;
                if (countdown !== null) {
                    cached.isDead = true;
                }
                npcDataCache.set(npcId, cached);

                const selector = `[data-npc-id="${escapeForSelector(npcId)}"]`;
                document.querySelectorAll(`.location-entity-card.is-npc${selector}`).forEach(card => {
                    const portrait = card.querySelector('.location-entity-icon');
                    applyNpcDeathStyling(card, portrait, cached);
                });
                document.querySelectorAll(`.party-card${selector}`).forEach(card => {
                    const portrait = card.querySelector('.location-entity-icon');
                    applyNpcDeathStyling(card, portrait, cached);
                });
            });
        }

        function removeNpcCards(removals = []) {
            if (!Array.isArray(removals) || !removals.length) {
                return;
            }

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            removals.forEach(entry => {
                if (!entry || !entry.npcId) {
                    return;
                }
                const npcId = entry.npcId;
                npcDataCache.delete(npcId);

                const selector = `[data-npc-id="${escapeForSelector(npcId)}"]`;
                document.querySelectorAll(`.location-entity-card.is-npc${selector}`).forEach(card => card.remove());
                document.querySelectorAll(`.party-card${selector}`).forEach(card => card.remove());
            });
        }

        function updateHealthBar(barElement, fillElement, currentValue, maxValue) {
            if (!barElement || !fillElement) {
                return;
            }

            if (!barElement.hasAttribute('role')) {
                barElement.setAttribute('role', 'progressbar');
                barElement.setAttribute('aria-valuemin', '0');
            }

            const current = Number.isFinite(Number(currentValue))
                ? Math.max(0, Number(currentValue))
                : null;
            const maxRaw = Number.isFinite(Number(maxValue))
                ? Math.max(0, Number(maxValue))
                : null;
            const max = maxRaw && maxRaw > 0 ? maxRaw : null;

            if (current === null) {
                fillElement.style.width = '0%';
                barElement.setAttribute('aria-hidden', 'true');
                barElement.removeAttribute('aria-valuenow');
                barElement.removeAttribute('aria-valuemax');
                barElement.removeAttribute('title');
                return;
            }

            const ratio = max ? current / max : (current > 0 ? 1 : 0);
            const clampedRatio = Math.max(0, Math.min(1, ratio));
            fillElement.style.width = `${(clampedRatio * 100).toFixed(1)}%`;

            barElement.setAttribute('aria-hidden', 'false');
            barElement.setAttribute('aria-valuenow', String(current));
            barElement.setAttribute('aria-valuemax', String(max || Math.max(current, 1)));
            barElement.setAttribute('title', max ? `Health: ${current} / ${max}` : `Health: ${current}`);
        }

        function renderNeedBars(container, bars = [], options = {}) {
            if (!container) {
                return;
            }

            const {
                showIcon = false,
                includePlayerOnly = false,
                variant = 'default',
                compact = false,
                iconFallback = ''
            } = options;

            const barsArray = Array.isArray(bars) ? bars : [];
            const filtered = includePlayerOnly ? barsArray : barsArray.filter(bar => !bar?.playerOnly);

            container.innerHTML = '';

            if (!filtered.length) {
                container.setAttribute('hidden', '');
                container.style.display = 'none';
                return;
            }

            container.removeAttribute('hidden');
            container.style.display = '';

            filtered.forEach(bar => {
                if (!bar) {
                    return;
                }

                const wrapper = document.createElement('div');
                wrapper.className = 'need-bar';
                if (variant) {
                    wrapper.classList.add(`need-bar--${variant}`);
                }
                if (compact) {
                    wrapper.classList.add('need-bar--compact');
                }
                wrapper.dataset.barId = bar.id || '';

                const min = Number.isFinite(Number(bar.min)) ? Number(bar.min) : 0;
                const max = Number.isFinite(Number(bar.max)) ? Number(bar.max) : 100;
                const value = Number.isFinite(Number(bar.value)) ? Number(bar.value) : min;
                const clamped = Math.max(min, Math.min(max, value));
                const denominator = max > min ? max - min : 1;
                const ratio = denominator ? (clamped - min) / denominator : 1;

                wrapper.setAttribute('role', 'progressbar');
                wrapper.setAttribute('aria-valuemin', String(min));
                wrapper.setAttribute('aria-valuemax', String(max));
                wrapper.setAttribute('aria-valuenow', String(Math.round(clamped)));
                wrapper.setAttribute('title', `${bar.name || bar.id || 'Need'}: ${Math.round(clamped)} / ${Math.round(max)}`);

                if (showIcon) {
                    const iconChar = (typeof bar.icon === 'string' && bar.icon.trim()) ? bar.icon.trim() : iconFallback;
                    if (iconChar) {
                        const iconSpan = document.createElement('span');
                        iconSpan.className = 'need-bar-icon';
                        iconSpan.textContent = iconChar;
                        iconSpan.setAttribute('aria-hidden', 'true');
                        wrapper.appendChild(iconSpan);
                    }
                }

                const track = document.createElement('div');
                track.className = 'need-bar-track';

                const fill = document.createElement('div');
                fill.className = 'need-bar-fill';
                const color = typeof bar.color === 'string' && bar.color.trim() ? bar.color.trim() : '';
                if (color) {
                    fill.style.setProperty('--need-bar-color', color);
                    fill.style.backgroundColor = color;
                }
                fill.style.width = `${(Math.max(0, Math.min(1, ratio)) * 100).toFixed(1)}%`;

                track.appendChild(fill);
                wrapper.appendChild(track);
                container.appendChild(wrapper);
            });
        }

        function cloneActorRecord(actor) {
            if (!actor || typeof actor !== 'object') {
                return null;
            }
            const clone = { ...actor };
            if (Array.isArray(actor.needBars)) {
                clone.needBars = actor.needBars.map(bar => ({ ...bar }));
            }
            if (Array.isArray(actor.importantMemories)) {
                clone.importantMemories = actor.importantMemories.slice(0);
            }
            if (actor.attributeInfo && typeof actor.attributeInfo === 'object') {
                const copied = {};
                for (const [key, info] of Object.entries(actor.attributeInfo)) {
                    copied[key] = info && typeof info === 'object' ? { ...info } : info;
                }
                clone.attributeInfo = copied;
            }
            return clone;
        }

        function cloneThingRecord(thing) {
            if (!thing || typeof thing !== 'object') {
                return null;
            }
            try {
                if (typeof structuredClone === 'function') {
                    return structuredClone(thing);
                }
            } catch (_) {
                // ignore structuredClone errors and fall back to JSON cloning
            }
            try {
                return JSON.parse(JSON.stringify(thing));
            } catch (_) {
                return { ...thing };
            }
        }

        function computeHealthDelta(previousActor, currentActor) {
            const previousHealth = Number(previousActor?.health);
            const currentHealth = Number(currentActor?.health);
            if (!Number.isFinite(previousHealth) || !Number.isFinite(currentHealth)) {
                return 0;
            }
            return currentHealth - previousHealth;
        }

        function triggerHealthChangeEffect(target, previousActor, currentActor) {
            if (!target) {
                return;
            }
            const delta = computeHealthDelta(previousActor, currentActor);
            if (!delta) {
                return;
            }
            spawnHealthChangeFloat(target, delta);
        }

        function spawnHealthChangeFloat(target, delta) {
            if (!target || !Number.isFinite(delta) || delta === 0) {
                return;
            }

            if (typeof console !== 'undefined') {
                try {
                    const actorCard = target.closest('[data-npc-id]');
                    const actorId = actorCard?.dataset?.npcId || window.currentPlayerData?.id || null;
                    const actorName = actorCard?.querySelector('.location-entity-name')?.textContent
                        || window.currentPlayerData?.name
                        || null;
                    console.debug('[HPChange]', {
                        delta,
                        actorId,
                        actorName,
                        timestamp: new Date().toISOString()
                    });
                } catch (_) {
                    console.debug('[HPChange]', { delta, timestamp: new Date().toISOString() });
                }
            }

            const indicator = document.createElement('div');
            indicator.className = 'health-change-float';
            indicator.classList.add(delta > 0 ? 'health-change--gain' : 'health-change--loss');
            indicator.textContent = `${delta > 0 ? '+' : ''}${Math.round(delta)}`;
            indicator.setAttribute('aria-hidden', 'true');

            const computedStyle = window.getComputedStyle(target);
            if (computedStyle.position === 'static') {
                target.style.position = 'relative';
            }

            const rect = target.getBoundingClientRect();
            const width = rect.width || target.offsetWidth || 0;
            const height = rect.height || target.offsetHeight || 0;

            const horizontalPadding = Math.min(width * 0.25, 40);
            const verticalPadding = Math.min(height * 0.25, 32);
            const availableWidth = Math.max(width - horizontalPadding * 2, 0);
            const availableHeight = Math.max(height - verticalPadding * 2, 0);

            const randomX = horizontalPadding + (availableWidth ? Math.random() * availableWidth : 0);
            const randomY = verticalPadding + (availableHeight ? Math.random() * availableHeight : 0);

            indicator.style.left = `${randomX}px`;
            indicator.style.top = `${randomY}px`;

            const horizontalDrift = (Math.random() * 28) - 14;
            const verticalDrift = -(Math.random() * 24 + 24);
            indicator.style.setProperty('--float-x', `${horizontalDrift}px`);
            indicator.style.setProperty('--float-y', `${verticalDrift}px`);

            target.appendChild(indicator);

            indicator.addEventListener('animationend', () => {
                indicator.remove();
            }, { once: true });

            window.setTimeout(() => {
                if (indicator.isConnected) {
                    indicator.remove();
                }
            }, 15000);
        }

        function resolveCurrencyLabel({ capitalize = false } = {}) {
            const setting = window.currentSetting || {};
            const raw = typeof setting.currencyNamePlural === 'string' ? setting.currencyNamePlural.trim() : '';
            const label = raw || 'coins';
            if (!capitalize) {
                return label;
            }
            if (!label) {
                return label;
            }
            return label.charAt(0).toUpperCase() + label.slice(1);
        }

        function resolveUnspentPointCount(value) {
            const numeric = Number.parseInt(value, 10);
            return Number.isFinite(numeric) ? numeric : 0;
        }

        function formatUnspentPointLabel(count, typeLabel) {
            const suffix = count === 1 ? '' : 's';
            return `${count} unspent ${typeLabel} point${suffix}`;
        }

        function buildUnspentPointsTooltip(skillPoints, attributePoints) {
            const parts = [];
            if (skillPoints > 0) {
                parts.push(formatUnspentPointLabel(skillPoints, 'skill'));
            }
            if (attributePoints > 0) {
                parts.push(formatUnspentPointLabel(attributePoints, 'attribute'));
            }
            if (!parts.length) {
                return '';
            }
            if (parts.length === 1) {
                return `You have ${parts[0]}.`;
            }
            return `You have ${parts[0]} and ${parts[1]}.`;
        }

        function updateChatPlayerPointsIndicator(player = {}) {
            const indicator = chatSidebarElements.pointsIndicator;
            if (!indicator) {
                return;
            }

            const skillPoints = resolveUnspentPointCount(player?.unspentSkillPoints);
            const attributePoints = resolveUnspentPointCount(player?.unspentAttributePoints);
            const shouldDisplay = skillPoints > 0 || attributePoints > 0;

            if (!shouldDisplay) {
                indicator.setAttribute('hidden', '');
                indicator.setAttribute('aria-hidden', 'true');
                indicator.removeAttribute('title');
                return;
            }

            const tooltipText = buildUnspentPointsTooltip(skillPoints, attributePoints);
            indicator.removeAttribute('hidden');
            indicator.setAttribute('aria-hidden', 'false');
            if (tooltipText) {
                indicator.setAttribute('title', tooltipText);
            } else {
                indicator.removeAttribute('title');
            }
        }

        const chatSidebarElements = {
            card: document.getElementById('chatPlayerCard'),
            portrait: document.getElementById('chatPlayerPortrait'),
            pointsIndicator: document.getElementById('chatPlayerPointsIndicator'),
            portraitImage: document.getElementById('chatPlayerPortraitImage'),
            healthBar: document.getElementById('chatPlayerHealthBar'),
            healthBarFill: document.getElementById('chatPlayerHealthBarFill'),
            needBars: document.getElementById('chatPlayerNeedBars'),
            viewButton: document.getElementById('chatPlayerViewButton'),
            inventoryButton: document.getElementById('chatPlayerInventoryButton'),
            name: document.getElementById('chatPlayerName'),
            level: document.getElementById('chatPlayerLevel'),
            archetype: document.getElementById('chatPlayerArchetype'),
            health: document.getElementById('chatPlayerHealth'),
            experience: document.getElementById('chatPlayerExperience'),
            currency: document.getElementById('chatPlayerCurrency'),
            description: document.getElementById('chatPlayerDescription'),
            partyGrid: document.getElementById('chatPartyMembers'),
            partyEmpty: document.getElementById('chatPartyEmpty'),
            partyCount: document.getElementById('chatPartyCount')
        };

        function getLatestPlayerData() {
            const baseData = (window.currentPlayerData && typeof window.currentPlayerData === 'object')
                ? window.currentPlayerData
                : null;
            if (!baseData || !baseData.id) {
                return baseData;
            }
            if (window.currentNpcData instanceof Map) {
                return window.currentNpcData.get(baseData.id) || baseData;
            }
            return baseData;
        }

        if (chatSidebarElements.viewButton) {
            chatSidebarElements.viewButton.addEventListener('click', () => {
                const playerData = getLatestPlayerData();
                if (!playerData || typeof showNpcViewModal !== 'function') {
                    return;
                }
                try {
                    showNpcViewModal(playerData);
                } catch (error) {
                    console.warn('Failed to open player view modal:', error);
                }
            });
        }

        if (chatSidebarElements.inventoryButton) {
            chatSidebarElements.inventoryButton.addEventListener('click', () => {
                const playerData = getLatestPlayerData();
                if (!playerData || typeof showNpcInventoryModal !== 'function') {
                    return;
                }
                try {
                    showNpcInventoryModal(playerData);
                } catch (error) {
                    console.warn('Failed to open player inventory modal:', error);
                }
            });
        }

        function updateChatPlayerPanel(player = {}) {
            if (!chatSidebarElements.card) {
                return;
            }

            const source = (player && typeof player === 'object') ? player : {};
            const previousSnapshot = (window.currentPlayerData && window.currentPlayerData.id === source.id)
                ? window.currentPlayerData
                : null;

            const cloned = cloneActorRecord(source) || { ...source };
            if (cloned) {
                cloned.isPlayer = true;
                cloned.isNPC = false;
            }
            const data = cloned;
            window.currentPlayerData = data;

            const resolvedLocationId = data?.locationId || data?.currentLocation || null;
            if (resolvedLocationId) {
                data.locationId = resolvedLocationId;
                if (!data.currentLocation) {
                    data.currentLocation = resolvedLocationId;
                }
            }

            const name = data?.name || 'Unnamed Adventurer';
            if (chatSidebarElements.name) {
                chatSidebarElements.name.textContent = name;
            }

            const levelLabel = Number.isFinite(data?.level) ? `Level ${data.level}` : 'Level ?';
            if (chatSidebarElements.level) {
                chatSidebarElements.level.textContent = levelLabel;
            }

            const archetypeParts = [];
            if (data?.class) {
                archetypeParts.push(data.class);
            }
            if (data?.race) {
                archetypeParts.push(data.race);
            }
            const archetypeLabel = archetypeParts.length ? archetypeParts.join(' ¬∑ ') : 'Unknown origin';
            if (chatSidebarElements.archetype) {
                chatSidebarElements.archetype.textContent = archetypeLabel;
            }

            const healthCurrent = Number.isFinite(data?.health) ? data.health : '?';
            const healthMaximum = Number.isFinite(data?.maxHealth) ? data.maxHealth : '?';
            if (chatSidebarElements.health) {
                chatSidebarElements.health.textContent = `HP: ${healthCurrent} / ${healthMaximum}`;
            }

            const experienceValue = Number.isFinite(data?.experience) ? data.experience : '?';
            if (chatSidebarElements.experience) {
                chatSidebarElements.experience.textContent = `Exp: ${experienceValue} / 100`;
            }

            const currencyValue = Number.isFinite(data?.currency) ? data.currency : null;
            if (chatSidebarElements.currency) {
                const currencyLabel = resolveCurrencyLabel({ capitalize: true });
                chatSidebarElements.currency.textContent = `${currencyLabel}: ${currencyValue !== null ? currencyValue : '?'}`;
            }

            if (chatSidebarElements.card && data?.id && typeof window.registerInventoryDropTarget === 'function') {
                window.registerInventoryDropTarget(chatSidebarElements.card, { ownerId: data.id, ownerType: 'player' });
            }

            const description = (data?.shortDescription || data?.description || 'No description available.').trim();
            if (chatSidebarElements.description) {
                chatSidebarElements.description.textContent = description;
            }
            updateChatPlayerPointsIndicator(data);

            const portraitElement = chatSidebarElements.portraitImage || chatSidebarElements.portrait;
            if (portraitElement) {
                renderEntityImage({
                    element: portraitElement,
                    entityType: 'player',
                    entityId: data?.id || null,
                    imageId: data?.imageId || null,
                    altText: `${name} portrait`,
                    placeholderIcon: 'üßô',
                    placeholderClass: 'chat-player-placeholder',
                    enableLightbox: true
                });
            }

            if (chatSidebarElements.healthBar) {
                if (name) {
                    chatSidebarElements.healthBar.setAttribute('aria-label', `${name} health`);
                } else {
                    chatSidebarElements.healthBar.removeAttribute('aria-label');
                }
            }

            updateHealthBar(
                chatSidebarElements.healthBar,
                chatSidebarElements.healthBarFill,
                data?.health,
                data?.maxHealth
            );

            if (chatSidebarElements.needBars) {
                renderNeedBars(
                    chatSidebarElements.needBars,
                    Array.isArray(data?.needBars) ? data.needBars : [],
                    {
                        showIcon: true,
                        includePlayerOnly: true,
                        variant: 'player'
                    }
                );
            }

            if (data?.id) {
                if (window.currentNpcData instanceof Map) {
                    window.currentNpcData.set(data.id, cloneActorRecord(data) || { ...data });
                }
                if (typeof window.registerNpcContextMenu === 'function' && chatSidebarElements.card) {
                    window.registerNpcContextMenu(chatSidebarElements.card, { ...data, isNPC: false });
                }
            }

            if (chatSidebarElements.portrait) {
                triggerHealthChangeEffect(chatSidebarElements.portrait, previousSnapshot, data);
            }

            if (chatSidebarElements.viewButton) {
                chatSidebarElements.viewButton.disabled = !data || !data.id;
            }
            if (chatSidebarElements.inventoryButton) {
                chatSidebarElements.inventoryButton.disabled = !data || !data.id;
            }
        }

        function renderChatPartyPanel(members = []) {
            const container = chatSidebarElements.partyGrid;
            const emptyState = chatSidebarElements.partyEmpty;
            const countLabel = chatSidebarElements.partyCount;
            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            if (!container) {
                if (countLabel) {
                    countLabel.textContent = '0';
                }
                return;
            }

            registerPartyDropTarget(container, 'recruit');
            if (emptyState) {
                registerPartyDropTarget(emptyState, 'recruit');
            }

            const safeMembers = Array.isArray(members)
                ? members.filter(member => member && typeof member === 'object')
                : [];
            container.innerHTML = '';

            if (countLabel) {
                countLabel.textContent = String(safeMembers.length);
            }

            if (emptyState) {
                emptyState.style.display = safeMembers.length ? 'none' : 'block';
            }

            container.style.display = safeMembers.length ? 'flex' : 'none';

            const tooltipController = window.floatingTooltipController;

            safeMembers.forEach(member => {
                if (!member) {
                    return;
                }

                const previous = member?.id ? npcDataCache.get(member.id) : null;

                const card = document.createElement('div');
                card.className = 'location-entity-card is-npc';
                if (member?.id) {
                    card.dataset.npcId = member.id;
                }

                const portrait = document.createElement('div');
                portrait.className = 'location-entity-icon';
                const portraitImage = document.createElement('div');
                portraitImage.className = 'location-entity-image';
                portrait.appendChild(portraitImage);

                const { bar: npcHealthBar, fill: npcHealthFill } = createHealthBar('npc-health-bar');
                npcHealthFill.classList.add('npc-health-bar-fill');
                portrait.appendChild(npcHealthBar);

                const npcNeedBars = document.createElement('div');
                npcNeedBars.className = 'npc-need-bars need-bars';
                portrait.appendChild(npcNeedBars);

                renderEntityImage({
                    element: portraitImage,
                    entityType: member.isNPC ? 'npc' : 'player',
                    entityId: member.id || null,
                    imageId: member.imageId || null,
                    altText: member.name || 'Party member portrait',
                    placeholderIcon: 'üé≠',
                    placeholderClass: 'location-entity-placeholder'
                });

                if (npcHealthBar) {
                    if (member?.name) {
                        npcHealthBar.setAttribute('aria-label', `${member.name} health`);
                    } else {
                        npcHealthBar.removeAttribute('aria-label');
                    }
                }

                updateHealthBar(npcHealthBar, npcHealthFill, member?.health, member?.maxHealth);

                renderNeedBars(
                    npcNeedBars,
                    Array.isArray(member?.needBars) ? member.needBars : [],
                    {
                        includePlayerOnly: false,
                        variant: 'npc',
                        compact: true
                    }
                );

                applyNpcDeathStyling(card, portrait, member);

                const nameEl = document.createElement('div');
                nameEl.className = 'location-entity-name';
                nameEl.textContent = member.name || 'Unknown';
                card.appendChild(portrait);
                card.appendChild(nameEl);

                registerNpcPartyDragSource(card, member, 'party');

                const rawDescription = member?.description || member?.shortDescription || '';
                const normalizedDescription = rawDescription
                    .replace(/<[^>]+>/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                const tooltipText = normalizedDescription || 'No description provided.';

                if (tooltipText) {
                    card.setAttribute('aria-label', tooltipText);
                }

                if (tooltipController && typeof tooltipController.show === 'function') {
                    card.addEventListener('mouseenter', (event) => {
                        tooltipController.show(tooltipText, event);
                    });
                    card.addEventListener('mousemove', (event) => {
                        tooltipController.move?.(event);
                    });
                    card.addEventListener('mouseleave', () => {
                        tooltipController.hide?.();
                    });
                    card.addEventListener('click', () => {
                        if (!assignItemToFirstAvailableSlot(clone.id)) {
                            assignItemToCraftingSlot(0, clone.id);
                        }
                    });
                }

                container.appendChild(card);

                if (member?.id) {
                    if (typeof registerNpcContextMenu === 'function') {
                        registerNpcContextMenu(card, member);
                    }
                    triggerHealthChangeEffect(portrait, previous, member);
                    npcDataCache.set(member.id, cloneActorRecord(member) || { ...member });
                    if (typeof window.registerInventoryDropTarget === 'function') {
                        window.registerInventoryDropTarget(card, { ownerId: member.id, ownerType: 'npc' });
                    }
                }
            });
        }


        window.updateChatPlayerPanel = updateChatPlayerPanel;
        window.renderChatPartyPanel = renderChatPartyPanel;

        function processAutoImageElement(element) {
            if (!(element instanceof HTMLElement)) {
                return;
            }

            const entityType = element.dataset.imageEntityType;
            const entityId = element.dataset.imageEntityId;
            if (!entityType || !entityId) {
                return;
            }

            if (element.dataset.imageProcessing === 'true') {
                return;
            }

            const force = element.dataset.imageForce === 'true';
            renderEntityImage({
                element,
                entityType,
                entityId,
                imageId: element.dataset.imageId || null,
                altText: element.dataset.imageAlt || '',
                placeholderIcon: element.dataset.imagePlaceholder || 'üñºÔ∏è',
                placeholderClass: element.dataset.imagePlaceholderClass || 'image-placeholder',
                placeholderMarkup: element.dataset.imagePlaceholderMarkup || null,
                enableLightbox: element.dataset.imageLightbox !== 'false',
                force
            }).finally(() => {
                element.dataset.imageObserved = 'true';
                if (force) {
                    delete element.dataset.imageForce;
                }
            });
        }

        function initializeAutoImagePlaceholders(root = document) {
            if (!root || typeof root.querySelectorAll !== 'function') {
                return;
            }

            const elements = root.querySelectorAll('[data-image-entity-type][data-image-entity-id]');
            elements.forEach(processAutoImageElement);
        }

        initializeAutoImagePlaceholders();

        const autoImageObserver = new MutationObserver(mutations => {
            for (const mutation of mutations) {
                mutation.addedNodes.forEach(node => {
                    if (!(node instanceof HTMLElement)) {
                        return;
                    }

                    if (node.dataset && node.dataset.imageEntityType && node.dataset.imageEntityId) {
                        processAutoImageElement(node);
                    }

                    initializeAutoImagePlaceholders(node);
                });
            }
        });

        try {
            autoImageObserver.observe(document.body, { childList: true, subtree: true });
        } catch (observerError) {
            console.warn('Auto image observer unavailable:', observerError);
        }

        const capitalize = (value) => {
            if (!value) return '';
            const str = String(value).trim();
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        const normalizeThingType = (thing = {}) => {
            const rawType = (thing.thingType || thing.type || thing.category || '').toLowerCase();
            if (!rawType) {
                return 'item';
            }
            if (rawType.includes('scenery')) {
                return 'scenery';
            }
            if (rawType.includes('item')) {
                return 'item';
            }
            return rawType;
        };

        const formatDetailValue = (value) => {
            if (Array.isArray(value)) {
                return value.map(item => escapeHtml(item)).join(', ');
            }
            if (value && typeof value === 'object') {
                try {
                    return escapeHtml(JSON.stringify(value));
                } catch (_) {
                    return escapeHtml(String(value));
                }
            }
            return escapeHtml(value);
        };

        const getAttributeBonuses = (thing = {}) => {
            if (Array.isArray(thing?.attributeBonuses)) {
                return thing.attributeBonuses;
            }
            if (Array.isArray(thing?.metadata?.attributeBonuses)) {
                return thing.metadata.attributeBonuses;
            }
            return [];
        };

        const titleCase = (value) => {
            if (!value) {
                return '';
            }
            return String(value)
                .split(/[\s_-]+/)
                .filter(Boolean)
                .map(part => {
                    const lowered = part.toLowerCase();
                    return lowered.charAt(0).toUpperCase() + lowered.slice(1);
                })
                .join(' ');
        };

        const formatAttributeName = (name = '') => titleCase(name);

        const rarityDefinitions = Array.isArray(window.rarityDefinitions) ? window.rarityDefinitions : [];
        const rarityInfoByKey = new Map();
        const rarityDefinitionByKey = new Map();
        const rarityClassLookup = [];

        const normalizeRarityKey = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value).trim().toLowerCase();
        };

        const raritySlug = (value) => {
            const normalized = normalizeRarityKey(value);
            const slug = normalized.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
            return slug || 'unknown';
        };

        const rarityStyleRules = [];
        rarityDefinitions.forEach((definition) => {
            if (!definition) {
                return;
            }
            const normalizedKey = normalizeRarityKey(definition.key || definition.label);
            if (!normalizedKey || rarityInfoByKey.has(normalizedKey)) {
                return;
            }
            const className = `rarity-${raritySlug(normalizedKey)}`;
            const label = definition.label || titleCase(normalizedKey);
            const color = typeof definition.color === 'string' && definition.color.trim() ? definition.color.trim() : null;
            const info = { key: normalizedKey, className, label, color };

            rarityInfoByKey.set(normalizedKey, info);
            rarityClassLookup.push(info);
            rarityDefinitionByKey.set(normalizedKey, definition);

            if (color) {
                rarityStyleRules.push(`.${className} { color: ${color}; }`);
                rarityStyleRules.push(`#thingEditRarity option.${className} { color: ${color}; }`);
            }
        });

        if (rarityStyleRules.length) {
            const styleElementId = 'dynamic-rarity-styles';
            let styleElement = document.getElementById(styleElementId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleElementId;
                document.head.appendChild(styleElement);
            }
            styleElement.textContent = rarityStyleRules.join('\n');
        }

        const availableSlotTypes = window.availableSlotTypes instanceof Set ? window.availableSlotTypes : new Set();
        window.availableSlotTypes = availableSlotTypes;

        const attributeOptions = Array.isArray(window.availableAttributes) ? window.availableAttributes : [];
        window.availableAttributes = attributeOptions;
        let attributeDefinitionsCache = typeof window.attributeDefinitionsMap === 'object' && window.attributeDefinitionsMap
            ? window.attributeDefinitionsMap
            : {};
        window.attributeDefinitionsMap = attributeDefinitionsCache;

        const getRarityLabel = (key) => {
            const normalized = normalizeRarityKey(key);
            if (!normalized) {
                return '';
            }
            const info = rarityInfoByKey.get(normalized);
            if (info && info.label) {
                return info.label;
            }
            return titleCase(normalized);
        };

        const getRarityDamageMultiplier = (rarityKey) => {
            const normalized = normalizeRarityKey(rarityKey);
            if (!normalized) {
                throw new Error('Weapon rarity is required to calculate base damage.');
            }
            const definition = rarityDefinitionByKey.get(normalized);
            if (!definition) {
                throw new Error(`Unknown weapon rarity "${rarityKey}".`);
            }
            const multiplier = Number(definition.damageMultiplier);
            if (!Number.isFinite(multiplier)) {
                throw new Error(`Weapon rarity "${rarityKey}" is missing a damage multiplier.`);
            }
            return multiplier;
        };

        const getBaseWeaponDamageValue = () => {
            const baseDamage = Number(runtimeConfig?.baseWeaponDamage);
            if (!Number.isFinite(baseDamage)) {
                throw new Error('runtimeConfig.baseWeaponDamage must be a finite number.');
            }
            return baseDamage;
        };

        const getMinimumUnmitigatedWeaponDamage = ({ rarity, level }) => {
            const normalizedLevel = Number(level);
            if (!Number.isFinite(normalizedLevel)) {
                throw new Error('Weapon level must be a finite number.');
            }
            if (normalizedLevel < 1) {
                throw new Error('Weapon level must be at least 1.');
            }
            const damageMultiplier = getRarityDamageMultiplier(rarity);
            const baseDamage = getBaseWeaponDamageValue() + normalizedLevel * damageMultiplier;
            const hitDegreeMultiplier = 0.75;
            const preRoundedDamage = baseDamage * hitDegreeMultiplier;
            const roundedDamageComponent = Math.round(preRoundedDamage);
            const constantBonus = 1;
            return constantBonus + roundedDamageComponent;
        };

        const isEquippableThing = (thing = {}) => {
            const slotValue = typeof thing.slot === 'string'
                ? thing.slot
                : (typeof thing.metadata?.slot === 'string' ? thing.metadata.slot : '');
            const normalizedSlot = normalizeSlotType(slotValue);
            if (!normalizedSlot) {
                return false;
            }
            return normalizedSlot !== 'n/a' && normalizedSlot !== 'none';
        };

        const isWeaponThing = (thing = {}) => {
            const typeCandidates = [
                thing.type,
                thing.itemTypeDetail,
                thing.category,
                thing.metadata?.type,
                thing.metadata?.itemTypeDetail,
                thing.metadata?.category
            ];
            const slotCandidates = [
                thing.slot,
                thing.metadata?.slot
            ];
            const hasWeaponType = [...typeCandidates, ...slotCandidates].some(value => {
                if (typeof value !== 'string') {
                    return false;
                }
                return tokenizeForMatch(value).includes(' weapon ');
            });
            if (hasWeaponType) {
                return true;
            }
            const hasToolType = typeCandidates.some(value => {
                if (typeof value !== 'string') {
                    return false;
                }
                return tokenizeForMatch(value).includes(' tool ');
            });
            if (!hasToolType) {
                return false;
            }
            return isEquippableThing(thing);
        };

        const normalizeSlotType = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value).trim().toLowerCase();
        };

        const formatSlotTypeLabel = (slotType) => titleCase(slotType);

        const addAvailableSlotType = (value) => {
            const normalized = normalizeSlotType(value);
            if (!normalized || normalized === 'n/a' || normalized === 'none') {
                return;
            }
            availableSlotTypes.add(normalized);
        };

        const trackSlotTypeFromThing = (thing = {}) => {
            if (!thing) {
                return;
            }
            const directSlot = typeof thing.slot === 'string' ? thing.slot : null;
            const metadataSlot = typeof thing.metadata?.slot === 'string' ? thing.metadata.slot : null;
            if (directSlot) {
                addAvailableSlotType(directSlot);
            } else if (metadataSlot) {
                addAvailableSlotType(metadataSlot);
            }
        };

        const updateAvailableSlotTypesFromPlayer = (player = {}) => {
            const gearSlotsByType = player && typeof player.gearSlotsByType === 'object' ? player.gearSlotsByType : null;
            if (gearSlotsByType) {
                Object.keys(gearSlotsByType).forEach(addAvailableSlotType);
            }

            const gear = player && typeof player.gear === 'object' ? player.gear : null;
            if (gear) {
                Object.values(gear).forEach(slot => {
                    if (slot && slot.slotType) {
                        addAvailableSlotType(slot.slotType);
                    }
                });
            }

            const inventory = Array.isArray(player.inventory) ? player.inventory : [];
            inventory.forEach(trackSlotTypeFromThing);
        };

        let attributeOptionsLoaded = attributeOptions.length > 0;
        let attributeFetchPromise = null;

        function refreshAllAttributeSelects() {
            if (!thingEditForm) {
                return;
            }
            const selects = thingEditForm.querySelectorAll('.thing-edit-bonus-attribute');
            selects.forEach(select => {
                const currentValue = select?.value || '';
                populateAttributeSelect(select, currentValue);
            });
        }

        function ensureAttributeDefinitions() {
            if (attributeOptionsLoaded) {
                return Promise.resolve(attributeOptions);
            }
            if (attributeFetchPromise) {
                return attributeFetchPromise;
            }

            attributeFetchPromise = (async () => {
                try {
                    const response = await fetch('/api/attributes');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    if (!data?.success || !Array.isArray(data.attributes)) {
                        if (!data?.success || !data.attributes) {
                            throw new Error(data?.error || 'Failed to load attribute definitions');
                        }
                        if (data.attributes && typeof data.attributes === 'object') {
                            data.attributes = Object.entries(data.attributes).map(([key, def]) => ({
                                key,
                                label: def?.label || titleCase(key),
                                description: def?.description || '',
                                abbreviation: def?.abbreviation || ''
                            }));
                        }
                        if (!Array.isArray(data.attributes)) {
                            throw new Error(data?.error || 'Failed to load attribute definitions');
                        }
                    }

                    attributeOptions.length = 0;
                    attributeDefinitionsCache = {};
                    window.attributeDefinitionsMap = attributeDefinitionsCache;

                    data.attributes.forEach(attr => {
                        if (!attr || !attr.key) {
                            return;
                        }
                        const key = String(attr.key).trim();
                        if (!key) {
                            return;
                        }
                        const entry = {
                            key,
                            keyLower: key.toLowerCase(),
                            label: attr.label || titleCase(key),
                            description: attr.description || '',
                            abbreviation: attr.abbreviation || ''
                        };
                        attributeOptions.push(entry);
                        attributeDefinitionsCache[key] = entry;
                    });

                    attributeOptionsLoaded = attributeOptions.length > 0;
                    refreshAllAttributeSelects();
                    return attributeOptions;
                } catch (error) {
                    console.warn('Failed to fetch attribute definitions:', error);
                    return [];
                } finally {
                    attributeFetchPromise = null;
                }
            })();

            return attributeFetchPromise;
        }

        let gearSlotTypesLoaded = availableSlotTypes.size > 0;
        let gearSlotTypesPromise = null;
        let loadGameSaves = [];
        let loadGameFetchToken = 0;
        let currentLoadGameSource = 'saves';
        let loadGameTriggerButton = null;

        function ensureGearSlotTypes() {
            if (gearSlotTypesLoaded) {
                return Promise.resolve(availableSlotTypes);
            }
            if (gearSlotTypesPromise) {
                return gearSlotTypesPromise;
            }
            gearSlotTypesPromise = (async () => {
                try {
                    const response = await fetch('/api/gear-slots');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    if (!data?.success) {
                        throw new Error(data?.error || 'Failed to load gear slot definitions');
                    }

                    if (Array.isArray(data.slotTypes)) {
                        data.slotTypes.forEach(addAvailableSlotType);
                    }

                    gearSlotTypesLoaded = availableSlotTypes.size > 0;
                    return data;
                } catch (error) {
                    console.warn('Failed to fetch gear slot definitions:', error);
                    return null;
                } finally {
                    gearSlotTypesPromise = null;
                }
            })();
            return gearSlotTypesPromise;
        }

        ensureGearSlotTypes();
        ensureAttributeDefinitions();

        const getRarityClass = (rarity) => {
            if (!rarity && rarity !== 0) {
                return '';
            }
            const normalized = normalizeRarityKey(rarity);
            if (!normalized) {
                return '';
            }
            for (const entry of rarityClassLookup) {
                if (normalized === entry.key) {
                    return entry.className;
                }
            }

            const normalizedTokens = tokenizeForMatch(normalized);
            if (!normalizedTokens) {
                return '';
            }

            for (const entry of rarityClassLookup) {
                if (!entry.key) {
                    continue;
                }
                const entryTokens = tokenizeForMatch(entry.key);
                if (entryTokens && normalizedTokens.includes(entryTokens)) {
                    return entry.className;
                }
            }
            return '';
        };

        const applyRarityClass = (element, rarity) => {
            if (!element) {
                return;
            }
            const rarityClass = getRarityClass(rarity);
            if (rarityClass) {
                element.classList.add(rarityClass);
            }
        };

        const thingDataCache = window.currentThingData instanceof Map ? window.currentThingData : new Map();
        window.currentThingData = thingDataCache;
        const pendingThingRequests = new Map();

        async function fetchThingDetails(thingId) {
            if (!thingId) {
                return null;
            }

            if (thingDataCache.has(thingId)) {
                return thingDataCache.get(thingId);
            }

            if (pendingThingRequests.has(thingId)) {
                return pendingThingRequests.get(thingId);
            }

            const request = fetch(`/api/things/${encodeURIComponent(thingId)}`, {
                cache: 'no-store'
            }).then(async response => {
                try {
                    const data = await response.json();
                    if (data?.success && data.thing) {
                        cacheThingData(data.thing);
                        return data.thing;
                    }
                } catch (error) {
                    console.warn('Failed to parse thing details:', error);
                }
                return null;
            }).catch(error => {
                console.warn(`Failed to load thing ${thingId}:`, error);
                return null;
            }).finally(() => {
                pendingThingRequests.delete(thingId);
            });

            pendingThingRequests.set(thingId, request);
            return request;
        }

        const thingMenuState = { openMenu: null, trigger: null, card: null };
        let thingMenuListenersAttached = false;

        function attachThingMenuListeners() {
            if (thingMenuListenersAttached) {
                return;
            }
            document.addEventListener('click', () => {
                if (thingMenuState.openMenu) {
                    closeThingContextMenu();
                }
            });
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeThingContextMenu();
                }
            });
            thingMenuListenersAttached = true;
        }

        function cacheThingData(thing) {
            if (!thing || !thing.id) {
                return;
            }
            thingDataCache.set(thing.id, { ...thing });
            trackSlotTypeFromThing(thing);
        }

        function closeThingContextMenu() {
            if (thingMenuState.openMenu) {
                thingMenuState.openMenu.classList.remove('is-open');
            }
            if (thingMenuState.trigger) {
                thingMenuState.trigger.setAttribute('aria-expanded', 'false');
            }
            if (thingMenuState.card) {
                thingMenuState.card.classList.remove('context-menu-open');
            }
            thingMenuState.openMenu = null;
            thingMenuState.trigger = null;
            thingMenuState.card = null;
        }

        function updateLocationThingReference(thingId, updater) {
            if (!lastRenderedLocation || typeof updater !== 'function') {
                return;
            }
            const collection = Array.isArray(lastRenderedLocation.things)
                ? lastRenderedLocation.things
                : [];
            const target = collection.find(entry => entry && entry.id === thingId);
            if (target) {
                try {
                    updater(target);
                } catch (error) {
                    console.warn('Failed to update location thing reference:', error);
                }
            }
        }

        async function dropThingToCurrentLocation(thing, options = {}) {
            if (!thing || !thing.id) {
                throw new Error('Missing item information.');
            }

            const playerId = window.currentPlayerData?.id || null;
            const ownerIdCandidate = options.npcId || null;
            let ownerId = ownerIdCandidate || null;
            let ownerType = null;

            if (ownerId && playerId && ownerId === playerId) {
                ownerType = 'player';
            } else if (ownerId) {
                ownerType = 'npc';
            } else if (playerId) {
                ownerType = 'player';
                ownerId = playerId;
            }

            const normalizeId = (value) => {
                if (typeof value !== 'string') {
                    return null;
                }
                const trimmed = value.trim();
                return trimmed || null;
            };

            let locationId = options.locationId || null;
            const ownerData = ownerId && window.currentNpcData instanceof Map
                ? window.currentNpcData.get(ownerId)
                : null;
            if (!locationId && ownerData) {
                locationId = ownerData.currentLocation || ownerData.locationId || null;
            }
            if (!locationId && window.lastRenderedLocation?.id) {
                locationId = window.lastRenderedLocation.id;
            }
            if (!locationId && window.currentPlayerData?.currentLocation) {
                locationId = window.currentPlayerData.currentLocation;
            }

            const payload = {};
            if (ownerId) {
                payload.ownerId = ownerId;
            }
            if (ownerType) {
                payload.ownerType = ownerType;
            }
            locationId = normalizeId(locationId);
            if (locationId) {
                payload.locationId = locationId;
            }

            const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}/drop`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json().catch(() => ({}));

            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            const droppedThing = result.thing || thing;
            thingDataCache.set(droppedThing.id, droppedThing);

            if (result.owner && result.owner.id) {
                if (window.currentNpcData instanceof Map) {
                    window.currentNpcData.set(result.owner.id, result.owner);
                }

                if (playerId && result.owner.id === playerId) {
                    window.currentPlayerData = { ...window.currentPlayerData, ...result.owner };
                    try {
                        await window.refreshInventory?.();
                    } catch (inventoryError) {
                        console.warn('Failed to refresh inventory after drop:', inventoryError);
                    }
                }
            } else if (ownerType === 'player') {
                try {
                    await window.refreshInventory?.();
                } catch (inventoryError) {
                    console.warn('Failed to refresh inventory after drop:', inventoryError);
                }
            }

            if (options.context === 'npc-inventory' && Array.isArray(currentNpcInventory)) {
                currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                renderNpcInventory(currentNpcInventory);
            }

            if (options.context === 'npc-equipment' && typeof currentNpcViewId !== 'undefined') {
                const viewId = currentNpcViewId;
                const refreshedNpc = (result.owner && result.owner.id === viewId)
                    ? result.owner
                    : (window.currentNpcData instanceof Map ? window.currentNpcData.get(viewId) : null);
                if (refreshedNpc && typeof showNpcViewModal === 'function') {
                    showNpcViewModal(refreshedNpc);
                }
            }

            if (result.location) {
                try {
                    await window.updateLocationDisplay?.(result.location);
                    window.lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                } catch (locationError) {
                    console.warn('Failed to update location display after drop:', locationError);
                    try {
                        await window.loadCurrentLocation?.();
                    } catch (_) {}
                }
            } else {
                try {
                    await window.loadCurrentLocation?.();
                } catch (locationError) {
                    console.warn('Failed to reload location after drop:', locationError);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (partyError) {
                console.warn('Failed to refresh party after drop:', partyError);
            }

            return result;
        }

        async function moveThingToInventory(thing, { ownerId = null, ownerType = 'npc', locationId = null } = {}) {
            if (!thing || !thing.id) {
                throw new Error('Missing item information.');
            }
            if (!ownerId) {
                throw new Error('Owner identifier is required.');
            }

            const payload = {
                ownerId,
                ownerType
            };
            if (locationId) {
                payload.locationId = locationId;
            }

            const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}/give`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json().catch(() => ({}));
            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            const ownerData = result.owner || null;
            if (ownerData) {
                if (ownerType === 'npc' && window.currentNpcData instanceof Map) {
                    window.currentNpcData.set(ownerData.id, ownerData);
                }
                if (ownerType === 'player' && window.currentPlayerData && ownerData.id === window.currentPlayerData.id) {
                    window.currentPlayerData = ownerData;
                }
            }

            const updatedThing = result.thing || thing;
            thingDataCache.set(updatedThing.id, updatedThing);

            if (window.lastRenderedLocation && locationId && window.lastRenderedLocation.id === locationId) {
                if (Array.isArray(window.lastRenderedLocation.things)) {
                    window.lastRenderedLocation.things = window.lastRenderedLocation.things.filter(entry => entry && entry.id !== thing.id);
                }
                if (Array.isArray(window.lastRenderedLocation.thingIds)) {
                    window.lastRenderedLocation.thingIds = window.lastRenderedLocation.thingIds.filter(id => id !== thing.id);
                }
            }

            if (ownerData && currentNpcInventoryNpcId && ownerData.id === currentNpcInventoryNpcId) {
                const updatedInventory = Array.isArray(ownerData.inventory) ? ownerData.inventory : [];
                currentNpcInventory = updatedInventory;
                renderNpcInventory(updatedInventory);
            }

            if (ownerData && currentNpcViewId && ownerData.id === currentNpcViewId && typeof showNpcViewModal === 'function') {
                showNpcViewModal(ownerData);
            }

            if (locationId && window.lastRenderedLocation && (window.lastRenderedLocation.id === locationId)) {
                try {
                    if (result.location) {
                        await window.updateLocationDisplay?.(result.location);
                        window.lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                    } else {
                        await window.loadCurrentLocation?.();
                    }
                } catch (error) {
                    console.warn('Failed to update location after moving item to inventory:', error);
                }
            } else if (result.location && result.location.id && window.lastRenderedLocation && window.lastRenderedLocation.id === result.location.id) {
                try {
                    await window.updateLocationDisplay?.(result.location);
                    window.lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                } catch (error) {
                    console.warn('Failed to refresh location after moving item to inventory:', error);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (partyError) {
                console.warn('Failed to refresh party after moving item to inventory:', partyError);
            }

            return result;
        }

        async function moveThingToNpcInventory(thing, npcId, { locationId = null } = {}) {
            return moveThingToInventory(thing, { ownerId: npcId, ownerType: 'npc', locationId });
        }

        let teleportLocationOptionsCache = null;
        let teleportLocationOptionsPromise = null;

        async function loadTeleportLocationOptions() {
            if (Array.isArray(teleportLocationOptionsCache)) {
                return teleportLocationOptionsCache;
            }
            if (teleportLocationOptionsPromise) {
                return teleportLocationOptionsPromise;
            }

            teleportLocationOptionsPromise = (async () => {
                try {
                    const response = await fetch('/api/locations?scope=named', { cache: 'no-store' });
                    const data = await response.json().catch(() => ({}));
                    if (!response.ok || !data?.success || !Array.isArray(data.locations)) {
                        throw new Error(data?.error || `HTTP ${response.status}`);
                    }

                    const normalized = data.locations
                        .filter(entry => entry && entry.id && typeof entry.label === 'string' && entry.label.trim())
                        .map(entry => ({
                            id: entry.id,
                            label: entry.label.trim(),
                            normalizedLabel: entry.label.trim().toLowerCase()
                        }))
                        .sort((a, b) => a.normalizedLabel.localeCompare(b.normalizedLabel));

                    teleportLocationOptionsCache = normalized;
                    return normalized;
                } catch (error) {
                    console.warn('Failed to load teleport destinations:', error);
                    return [];
                } finally {
                    teleportLocationOptionsPromise = null;
                }
            })();

            return teleportLocationOptionsPromise;
        }

        function invalidateTeleportLocationCache() {
            teleportLocationOptionsCache = null;
        }

        async function applyTeleportLocationUpdate(locationPayload) {
            if (!locationPayload || !locationPayload.id) {
                return false;
            }
            if (!window.lastRenderedLocation || window.lastRenderedLocation.id !== locationPayload.id) {
                return false;
            }
            try {
                await window.updateLocationDisplay?.(locationPayload);
                window.lastRenderedLocation = JSON.parse(JSON.stringify(locationPayload));
                return true;
            } catch (error) {
                console.warn('Failed to apply location update after teleport:', error);
                return false;
            }
        }

        async function teleportThingToLocation(thing, destinationLocationId, { context = 'general', card = null, npcId = null, originLocationId = null } = {}) {
            if (!thing || !thing.id) {
                throw new Error('Missing item information.');
            }
            if (!destinationLocationId) {
                throw new Error('Destination location is required.');
            }

            const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}/teleport`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locationId: destinationLocationId })
            });

            const result = await response.json().catch(() => ({}));
            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            invalidateTeleportLocationCache();

            const updatedThing = result.thing || thing;
            thingDataCache.set(updatedThing.id, updatedThing);

            const removedOwnerIds = Array.isArray(result.removedOwnerIds) ? result.removedOwnerIds : [];

            const updateNpcInventoryCache = (targetNpcId) => {
                if (!targetNpcId) {
                    return;
                }
                if (currentNpcInventoryNpcId && targetNpcId === currentNpcInventoryNpcId && Array.isArray(currentNpcInventory)) {
                    currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                    renderNpcInventory(currentNpcInventory);
                }
                if (window.currentNpcData instanceof Map && window.currentNpcData.has(targetNpcId)) {
                    const npcRecord = window.currentNpcData.get(targetNpcId);
                    if (npcRecord && Array.isArray(npcRecord.inventory)) {
                        npcRecord.inventory = npcRecord.inventory.filter(item => item && item.id !== thing.id);
                        window.currentNpcData.set(targetNpcId, npcRecord);
                        if (currentNpcViewId === targetNpcId && typeof showNpcViewModal === 'function') {
                            showNpcViewModal(npcRecord);
                        }
                    }
                }
            };

            removedOwnerIds.forEach(updateNpcInventoryCache);

            if (npcId) {
                updateNpcInventoryCache(npcId);
            }

            const activeContext = context || 'general';

            if (activeContext === 'npc-inventory' && Array.isArray(currentNpcInventory)) {
                currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                renderNpcInventory(currentNpcInventory);
            }

            if (activeContext === 'npc-equipment' && card && card.parentElement) {
                card.remove();
            }

            if (card && card.parentElement && activeContext === 'location') {
                const destinationId = result.destination?.id || null;
                if (!destinationId || destinationId !== (window.lastRenderedLocation?.id || null)) {
                    card.remove();
                    const container = card.parentElement;
                    const hasRemainingCards = container.querySelector('.location-entity-card');
                    if (!hasRemainingCards) {
                        const emptyMessage = container.id === 'locationScenery'
                            ? 'No notable scenery present.'
                            : 'No notable items present.';
                        container.innerHTML = `<div class="location-thing-empty">${emptyMessage}</div>`;
                    }
                }
            }

            if (card && card.parentElement && !['location', 'npc-equipment', 'npc-inventory'].includes(activeContext)) {
                card.remove();
            }

            const currentPlayerId = window.currentPlayerData?.id || null;
            if (currentPlayerId && removedOwnerIds.includes(currentPlayerId)) {
                try {
                    await window.refreshInventory?.();
                } catch (error) {
                    console.warn('Failed to refresh player inventory after teleport:', error);
                }
            }

            if (result.previousLocation) {
                await applyTeleportLocationUpdate(result.previousLocation);
            }
            if (result.destination) {
                await applyTeleportLocationUpdate(result.destination);
            }

            const currentLocationId = window.lastRenderedLocation?.id || null;
            const destinationId = result.destination?.id || null;
            const shouldReload = (
                (originLocationId && originLocationId === currentLocationId)
                || (destinationId && destinationId === currentLocationId)
            );

            if (shouldReload) {
                try {
                    await window.loadCurrentLocation?.();
                } catch (error) {
                    console.warn('Failed to reload current location after teleport:', error);
                }
            }

            if (activeContext === 'player-inventory' && (!currentPlayerId || !removedOwnerIds.includes(currentPlayerId))) {
                try {
                    await window.refreshInventory?.();
                } catch (error) {
                    console.warn('Failed to refresh player inventory after teleport:', error);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (error) {
                console.warn('Failed to refresh party after teleport:', error);
            }

            return result;
        }

        async function teleportNpcToLocation(npc, destinationLocationId, { card = null, originLocationId = null } = {}) {
            if (!npc || !npc.id) {
                throw new Error('Missing character information.');
            }
            if (!destinationLocationId) {
                throw new Error('Destination location is required.');
            }

            const npcId = npc.id;
            const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}/teleport`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locationId: destinationLocationId })
            });

            const result = await response.json().catch(() => ({}));
            if (!response.ok || !result?.success) {
                throw new Error(result?.error || `Request failed with status ${response.status}`);
            }

            const updatedNpc = result.npc || npc;
            if (window.currentNpcData instanceof Map) {
                window.currentNpcData.set(updatedNpc.id, cloneActorRecord(updatedNpc) || { ...updatedNpc });
            }

            if (updatedNpc && !updatedNpc.isNPC && typeof updateChatPlayerPanel === 'function') {
                updateChatPlayerPanel(updatedNpc);
            }

            const destinationId = result.destination?.id || null;
            const currentLocationId = window.lastRenderedLocation?.id || null;
            if (npc?.isNPC && card && card.parentElement) {
                if (!destinationId || destinationId !== currentLocationId) {
                    card.remove();
                }
            }

            let applied = false;
            if (result.previousLocation) {
                applied = await applyTeleportLocationUpdate(result.previousLocation) || applied;
            }
            if (result.destination) {
                applied = await applyTeleportLocationUpdate(result.destination) || applied;
            }

            const shouldReload = (!applied && (
                (originLocationId && originLocationId === currentLocationId)
                || (destinationId && destinationId === currentLocationId)
            ));

            if (shouldReload && typeof window.loadCurrentLocation === 'function') {
                try {
                    await window.loadCurrentLocation();
                } catch (error) {
                    console.warn('Failed to refresh current location after teleporting NPC:', error);
                }
            }

            try {
                await window.refreshParty?.();
            } catch (error) {
                console.warn('Failed to refresh party after teleporting NPC:', error);
            }

            if (updatedNpc && !updatedNpc.isNPC) {
                if (result.destination) {
                    try {
                        await window.updateLocationDisplay?.(result.destination);
                        window.lastRenderedLocation = JSON.parse(JSON.stringify(result.destination));
                    } catch (error) {
                        console.warn('Failed to refresh destination location after teleporting player:', error);
                    }
                } else {
                    try {
                        await window.loadCurrentLocation?.();
                    } catch (error) {
                        console.warn('Failed to load current location after teleporting player:', error);
                    }
                }
            }

            invalidateTeleportLocationCache();

            return result;
        }

        async function showTeleportLocationModal(thing, { context = 'general', card = null, locationId = null, npcId = null, npc = null } = {}) {
            const options = await loadTeleportLocationOptions();
            if (!Array.isArray(options) || !options.length) {
                alert('No named locations are currently available to teleport to.');
                return;
            }

            const modal = document.createElement('div');
            modal.className = 'npc-selection-modal';

            const backdrop = document.createElement('div');
            backdrop.className = 'npc-selection-backdrop';

            const dialog = document.createElement('div');
            dialog.className = 'npc-selection-dialog';

            const header = document.createElement('div');
            header.className = 'npc-selection-header';
            const title = document.createElement('h2');
            title.textContent = npcId ? 'Teleport Character' : 'Teleport Item';
            header.appendChild(title);

            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.className = 'npc-selection-close';
            closeBtn.textContent = 'üóô';
            closeBtn.setAttribute('aria-label', 'Close');
            header.appendChild(closeBtn);

            const body = document.createElement('div');
            body.className = 'npc-selection-body';

            const filterWrapper = document.createElement('div');
            filterWrapper.className = 'npc-selection-filter';

            const filterInput = document.createElement('input');
            filterInput.type = 'search';
            filterInput.className = 'npc-selection-filter-input';
            filterInput.placeholder = 'Filter locations';
            filterInput.setAttribute('aria-label', 'Filter locations by name');
            filterWrapper.appendChild(filterInput);
            body.appendChild(filterWrapper);

            const list = document.createElement('ul');
            list.className = 'npc-selection-list';
            body.appendChild(list);

            const decoratedOptions = options.map(entry => ({
                id: entry.id,
                label: entry.label,
                normalizedLabel: entry.normalizedLabel || entry.label.toLowerCase()
            }));

            const renderTeleportOptions = (filterValue = '') => {
                const normalizedFilter = filterValue.trim().toLowerCase();
                list.textContent = '';

                const filteredEntries = normalizedFilter
                    ? decoratedOptions.filter(entry => entry.normalizedLabel.includes(normalizedFilter))
                    : decoratedOptions;

                filteredEntries.forEach(entry => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'npc-selection-item';
                    button.textContent = entry.label;
                    button.dataset.locationId = entry.id;

                    const li = document.createElement('li');
                    li.appendChild(button);
                    list.appendChild(li);
                });
            };

            renderTeleportOptions();

            filterInput.addEventListener('input', () => {
                renderTeleportOptions(filterInput.value);
            });

            const footer = document.createElement('div');
            footer.className = 'npc-selection-footer';
            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'npc-selection-cancel';
            cancelBtn.textContent = 'Cancel';
            footer.appendChild(cancelBtn);

            dialog.appendChild(header);
            dialog.appendChild(body);
            dialog.appendChild(footer);
            modal.appendChild(backdrop);
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            document.body.classList.add('modal-open');

            const cleanup = () => {
                document.body.classList.remove('modal-open');
                modal.remove();
            };

            let isProcessing = false;

            const handleSelection = async (targetLocationId, triggerButton) => {
                if (!targetLocationId || isProcessing) {
                    return;
                }
                isProcessing = true;
                if (triggerButton) {
                    triggerButton.disabled = true;
                }

                let overlayVisible = false;
                try {
                    showLocationOverlay('Teleporting...');
                    overlayVisible = true;
                } catch (_) {
                    // ignore overlay errors
                }

                try {
                    if (npcId) {
                        const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                        const resolvedNpc = npc
                            || (npcDataCache ? (npcDataCache.get(npcId) || null) : null)
                            || { id: npcId };

                        await teleportNpcToLocation(resolvedNpc, targetLocationId, {
                            card,
                            originLocationId: locationId || (window.lastRenderedLocation?.id || null)
                        });
                    } else {
                        if (!thing || !thing.id) {
                            throw new Error('Item data unavailable for teleportation.');
                        }
                        await teleportThingToLocation(thing, targetLocationId, {
                            context,
                            card,
                            npcId,
                            originLocationId: locationId || (window.lastRenderedLocation?.id || null)
                        });
                    }
                    cleanup();
                } catch (error) {
                    console.warn('Failed to teleport entity:', error);
                    alert(`Failed to teleport ${npcId ? 'character' : 'item'}: ${error?.message || error}`);
                    if (triggerButton) {
                        triggerButton.disabled = false;
                    }
                } finally {
                    isProcessing = false;
                    if (overlayVisible) {
                        hideLocationOverlay();
                    }
                }
            };

            closeBtn.addEventListener('click', cleanup);
            cancelBtn.addEventListener('click', cleanup);
            backdrop.addEventListener('click', cleanup);
            list.addEventListener('click', (event) => {
                if (!(event.target instanceof HTMLButtonElement)) {
                    return;
                }
                const targetId = event.target.dataset.locationId || null;
                handleSelection(targetId, event.target);
            });
        }

        function registerThingContextMenu(card, thing, options = {}) {
            if (!card || !thing || !thing.id) {
                return;
            }

            attachThingMenuListeners();
            cacheThingData(thing);

            const thingIdString = String(thing.id);
            if (card.dataset.thingMenuAttached === 'true' && card.dataset.thingId === thingIdString) {
                return;
            }

            const existingButton = card.querySelector('.thing-card-menu-button');
            const existingMenu = card.querySelector('.thing-card-menu');
            existingButton?.remove();
            existingMenu?.remove();

            card.dataset.thingId = thingIdString;
            card.dataset.thingMenuAttached = 'true';

            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'thing-card-menu-button';
            button.setAttribute('aria-haspopup', 'true');
            button.setAttribute('aria-expanded', 'false');
            button.setAttribute('aria-label', `More actions for ${thing.name || 'item'}`);

            const icon = document.createElement('span');
            icon.setAttribute('aria-hidden', 'true');
            icon.textContent = '‚Ä¢‚Ä¢‚Ä¢';
            button.appendChild(icon);

            const menu = document.createElement('div');
            menu.className = 'thing-card-menu';

            const editButton = document.createElement('button');
            editButton.type = 'button';
            editButton.className = 'thing-card-menu-item';
            editButton.textContent = 'Edit';
            menu.appendChild(editButton);

            let regenerateImageButton = null;
            const imageGenerationEnabled = runtimeConfig?.imagegen?.enabled !== false;
            if (imageGenerationEnabled) {
                regenerateImageButton = document.createElement('button');
                regenerateImageButton.type = 'button';
                regenerateImageButton.className = 'thing-card-menu-item';
                regenerateImageButton.textContent = 'Regenerate Image';
                menu.appendChild(regenerateImageButton);
            }

            const canDrop = options.context === 'npc-inventory' || options.context === 'npc-equipment';
            let dropButton = null;
            if (canDrop) {
                dropButton = document.createElement('button');
                dropButton.type = 'button';
                dropButton.className = 'thing-card-menu-item';
                dropButton.textContent = 'Drop';
                menu.appendChild(dropButton);
            }

            const canPickup = true;
            let pickupButton = null;
            if (canPickup) {
                pickupButton = document.createElement('button');
                pickupButton.type = 'button';
                pickupButton.className = 'thing-card-menu-item';
                pickupButton.textContent = 'Put in Inventory';
                menu.appendChild(pickupButton);
            }

            const teleportButton = document.createElement('button');
            teleportButton.type = 'button';
            teleportButton.className = 'thing-card-menu-item';
            teleportButton.textContent = 'Teleport';
            menu.appendChild(teleportButton);

            const allowDeletion = Boolean(options.allowDelete ?? true);
            let deleteButton = null;
            if (allowDeletion) {
                deleteButton = document.createElement('button');
                deleteButton.type = 'button';
                deleteButton.className = 'thing-card-menu-item thing-card-menu-item--danger';
                deleteButton.textContent = 'Delete';
                menu.appendChild(deleteButton);
            }

            button.addEventListener('click', (event) => {
                event.stopPropagation();
                const wasOpen = thingMenuState.openMenu === menu;
                closeThingContextMenu();
                if (!wasOpen) {
                    menu.classList.add('is-open');
                    button.setAttribute('aria-expanded', 'true');
                    thingMenuState.openMenu = menu;
                    thingMenuState.trigger = button;
                    thingMenuState.card = card;
                    card.classList.add('context-menu-open');
                }
            });

            editButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeThingContextMenu();
                const cachedThing = thingDataCache.get(thing.id) || thing;
                try {
                    await showThingEditModal(cachedThing, options.context || 'general');
                } catch (error) {
                    console.warn('Failed to open thing editor:', error);
                }
            });

            if (regenerateImageButton) {
                regenerateImageButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeThingContextMenu();

                    const cachedThing = { ...(thingDataCache.get(thing.id) || thing) };
                    const entityId = String(cachedThing?.id || '');
                    if (!entityId) {
                        console.warn('Unable to regenerate image: missing thing identifier.');
                        return;
                    }

                    const context = options.context || 'general';
                    const locationId = options.locationId || null;
                    const npcId = options.npcId || null;
                    const previousImageId = cachedThing.imageId || null;
                    const placeholderAlt = cachedThing.name || 'Location item';

                    applyEntityImagePlaceholder('thing', entityId);

                    const updatedThing = {
                        ...cachedThing,
                        imageId: null,
                        imageJobId: null,
                        pendingImageJobId: null
                    };
                    thingDataCache.set(thing.id, updatedThing);
                    thing.imageId = null;
                    thing.imageJobId = null;
                    thing.pendingImageJobId = null;
                    updateLocationThingReference(entityId, (entry) => {
                        entry.imageId = null;
                        entry.imageJobId = null;
                        entry.pendingImageJobId = null;
                    });

                    const payload = {
                        entityType: 'thing',
                        entityId: entityId,
                        force: true
                    };
                    if (context) {
                        payload.context = context;
                    }
                    if (locationId) {
                        payload.locationId = locationId;
                    }
                    if (npcId) {
                        payload.npcId = npcId;
                    }
                    const clientId = window.AIRPG_CLIENT_ID || null;
                    if (clientId) {
                        payload.clientId = clientId;
                    }

                    try {
                        const response = await fetch('/api/images/request', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await response.json().catch(() => ({}));

                        if (!response.ok) {
                            throw new Error(data?.error || `HTTP ${response.status}`);
                        }

                        if (data?.skipped) {
                            thingDataCache.set(thing.id, { ...cachedThing });
                            thing.imageId = cachedThing?.imageId || thing.imageId || null;
                            thing.imageJobId = cachedThing?.imageJobId || thing.imageJobId || null;
                            thing.pendingImageJobId = cachedThing?.pendingImageJobId || null;
                            updateLocationThingReference(entityId, (entry) => {
                                entry.imageId = cachedThing?.imageId || null;
                                if ('imageJobId' in cachedThing) {
                                    entry.imageJobId = cachedThing.imageJobId;
                                }
                                if ('pendingImageJobId' in cachedThing) {
                                    entry.pendingImageJobId = cachedThing.pendingImageJobId || null;
                                }
                            });
                            renderEntityImages('thing', entityId, {
                                imageId: previousImageId,
                                force: false,
                                altText: placeholderAlt
                            });
                            return;
                        }

                        if (!data?.success && !data?.existingJob) {
                            throw new Error(data?.error || 'Image request was not accepted');
                        }

                        const nextThing = {
                            ...updatedThing,
                            pendingImageJobId: data?.jobId || null
                        };
                        thingDataCache.set(thing.id, nextThing);
                        thing.pendingImageJobId = data?.jobId || null;
                        if (data?.imageId) {
                            thing.imageId = data.imageId;
                        }
                        updateLocationThingReference(entityId, (entry) => {
                            entry.pendingImageJobId = data?.jobId || null;
                        });

                        renderEntityImages('thing', entityId, {
                            imageId: null,
                            force: true,
                            altText: placeholderAlt
                        });
                    } catch (error) {
                        console.warn('Failed to regenerate image for thing:', error);
                        thingDataCache.set(thing.id, { ...cachedThing });
                        thing.imageId = cachedThing?.imageId || thing.imageId || null;
                        thing.imageJobId = cachedThing?.imageJobId || thing.imageJobId || null;
                        thing.pendingImageJobId = cachedThing?.pendingImageJobId || null;
                        updateLocationThingReference(entityId, (entry) => {
                            entry.imageId = cachedThing?.imageId || null;
                            if ('imageJobId' in cachedThing) {
                                entry.imageJobId = cachedThing.imageJobId;
                            }
                            if ('pendingImageJobId' in cachedThing) {
                                entry.pendingImageJobId = cachedThing.pendingImageJobId || null;
                            }
                        });
                        renderEntityImages('thing', entityId, {
                            imageId: previousImageId,
                            force: false,
                            altText: placeholderAlt
                        });
                    }
                });
            }

            if (dropButton) {
                dropButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    dropButton.disabled = true;
                    try {
                        closeThingContextMenu();
                        await dropThingToCurrentLocation(thingDataCache.get(thing.id) || thing, options);
                    } catch (error) {
                        console.warn('Failed to drop item:', error);
                        alert(`Failed to drop item: ${error?.message || error}`);
                    } finally {
                        dropButton.disabled = false;
                    }
                });
            }

            if (pickupButton) {
                pickupButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeThingContextMenu();

                    try {
                        const fetchNpcOptions = async () => {
                            const options = [];
                            const seenIds = new Set();

                            const pushEntry = (entry, { priority = 2 } = {}) => {
                                if (!entry || !entry.id || !entry.name) {
                                    return;
                                }

                                const trimmedName = entry.name.trim();
                                if (!trimmedName || seenIds.has(entry.id)) {
                                    return;
                                }

                                seenIds.add(entry.id);
                                options.push({ id: entry.id, name: trimmedName, priority });
                            };

                            const currentPlayer = window.currentPlayerData && window.currentPlayerData.id && window.currentPlayerData.name
                                ? { id: window.currentPlayerData.id, name: window.currentPlayerData.name }
                                : null;

                            if (currentPlayer) {
                                pushEntry(currentPlayer, { priority: 0 });
                            }

                            // Include cached NPCs (player party, etc.)
                            if (window.currentNpcData instanceof Map) {
                                window.currentNpcData.forEach(entry => pushEntry(entry, { priority: 1 }));
                            }

                            try {
                                const response = await fetch('/api/players');
                                const data = await response.json().catch(() => ({}));
                                if (response.ok && data?.success && Array.isArray(data.players)) {
                                    data.players
                                        .filter(entry => entry && entry.id && entry.name && entry.isNPC)
                                        .forEach(entry => {
                                            const priority = 2;
                                            pushEntry(entry, { priority });
                                        });
                                }
                            } catch (fetchError) {
                                console.warn('Failed to fetch NPC list:', fetchError);
                            }

                            return options;
                        };

                        const npcOptions = await fetchNpcOptions();

                        if (!npcOptions.length) {
                            alert('No NPCs are available to receive this item.');
                            return;
                        }

                        const sortedNpcList = npcOptions.sort((a, b) => {
                            if (a.priority !== b.priority) {
                                return a.priority - b.priority;
                            }
                            return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
                        });

                        const modal = document.createElement('div');
                        modal.className = 'npc-selection-modal';

                        const backdrop = document.createElement('div');
                        backdrop.className = 'npc-selection-backdrop';

                        const dialog = document.createElement('div');
                        dialog.className = 'npc-selection-dialog';

                        const header = document.createElement('div');
                        header.className = 'npc-selection-header';
                        const title = document.createElement('h2');
                        title.textContent = 'Select Person';
                        header.appendChild(title);

                        const closeBtn = document.createElement('button');
                        closeBtn.type = 'button';
                        closeBtn.className = 'npc-selection-close';
                        closeBtn.textContent = 'üóô';
                        closeBtn.setAttribute('aria-label', 'Close');
                        header.appendChild(closeBtn);

                        const body = document.createElement('div');
                        body.className = 'npc-selection-body';

                        const filterWrapper = document.createElement('div');
                        filterWrapper.className = 'npc-selection-filter';

                        const filterInput = document.createElement('input');
                        filterInput.type = 'search';
                        filterInput.className = 'npc-selection-filter-input';
                        filterInput.placeholder = 'Filter by name';
                        filterInput.setAttribute('aria-label', 'Filter people by name');
                        filterWrapper.appendChild(filterInput);
                        body.appendChild(filterWrapper);

                        const list = document.createElement('ul');
                        list.className = 'npc-selection-list';
                        body.appendChild(list);

                        const decoratedNpcList = sortedNpcList.map(entry => ({
                            id: entry.id,
                            name: entry.name,
                            normalizedName: entry.name.toLocaleLowerCase()
                        }));

                        const renderNpcButtons = (filterValue = '') => {
                            const normalizedFilter = filterValue.trim().toLocaleLowerCase();
                            list.textContent = '';

                            const filteredEntries = normalizedFilter
                                ? decoratedNpcList.filter(entry => entry.normalizedName.includes(normalizedFilter))
                                : decoratedNpcList;

                            filteredEntries.forEach(entry => {
                                const itemButton = document.createElement('button');
                                itemButton.type = 'button';
                                itemButton.className = 'npc-selection-item';
                                itemButton.textContent = entry.name;
                                itemButton.dataset.npcId = entry.id;

                                const itemLi = document.createElement('li');
                                itemLi.appendChild(itemButton);
                                list.appendChild(itemLi);
                            });
                        };

                        renderNpcButtons();

                        filterInput.addEventListener('input', () => {
                            renderNpcButtons(filterInput.value);
                        });

                        const footer = document.createElement('div');
                        footer.className = 'npc-selection-footer';
                        const cancelBtn = document.createElement('button');
                        cancelBtn.type = 'button';
                        cancelBtn.className = 'npc-selection-cancel';
                        cancelBtn.textContent = 'Cancel';
                        footer.appendChild(cancelBtn);

                        dialog.appendChild(header);
                        dialog.appendChild(body);
                        dialog.appendChild(footer);
                        modal.appendChild(backdrop);
                        modal.appendChild(dialog);
                        document.body.appendChild(modal);
                        document.body.classList.add('modal-open');

                        const cleanup = () => {
                            document.body.classList.remove('modal-open');
                            modal.remove();
                        };

                        const handleSelection = async (npcId) => {
                            if (!npcId) {
                                return;
                            }
                            let moveResult = null;
                            try {
                                pickupButton.disabled = true;
                                moveResult = await moveThingToNpcInventory(thingDataCache.get(thing.id) || thing, npcId, {
                                    locationId: options.locationId || (window.lastRenderedLocation?.id || null)
                                });
                            } catch (error) {
                                console.warn('Failed to move item into inventory:', error);
                                alert(`Failed to move item: ${error?.message || error}`);
                            } finally {
                                pickupButton.disabled = false;
                                cleanup();
                            }

                            if (moveResult?.success) {
                                if (options.context === 'location' && card && card.parentElement) {
                                    const container = card.parentElement;
                                    card.remove();

                                    const hasRemainingCards = container.querySelector('.location-entity-card');
                                    if (!hasRemainingCards) {
                                        const emptyMessage = container.id === 'locationScenery'
                                            ? 'No notable scenery present.'
                                            : 'No notable items present.';
                                        container.innerHTML = `<div class="location-thing-empty">${emptyMessage}</div>`;
                                    }
                                } else if (options.context === 'npc-inventory') {
                                    const targetOwnerId = moveResult?.owner?.id || null;
                                    if (targetOwnerId === currentNpcInventoryNpcId) {
                                        const updatedInventory = Array.isArray(moveResult.owner?.inventory) ? moveResult.owner.inventory : [];
                                        currentNpcInventory = updatedInventory;
                                        renderNpcInventory(updatedInventory);
                                    } else if (Array.isArray(currentNpcInventory)) {
                                        currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                                        renderNpcInventory(currentNpcInventory);
                                    }
                                } else if (options.context === 'player-inventory') {
                                    try {
                                        await window.refreshInventory?.();
                                    } catch (inventoryError) {
                                        console.warn('Failed to refresh player inventory after moving item:', inventoryError);
                                    }
                                }
                            }
                        };

                        closeBtn.addEventListener('click', cleanup);
                        cancelBtn.addEventListener('click', cleanup);
                        backdrop.addEventListener('click', cleanup);
                        list.addEventListener('click', (ev) => {
                            if (!(ev.target instanceof HTMLButtonElement)) {
                                return;
                            }
                            const targetId = ev.target.dataset.npcId || null;
                            if (targetId) {
                                handleSelection(targetId);
                            }
                        });
                    } catch (error) {
                        console.warn('Failed to prepare NPC selection modal:', error);
                        alert(`Unable to show NPC selection: ${error?.message || error}`);
                    }
                });
            }

            teleportButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeThingContextMenu();
                try {
                    await showTeleportLocationModal(thingDataCache.get(thing.id) || thing, {
                        context: options.context || 'general',
                        card,
                        locationId: options.locationId || null,
                        npcId: options.npcId || null
                    });
                } catch (error) {
                    console.warn('Failed to open teleport modal:', error);
                    alert(`Unable to teleport item: ${error?.message || error}`);
                }
            });

            if (deleteButton) {
                deleteButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeThingContextMenu();

                    const cachedThing = thingDataCache.get(thing.id) || thing;
                    const thingName = cachedThing?.name || 'this item';
                    const confirmed = window.confirm(`Delete ${thingName}? This cannot be undone.`);
                    if (!confirmed) {
                        return;
                    }

                    const context = options.context || 'general';
                    const locationHintId = options.locationId || null;
                    const npcHintId = options.npcId || null;

                    try {
                        const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json().catch(() => ({}));
                        if (!response.ok || !result?.success) {
                            throw new Error(result?.error || `HTTP ${response.status}`);
                        }

                        thingDataCache.delete(thing.id);

                        const locationIds = Array.isArray(result.locationIds) ? result.locationIds : [];
                        const playerIds = Array.isArray(result.playerIds) ? result.playerIds : [];
                        const npcIds = Array.isArray(result.npcIds) ? result.npcIds : [];

                        const refreshLocationsByIds = async (ids = []) => {
                            if (typeof window.updateLocationDisplay !== 'function' || !Array.isArray(ids) || !ids.length) {
                                return false;
                            }
                            for (const locId of ids) {
                                if (!locId) {
                                    continue;
                                }
                                try {
                                    const resp = await fetch(`/api/locations/${encodeURIComponent(locId)}`, { cache: 'no-store' });
                                    const data = await resp.json().catch(() => ({}));
                                    if (resp.ok && data?.success && data.location) {
                                        await window.updateLocationDisplay(data.location);
                                        return true;
                                    }
                                } catch (refreshError) {
                                    console.warn('Failed to refresh location details:', refreshError);
                                }
                            }
                            return false;
                        };

                        try {
                            if (context === 'npc-inventory') {
                                if (Array.isArray(currentNpcInventory)) {
                                    currentNpcInventory = currentNpcInventory.filter(item => item && item.id !== thing.id);
                                    renderNpcInventory(currentNpcInventory);
                                }
                                let refreshed = await refreshLocationsByIds(locationIds.length ? locationIds : (locationHintId ? [locationHintId] : []));
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                }
                                if (npcHintId && currentNpcViewId === npcHintId) {
                                    const updatedNpc = window.currentNpcData?.get(npcHintId);
                                    if (updatedNpc) {
                                        showNpcViewModal(updatedNpc);
                                    }
                                }
                            } else if (context === 'npc-equipment') {
                                if (card && card.parentElement) {
                                    card.remove();
                                }
                                let refreshed = await refreshLocationsByIds(locationIds.length ? locationIds : (locationHintId ? [locationHintId] : []));
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                }
                                if (npcHintId && currentNpcViewId === npcHintId) {
                                    const updatedNpc = window.currentNpcData?.get(npcHintId);
                                    if (updatedNpc) {
                                        showNpcViewModal(updatedNpc);
                                    }
                                }
                            } else if (context === 'location') {
                                let refreshed = await refreshLocationsByIds(locationIds.length ? locationIds : (locationHintId ? [locationHintId] : []));
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                    refreshed = true;
                                }
                                if (!refreshed && card && card.parentElement) {
                                    card.remove();
                                }
                            } else {
                                await window.refreshInventory?.();
                                let refreshed = await refreshLocationsByIds(locationIds);
                                if (!refreshed) {
                                    await window.loadCurrentLocation?.();
                                }
                            }

                            const currentPlayerId = window.currentPlayerData?.id;
                            if (currentPlayerId && playerIds.includes(currentPlayerId)) {
                                await window.refreshInventory?.();
                            }

                            if (npcHintId && context !== 'npc-inventory' && npcIds.includes(npcHintId) && currentNpcViewId === npcHintId) {
                                const updatedNpc = window.currentNpcData?.get(npcHintId);
                                if (updatedNpc) {
                                    showNpcViewModal(updatedNpc);
                                }
                            }
                        } catch (refreshError) {
                            console.warn('Failed to refresh after deleting thing:', refreshError);
                            if (card && card.parentElement) {
                                card.remove();
                            }
                        }

                        window.refreshParty?.();
                    } catch (error) {
                        console.warn('Failed to delete item:', error);
                        alert(`Failed to delete item: ${error?.message || 'Unknown error'}`);
                    }
                });
            }

            menu.addEventListener('click', (event) => event.stopPropagation());
            const shiftDropContexts = new Set(['npc-inventory', 'npc-equipment', 'player-inventory', 'location']);
            const suppressSelectionIfShiftDrop = (event) => {
                if (event.button === 0 && event.shiftKey && shiftDropContexts.has(options.context)) {
                    event.preventDefault();
                    try {
                        const sel = window.getSelection && window.getSelection();
                        sel?.removeAllRanges?.();
                    } catch (_) {
                        // ignore selection errors
                    }
                }
            };
            card.addEventListener('mousedown', suppressSelectionIfShiftDrop);
            card.addEventListener('click', async (event) => {
                if (event.button === 0 && event.shiftKey && shiftDropContexts.has(options.context)) {
                    if (event.target && event.target.closest('.thing-card-menu-button')) {
                        return;
                    }
                    event.preventDefault();
                    event.stopPropagation();
                    try {
                        const cachedThing = thingDataCache.get(thing.id) || thing;
                        if (options.context === 'location') {
                            const playerId = window.currentPlayerData?.id || null;
                            if (!playerId) {
                                throw new Error('No active player to receive the item.');
                            }
                            const locationId = options.locationId || window.lastRenderedLocation?.id || null;
                            await moveThingToInventory(cachedThing, {
                                ownerId: playerId,
                                ownerType: 'player',
                                locationId
                            });
                        } else {
                            await dropThingToCurrentLocation(cachedThing, options);
                        }
                        if (thingMenuState.openMenu) {
                            closeThingContextMenu();
                        }
                        return;
                    } catch (error) {
                        console.warn('Ctrl-click drop failed:', error);
                        alert(error?.message || 'Failed to drop item.');
                    }
                }
                if (thingMenuState.openMenu) {
                    closeThingContextMenu();
                }
            });

            card.appendChild(button);
            card.appendChild(menu);
        }

        const formatThingTooltip = (thing = {}) => {
            const normalizedType = normalizeThingType(thing);

            const metaParts = [];
            if (thing.thingType) {
                const label = thing.thingType === 'scenery' ? 'Scenery' : capitalize(thing.thingType);
                metaParts.push(escapeHtml(label));
            } else if (thing.type) {
                metaParts.push(escapeHtml(capitalize(thing.type)));
            } else if (thing.category) {
                metaParts.push(escapeHtml(capitalize(thing.category)));
            } else if (normalizedType) {
                metaParts.push(escapeHtml(capitalize(normalizedType)));
            }
            if (thing.rarity) {
                metaParts.push(escapeHtml(thing.rarity));
            }
            if (thing.itemTypeDetail) {
                metaParts.push(escapeHtml(thing.itemTypeDetail));
            }

            const detailItems = [];
            if (thing.metadata) {
                const { value, weight, properties } = thing.metadata;
                if (value) {
                    detailItems.push({ label: 'Value', value });
                }
                if (weight) {
                    detailItems.push({ label: 'Weight', value: weight });
                }
                if (properties) {
                    detailItems.push({ label: 'Properties', value: properties });
                }
            }
            if (thing.quantity !== undefined && thing.quantity !== null) {
                detailItems.push({ label: 'Quantity', value: thing.quantity });
            }

            const rarityClass = getRarityClass(thing.rarity);
            const nameClasses = ['tooltip-thing-name'];
            if (rarityClass) {
                nameClasses.push(rarityClass);
            }

            const nameHtml = `<div class="${nameClasses.join(' ')}">${escapeHtml(thing.name || 'Unknown Object')}</div>`;
            const resolvedLevel = Number.isFinite(thing?.level)
                ? thing.level
                : (Number.isFinite(Number(thing?.metadata?.level)) ? Number(thing.metadata.level) : null);
            const levelHtml = Number.isFinite(resolvedLevel)
                ? `<div class="tooltip-thing-level">Level ${escapeHtml(String(resolvedLevel))}</div>`
                : '';
            const metaHtml = metaParts.length
                ? `<div class="tooltip-thing-meta">${metaParts.join(' ‚Ä¢ ')}</div>`
                : '';
            const baseDamageHtml = (() => {
                if (!isWeaponThing(thing)) {
                    return '';
                }
                if (!Number.isFinite(resolvedLevel)) {
                    throw new Error('Weapon level is required to calculate base damage.');
                }
                const rarityKey = typeof thing.rarity === 'string'
                    ? thing.rarity
                    : (typeof thing.metadata?.rarity === 'string' ? thing.metadata.rarity : '');
                const baseDamage = getMinimumUnmitigatedWeaponDamage({ rarity: rarityKey, level: resolvedLevel });
                return `<div class="tooltip-thing-stat">Base Damage: ${escapeHtml(String(baseDamage))}</div>`;
            })();
            const descriptionHtml = `<div class="tooltip-thing-description">${escapeHtml(thing.description || 'No description provided.').replace(/\n/g, '<br>')}</div>`;

            const formatModifiersList = (attributes = [], skills = []) => {
                const combined = [
                    ...(Array.isArray(attributes) ? attributes : []),
                    ...(Array.isArray(skills) ? skills : [])
                ];
                const valid = combined
                    .map(mod => {
                        const key = mod.attribute || mod.skill || mod.name;
                        const val = Number.isFinite(mod.modifier) ? mod.modifier : (Number.isFinite(mod.value) ? mod.value : null);
                        if (!key || !Number.isFinite(val)) {
                            return null;
                        }
                        const formattedVal = val > 0 ? `+${val}` : `${val}`;
                        return `<li class="tooltip-thing-bonus-item"><span class="tooltip-thing-bonus-attr">${escapeHtml(key)}</span><span class="tooltip-thing-bonus-value">${escapeHtml(formattedVal)}</span></li>`;
                    })
                    .filter(Boolean);
                if (!valid.length) {
                    return '';
                }
                return `<ul class="tooltip-thing-bonuses-list">${valid.join('')}</ul>`;
            };

            const formatStatusEffectDuration = (durationValue) => {
                if (durationValue === null || durationValue === undefined || durationValue === '') {
                    return '';
                }
                const normalizeNumeric = (num) => {
                    if (!Number.isFinite(num)) {
                        return '';
                    }
                    if (num < 0) {
                        return 'Permanent';
                    }
                    const rounded = Math.floor(num);
                    return `${rounded} turn${rounded === 1 ? '' : 's'}`;
                };

                if (typeof durationValue === 'string') {
                    const trimmed = durationValue.trim();
                    if (!trimmed) {
                        return '';
                    }
                    const lower = trimmed.toLowerCase();
                    if (lower === 'permanent' || lower === 'continuous') {
                        return 'Permanent';
                    }
                    if (lower === 'instant') {
                        return '1 turn';
                    }
                    const parsed = Number(trimmed);
                    if (Number.isFinite(parsed)) {
                        return normalizeNumeric(parsed);
                    }
                    return trimmed;
                }

                const numeric = Number(durationValue);
                return normalizeNumeric(numeric);
            };

            const renderEffectSection = (effect, title, { includeDuration = false } = {}) => {
                if (!effect || (!effect.description && !effect.name)) {
                    return '';
                }
                const nameText = effect.name || '';
                const description = effect.description || effect.text || effect.name || '';
                const durationLabel = includeDuration ? formatStatusEffectDuration(effect.duration) : '';
                const durationSuffix = durationLabel ? ` (Duration: ${durationLabel})` : '';
                const descriptionText = description
                    ? `${description}${durationSuffix}`
                    : (durationSuffix ? durationSuffix.trim() : '');
                const mods = (() => {
                    const combined = [
                        ...(Array.isArray(effect.attributes) ? effect.attributes : []),
                        ...(Array.isArray(effect.skills) ? effect.skills : [])
                    ];
                    const valid = combined
                        .map(mod => {
                            const key = mod.attribute || mod.skill || mod.name;
                            const val = Number.isFinite(mod.modifier) ? mod.modifier : (Number.isFinite(mod.value) ? mod.value : null);
                            if (!key || !Number.isFinite(val)) {
                                return null;
                            }
                            const formattedVal = val > 0 ? `+${val}` : `${val}`;
                            const valClass = val > 0 ? 'positive' : (val < 0 ? 'negative' : 'neutral');
                            return `<li class="tooltip-thing-bonus-item"><span class="tooltip-thing-bonus-attr">${escapeHtml(key)}</span><span class="tooltip-thing-bonus-value ${valClass}">${escapeHtml(formattedVal)}</span></li>`;
                        })
                        .filter(Boolean);
                    return valid.length ? valid : [];
                })();

                const needBars = Array.isArray(effect.needBars) ? effect.needBars : [];
                const needBarItems = needBars
                    .map(entry => {
                        if (!entry) return null;
                        const name = entry.name || entry.bar || entry.id || null;
                        const delta = Number.isFinite(entry.delta) ? entry.delta : (Number.isFinite(entry.modifier) ? entry.modifier : null);
                        if (!name || !Number.isFinite(delta)) {
                            return null;
                        }
                        const formattedDelta = (delta > 0 ? `+${delta}` : `${delta}`) + '/turn';
                        const valClass = delta > 0 ? 'positive' : (delta < 0 ? 'negative' : 'neutral');
                        return `<li class="tooltip-thing-bonus-item"><span class="tooltip-thing-bonus-attr">${escapeHtml(name)}</span><span class="tooltip-thing-bonus-value ${valClass}">${escapeHtml(formattedDelta)}</span></li>`;
                    })
                    .filter(Boolean);

                const allItems = [...mods, ...needBarItems];
                const combinedList = allItems.length
                    ? `<ul class="tooltip-thing-bonuses-list">${allItems.join('')}</ul>`
                    : '';

                return `
                    <div class="tooltip-thing-status">
                        <div class="tooltip-thing-bonuses-title">${escapeHtml(title)}</div>
                        <div class="tooltip-status-desc">${nameText ? `<strong>${escapeHtml(nameText)}</strong> ‚Äì ` : ''}${escapeHtml(descriptionText)}</div>
                        ${combinedList}
                    </div>
                `;
            };

            const statusSections = [];
            const canEquip = normalizedType !== 'scenery' && isEquippableThing(thing);
            statusSections.push(renderEffectSection(thing.causeStatusEffectOnTarget, 'INFLICT STATUS EFFECT', { includeDuration: true }));
            if (canEquip) {
                statusSections.push(renderEffectSection(thing.causeStatusEffectOnEquipper, 'EQUIP STATUS EFFECT'));
            }
            const statusEffectsHtml = statusSections.filter(Boolean).join('');
            const attributeBonuses = getAttributeBonuses(thing).filter(Boolean);
            const bonusesHtml = canEquip && attributeBonuses.length
                ? `<div class="tooltip-thing-bonuses">
                        <div class="tooltip-thing-bonuses-title">Attribute Bonuses</div>
                        <ul class="tooltip-thing-bonuses-list">
                            ${attributeBonuses.map(bonus => {
                                const attrName = formatAttributeName(bonus?.attribute || bonus?.name || 'Attribute');
                                const rawBonus = Number.parseFloat(bonus?.bonus ?? bonus?.value ?? 0);
                                const formattedBonus = Number.isFinite(rawBonus)
                                    ? (rawBonus > 0 ? `+${rawBonus}` : `${rawBonus}`)
                                    : escapeHtml(bonus?.bonus ?? bonus?.value ?? '0');
                                const valClass = rawBonus > 0 ? 'positive' : (rawBonus < 0 ? 'negative' : 'neutral');
                                return `<li class="tooltip-thing-bonus-item"><span class="tooltip-thing-bonus-attr">${escapeHtml(attrName)}</span><span class="tooltip-thing-bonus-value ${valClass}">${escapeHtml(formattedBonus)}</span></li>`;
                            }).join('')}
                        </ul>
                    </div>`
                : '';
            const detailsHtml = detailItems.length
                ? `<div class="tooltip-thing-details">${detailItems.map(item => `
                        <div class="tooltip-thing-detail">
                            <span class="tooltip-thing-detail-label">${escapeHtml(item.label)}</span>
                            <span class="tooltip-thing-detail-value">${formatDetailValue(item.value)}</span>
                        </div>`).join('')}</div>`
                : '';

            const cardClass = normalizedType === 'scenery' ? 'is-scenery' : 'is-item';

            return `
                <div class="tooltip-thing ${cardClass}">
                    ${nameHtml}
                    ${levelHtml}
                    ${metaHtml}
                    ${baseDamageHtml}
                    ${descriptionHtml}
                    ${statusEffectsHtml ? '<hr>' + statusEffectsHtml : ''}
                    ${bonusesHtml}
                    ${detailsHtml}
                </div>
            `.trim();
        };

        const npcEditModal = document.getElementById('npcEditModal');
        const npcInventoryModal = document.getElementById('npcInventoryModal');
        const npcInventoryModalTitle = document.getElementById('npcInventoryModalTitle');
        const npcViewModal = document.getElementById('npcViewModal');
        const npcModalBackdrop = document.getElementById('npcModalBackdrop');
        const npcDispositionModal = document.getElementById('npcDispositionModal');
        const npcDispositionModalTitle = document.getElementById('npcDispositionModalTitle');
        const npcDispositionForm = document.getElementById('npcDispositionForm');
        const npcDispositionSummary = document.getElementById('npcDispositionSummary');
        const npcDispositionList = document.getElementById('npcDispositionList');
        const npcDispositionEmpty = document.getElementById('npcDispositionEmpty');
        const npcDispositionStatus = document.getElementById('npcDispositionStatus');
        const npcDispositionLoading = document.getElementById('npcDispositionLoading');
        const npcDispositionCancelBtn = document.getElementById('npcDispositionCancelBtn');
        const npcDispositionSaveBtn = document.getElementById('npcDispositionSaveBtn');
        const npcDispositionCloseBtn = document.getElementById('npcDispositionCloseBtn');
        const npcNeedsModal = document.getElementById('npcNeedsModal');
        const npcNeedsModalTitle = document.getElementById('npcNeedsModalTitle');
        const npcNeedsForm = document.getElementById('npcNeedsForm');
        const npcNeedsSummary = document.getElementById('npcNeedsSummary');
        const npcNeedsList = document.getElementById('npcNeedsList');
        const npcNeedsEmpty = document.getElementById('npcNeedsEmpty');
        const npcNeedsStatus = document.getElementById('npcNeedsStatus');
        const npcNeedsLoading = document.getElementById('npcNeedsLoading');
        const npcNeedsCancelBtn = document.getElementById('npcNeedsCancelBtn');
        const npcNeedsSaveBtn = document.getElementById('npcNeedsSaveBtn');
        const npcNeedsCloseBtn = document.getElementById('npcNeedsCloseBtn');
        const npcMemoriesModal = document.getElementById('npcMemoriesModal');
        const npcMemoriesModalTitle = document.getElementById('npcMemoriesModalTitle');
        const npcMemoriesList = document.getElementById('npcMemoriesList');
        const npcMemoriesAddBtn = document.getElementById('npcMemoriesAddBtn');
        const npcMemoriesStatus = document.getElementById('npcMemoriesStatus');
        const npcMemoriesCancelBtn = document.getElementById('npcMemoriesCancelBtn');
        const npcMemoriesSaveBtn = document.getElementById('npcMemoriesSaveBtn');
        const npcMemoriesCloseBtn = document.getElementById('npcMemoriesCloseBtn');
        const npcGoalsModal = document.getElementById('npcGoalsModal');
        const npcGoalsModalTitle = document.getElementById('npcGoalsModalTitle');
        const npcGoalsList = document.getElementById('npcGoalsList');
        const npcGoalsAddBtn = document.getElementById('npcGoalsAddBtn');
        const npcGoalsStatus = document.getElementById('npcGoalsStatus');
        const npcGoalsCancelBtn = document.getElementById('npcGoalsCancelBtn');
        const npcGoalsSaveBtn = document.getElementById('npcGoalsSaveBtn');
        const npcGoalsCloseBtn = document.getElementById('npcGoalsCloseBtn');
        const newExitModal = document.getElementById('newExitModal');
        const newExitModalTitle = document.getElementById('newExitModalTitle');
        const newExitForm = document.getElementById('newExitForm');
        const newExitRegionSelect = document.getElementById('newExitRegion');
        const newExitLocationSelect = document.getElementById('newExitLocation');
        const newExitLocationGroup = document.getElementById('newExitLocationGroup');
        const newExitNameGroup = document.getElementById('newExitNameGroup');
        const newExitDescriptionGroup = document.getElementById('newExitDescriptionGroup');
        const newExitImageGroup = document.getElementById('newExitImageGroup');
        const newExitNameInput = document.getElementById('newExitName');
        const newExitDescriptionInput = document.getElementById('newExitDescription');
        const newExitImageInput = document.getElementById('newExitImage');
        const newExitVehicleGroup = document.getElementById('newExitVehicleGroup');
        const newExitVehicleInput = document.getElementById('newExitVehicle');
        const newExitRelativeLevelGroup = document.getElementById('newExitRelativeLevelGroup');
        const newExitRelativeLevelInput = document.getElementById('newExitRelativeLevel');
        const newExitStatus = document.getElementById('newExitStatus');
        const newExitCancelBtn = document.getElementById('newExitCancelBtn');
        const newExitSaveBtn = document.getElementById('newExitSaveBtn');
        const newExitCloseBtn = document.getElementById('newExitCloseBtn');
        const newExitChildRegionGroup = document.getElementById('newExitChildRegionGroup');
        const newExitChildRegionCheckbox = document.getElementById('newExitChildRegion');
        const newExitButton = document.getElementById('newExitButton');
        let newExitOptionsCache = null;
        let newExitRegionsById = new Map();
        let newExitOriginLocationId = null;
        let newExitOriginRegionId = null;
        let newExitPreferredRegionId = null;
        let newExitMapPosition = null;
        let newExitMapMode = false;
        let newExitSubmitting = false;
        const locationCache = {};
        let editingRegionId = null;
        let editingExitContext = null;
        let locationEditMode = 'location';
        let stubEditContext = null;
        let factionOptionsCache = { list: [], map: new Map(), loadedAt: 0 };
        let factionOptionsPromise = null;
        const addNpcModal = document.getElementById('addNpcModal');
        const addNpcForm = document.getElementById('addNpcForm');
        const addNpcNameInput = document.getElementById('addNpcName');
        const addNpcShortDescriptionInput = document.getElementById('addNpcShortDescription');
        const addNpcDescriptionInput = document.getElementById('addNpcDescription');
        const addNpcNotesInput = document.getElementById('addNpcNotes');
        const addNpcRoleInput = document.getElementById('addNpcRole');
        const addNpcClassInput = document.getElementById('addNpcClass');
        const addNpcRaceInput = document.getElementById('addNpcRace');
        const addNpcLevelInput = document.getElementById('addNpcLevel');
        const addNpcCurrencyInput = document.getElementById('addNpcCurrency');
        const addNpcIsHostileInput = document.getElementById('addNpcIsHostile');
        const addNpcImageInput = document.getElementById('addNpcImage');
        const addNpcStatus = document.getElementById('addNpcStatus');
        const addNpcCancelBtn = document.getElementById('addNpcCancelBtn');
        const addNpcSaveBtn = document.getElementById('addNpcSaveBtn');
        const addNpcCloseBtn = document.getElementById('addNpcCloseBtn');
        const addNpcButton = document.getElementById('addNpcButton');
        const addThingButton = document.getElementById('addThingButton');
        let addNpcSubmitting = false;
        const craftSceneryButton = document.getElementById('craftSceneryButton');
        const craftItemButton = document.getElementById('craftItemButton');
        const loadGameModal = document.getElementById('loadGameModal');
        const loadGameSelect = document.getElementById('loadGameSelect');
        const loadGameSourceRadios = Array.from(document.querySelectorAll('input[name="loadGameSource"]'));
        const loadGameStatus = document.getElementById('loadGameStatus');
        const loadGameCancelBtn = document.getElementById('loadGameCancelBtn');
        const loadGameConfirmBtn = document.getElementById('loadGameConfirmBtn');
        const loadGameCloseBtn = document.getElementById('loadGameCloseBtn');
        const npcEditForm = document.getElementById('npcEditForm');
        const npcEditModalTitle = document.getElementById('npcEditModalTitle');
        const npcEditIdInput = document.getElementById('npcEditId');
        const npcEditNameInput = document.getElementById('npcEditName');
        const npcEditShortDescriptionInput = document.getElementById('npcEditShortDescription');
        const npcEditRaceInput = document.getElementById('npcEditRace');
        const npcEditClassInput = document.getElementById('npcEditClass');
        const npcEditFactionSelect = document.getElementById('npcEditFaction');
        const npcEditLevelInput = document.getElementById('npcEditLevel');
        const npcEditHealthInput = document.getElementById('npcEditHealth');
        const npcEditMaxHealthDisplay = document.getElementById('npcEditMaxHealth');
        const npcEditHealthAttributeSelect = document.getElementById('npcEditHealthAttribute');
        const npcEditUnspentInput = document.getElementById('npcEditUnspent');
        const npcEditCurrencyInput = document.getElementById('npcEditCurrency');
        const npcEditExperienceInput = document.getElementById('npcEditExperience');
        const npcEditDescriptionInput = document.getElementById('npcEditDescription');
        const npcEditPersonalityTypeInput = document.getElementById('npcEditPersonalityType');
        const npcEditPersonalityTraitsInput = document.getElementById('npcEditPersonalityTraits');
        const npcEditPersonalityNotesInput = document.getElementById('npcEditPersonalityNotes');
        const npcEditAttributesContainer = document.getElementById('npcEditAttributes');
        const npcEditSkillsContainer = document.getElementById('npcEditSkills');
        const npcEditAbilitiesContainer = document.getElementById('npcEditAbilities');
        const npcAddSkillBtn = document.getElementById('npcAddSkillBtn');
        const npcAddAbilityBtn = document.getElementById('npcAddAbilityBtn');
        const npcStatusEffectsList = document.getElementById('npcEditStatusEffectsList');
        const npcStatusEffectAddBtn = document.getElementById('npcStatusEffectAddBtn');
        const npcEditCancelBtn = document.getElementById('npcEditCancelBtn');
        const npcEditCloseBtn = document.getElementById('npcEditCloseBtn');
        const npcEditStatus = document.getElementById('npcEditStatus');
        const npcEditSaveBtn = document.getElementById('npcEditSaveBtn');
        const npcInventoryGrid = document.getElementById('npcInventoryGrid');
        const npcInventoryFilterInput = document.getElementById('npcInventoryFilterInput');
        const npcInventorySlotFilter = document.getElementById('npcInventorySlotFilter');
        const npcInventoryShowAllRadio = document.getElementById('npcInventoryShowAll');
        const npcInventoryEquippedOnlyRadio = document.getElementById('npcInventoryEquippedOnly');
        const npcInventoryEquippableOnlyRadio = document.getElementById('npcInventoryEquippableOnly');
        const npcInventoryNonEquippableOnlyRadio = document.getElementById('npcInventoryNonEquippableOnly');
        const npcInventoryEmpty = document.getElementById('npcInventoryEmpty');
        const npcInventoryEmptyDefaultText = npcInventoryEmpty ? npcInventoryEmpty.textContent : 'Inventory is empty.';
        const npcInventoryCount = document.getElementById('npcInventoryCount');
        const npcInventoryName = document.getElementById('npcInventoryName');
        const npcInventoryCloseBtn = document.getElementById('npcInventoryCloseBtn');
        const npcViewModalTitle = document.getElementById('npcViewModalTitle');
        const npcViewCloseBtn = document.getElementById('npcViewCloseBtn');
        const npcViewImage = document.getElementById('npcViewImage');
        const locationImageWrapper = document.getElementById('locationImageWrapper');
        const locationImageMenuButton = document.getElementById('locationImageMenuButton');
        const locationImageMenu = document.getElementById('locationImageMenu');
        const locationImageEditButton = document.getElementById('locationImageEditButton');
        const locationRegionEditButton = document.getElementById('locationRegionEditButton');
        const locationSummonNpcButton = document.getElementById('locationSummonNpcButton');
        const locationSummonThingButton = document.getElementById('locationSummonThingButton');
        const locationImageRegenerateButton = document.getElementById('locationImageRegenerateButton');
        const mapLocationContextMenu = document.getElementById('mapLocationContextMenu');
        const worldMapReloadButton = document.getElementById('worldMapReloadButton');
        const mapLocationMenuEditButton = document.getElementById('mapLocationMenuEditButton');
        const mapLocationMenuRegionButton = document.getElementById('mapLocationMenuRegionButton');
        const mapLocationMenuSummonNpcButton = document.getElementById('mapLocationMenuSummonNpcButton');
        const mapLocationMenuSummonThingButton = document.getElementById('mapLocationMenuSummonThingButton');
        const mapLocationMenuRegenerateImageButton = document.getElementById('mapLocationMenuRegenerateImageButton');
        const locationEditModal = document.getElementById('locationEditModal');
        const locationEditModalTitle = document.getElementById('locationEditModalTitle');
        const locationEditForm = document.getElementById('locationEditForm');
        const locationEditNameInput = document.getElementById('locationEditName');
        const locationEditDescriptionInput = document.getElementById('locationEditDescription');
        const locationEditShortDescriptionInput = document.getElementById('locationEditShortDescription');
        const locationEditShortDescriptionGroup = document.getElementById('locationEditShortDescriptionGroup');
        const locationEditRelativeLevelGroup = document.getElementById('locationEditRelativeLevelGroup');
        const locationEditRelativeLevelInput = document.getElementById('locationEditRelativeLevel');
        const locationEditLevelInput = document.getElementById('locationEditLevel');
        const locationEditFactionSelect = document.getElementById('locationEditFaction');
        const locationEditAbsoluteLevel = document.getElementById('locationEditAbsoluteLevel');
        const locationEditStatus = document.getElementById('locationEditStatus');
        const locationEditCancelBtn = document.getElementById('locationEditCancelBtn');
        const locationEditCloseBtn = document.getElementById('locationEditCloseBtn');
        const locationEditSaveBtn = document.getElementById('locationEditSaveBtn');
        const locationStatusEffectsList = document.getElementById('locationEditStatusEffectsList');
        const locationStatusEffectAddBtn = document.getElementById('locationStatusEffectAddBtn');
        const summonNpcModal = document.getElementById('summonNpcModal');
        const summonNpcForm = document.getElementById('summonNpcForm');
        const summonNpcSelect = document.getElementById('summonNpcSelect');
        const summonNpcStatus = document.getElementById('summonNpcStatus');
        const summonNpcCancelBtn = document.getElementById('summonNpcCancelBtn');
        const summonNpcCloseBtn = document.getElementById('summonNpcCloseBtn');
        const summonNpcConfirmBtn = document.getElementById('summonNpcConfirmBtn');
        const summonThingModal = document.getElementById('summonThingModal');
        const summonThingForm = document.getElementById('summonThingForm');
        const summonThingSelect = document.getElementById('summonThingSelect');
        const summonThingStatus = document.getElementById('summonThingStatus');
        const summonThingCancelBtn = document.getElementById('summonThingCancelBtn');
        const summonThingCloseBtn = document.getElementById('summonThingCloseBtn');
        const summonThingConfirmBtn = document.getElementById('summonThingConfirmBtn');
        const regionEditModal = document.getElementById('regionEditModal');
        const regionEditForm = document.getElementById('regionEditForm');
        const regionEditNameInput = document.getElementById('regionEditName');
        const regionEditDescriptionInput = document.getElementById('regionEditDescription');
        const regionEditShortDescriptionInput = document.getElementById('regionEditShortDescription');
        const regionEditParentSelect = document.getElementById('regionEditParent');
        const regionEditAverageLevelInput = document.getElementById('regionEditAverageLevel');
        const regionEditFactionSelect = document.getElementById('regionEditFaction');
        const regionEditStatus = document.getElementById('regionEditStatus');
        const regionEditCancelBtn = document.getElementById('regionEditCancelBtn');
        const regionEditCloseBtn = document.getElementById('regionEditCloseBtn');
        const regionEditSaveBtn = document.getElementById('regionEditSaveBtn');
        const npcViewName = document.getElementById('npcViewName');
        const npcViewDescription = document.getElementById('npcViewDescription');
        const npcViewClass = document.getElementById('npcViewClass');
        const npcViewRace = document.getElementById('npcViewRace');
        const npcViewLevel = document.getElementById('npcViewLevel');
        const npcViewHealth = document.getElementById('npcViewHealth');
        const npcViewCurrency = document.getElementById('npcViewCurrency');
        const npcViewExperience = document.getElementById('npcViewExperience');
        const npcViewDispositions = document.getElementById('npcViewDispositions');
        const npcViewDispositionsList = document.getElementById('npcViewDispositionsList');
        const npcViewAttributes = document.getElementById('npcViewAttributes');
        const npcViewAttributesEmpty = document.getElementById('npcViewAttributesEmpty');
        const npcViewEquipment = document.getElementById('npcViewEquipment');
        const npcViewEquipmentEmpty = document.getElementById('npcViewEquipmentEmpty');
        const npcViewSkills = document.getElementById('npcViewSkills');
        const npcViewSkillsEmpty = document.getElementById('npcViewSkillsEmpty');
        const npcViewAbilities = document.getElementById('npcViewAbilities');
        const npcViewAbilitiesEmpty = document.getElementById('npcViewAbilitiesEmpty');
        const npcViewStatuses = document.getElementById('npcViewStatuses');
        const npcViewStatusesEmpty = document.getElementById('npcViewStatusesEmpty');
        const thingEditModal = document.getElementById('thingEditModal');
        const thingEditForm = document.getElementById('thingEditForm');
        const thingEditModalTitle = document.getElementById('thingEditModalTitle');
        const thingEditIdInput = document.getElementById('thingEditId');
        const thingEditNameInput = document.getElementById('thingEditName');
        const thingEditTypeSelect = document.getElementById('thingEditType');
        const thingEditRarityInput = document.getElementById('thingEditRarity');
        const thingEditItemDetailInput = document.getElementById('thingEditItemDetail');
        const thingEditSlotSelect = document.getElementById('thingEditSlot');
        const thingEditLevelInput = document.getElementById('thingEditLevel');
        const thingEditImageIdInput = document.getElementById('thingEditImageId');
        const thingEditDescriptionInput = document.getElementById('thingEditDescription');
        const thingEditShortDescriptionInput = document.getElementById('thingEditShortDescription');
        const thingEditShortDescriptionGroup = document.getElementById('thingEditShortDescriptionGroup');
        const thingEditNotesGroup = document.getElementById('thingEditNotesGroup');
        const thingEditNotesInput = document.getElementById('thingEditNotes');
        const thingOnHitSection = document.getElementById('thingOnHitSection');
        const thingOnHitTitle = document.getElementById('thingOnHitTitle');
        const thingEquipSection = document.getElementById('thingEquipSection');
        const thingEditIsVehicleInput = document.getElementById('thingEditIsVehicle');
        const thingEditIsCraftingStationInput = document.getElementById('thingEditIsCraftingStation');
        const thingEditIsProcessingStationInput = document.getElementById('thingEditIsProcessingStation');
        const thingEditIsHarvestableInput = document.getElementById('thingEditIsHarvestable');
        const thingEditIsSalvageableInput = document.getElementById('thingEditIsSalvageable');
        const thingMetadataList = document.getElementById('thingEditMetadataList');
        const thingMetadataAddBtn = document.getElementById('thingMetadataAddBtn');
        const thingAttributeBonusesList = document.getElementById('thingEditAttributeBonusesList');
        const thingAttributeBonusAddBtn = document.getElementById('thingAttributeBonusAddBtn');
        const thingCauseEffectNameInput = document.getElementById('thingEditCauseStatusEffectName');
        const thingCauseEffectDescriptionInput = document.getElementById('thingEditCauseStatusEffectDescription');
        const thingCauseEffectDurationInput = document.getElementById('thingEditCauseStatusEffectDuration');
        const thingCauseEffectTargetModifiers = document.getElementById('thingCauseEffectTargetModifiers');
        const thingCauseEffectTargetAddModifierBtn = document.getElementById('thingCauseEffectTargetAddModifierBtn');
        const thingCauseEffectEquipperNameInput = document.getElementById('thingEditCauseStatusEffectEquipperName');
        const thingCauseEffectEquipperDescriptionInput = document.getElementById('thingEditCauseStatusEffectEquipperDescription');
        const thingCauseEffectEquipperDurationInput = document.getElementById('thingEditCauseStatusEffectEquipperDuration');
        const thingCauseEffectEquipperModifiers = document.getElementById('thingCauseEffectEquipperModifiers');
        const thingCauseEffectEquipperAddModifierBtn = document.getElementById('thingCauseEffectEquipperAddModifierBtn');
        const thingEditCancelBtn = document.getElementById('thingEditCancelBtn');
        const thingEditCloseBtn = document.getElementById('thingEditCloseBtn');
        const thingEditSaveBtn = document.getElementById('thingEditSaveBtn');
        const thingEditStatus = document.getElementById('thingEditStatus');
        const normalizeNeedBarKey = (value) => {
            if (typeof value !== 'string') {
                return '';
            }
            const trimmed = value.trim();
            if (!trimmed) {
                return '';
            }
            const lowered = trimmed.toLowerCase();
            if (lowered === 'health') {
                return 'health';
            }
            const needBars = Array.isArray(window.needBarDefinitions) ? window.needBarDefinitions : [];
            const byId = needBars.find(entry => entry?.id && String(entry.id).trim().toLowerCase() === lowered);
            if (byId?.id) {
                return String(byId.id);
            }
            const byName = needBars.find(entry => entry?.name && String(entry.name).trim().toLowerCase() === lowered);
            if (byName?.id) {
                return String(byName.id);
            }
            return trimmed;
        };
        const thingModifierTemplates = {
            buildOptions(selectEl) {
                if (!selectEl) return;
                selectEl.innerHTML = '';
                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = 'Select attribute, skill, or need bar';
                selectEl.appendChild(defaultOpt);

                const addGroup = (label, values, prefix) => {
                    if (!Array.isArray(values) || !values.length) return;
                    const group = document.createElement('optgroup');
                    group.label = label;
                    values.forEach(entry => {
                        const option = document.createElement('option');
                        option.value = `${prefix}:${entry.key || entry.name}`;
                        option.textContent = entry.label || entry.name || entry.key;
                        group.appendChild(option);
                    });
                    selectEl.appendChild(group);
                };

                const attributes = Array.isArray(attributeOptions) && attributeOptions.length
                    ? attributeOptions.map(entry => ({
                        key: entry.key,
                        label: entry.label || entry.key
                    }))
                    : [];
                const skills = Array.isArray(window.availableSkillsList)
                    ? window.availableSkillsList
                        .filter(entry => entry && entry.name)
                        .map(entry => ({ key: entry.name, label: entry.name }))
                    : [];

                const needBars = Array.isArray(window.needBarDefinitions)
                    ? window.needBarDefinitions
                        .filter(entry => entry && entry.id && entry.name)
                        .map(entry => ({ key: entry.id, label: entry.name }))
                    : [];
                needBars.unshift({ key: 'health', label: 'Health' });

                addGroup('Attributes', attributes, 'attr');
                addGroup('Skills', skills, 'skill');
                addGroup('Need Bars', needBars, 'need');
            },
            createRow(initial) {
                const row = document.createElement('div');
                row.className = 'thing-modifier-row';

                const select = document.createElement('select');
                select.className = 'thing-modifier-select';
                this.buildOptions(select);

                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'thing-modifier-value';
                input.placeholder = '+/-';
                input.step = '1';

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'npc-edit-remove-btn';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', () => row.remove());

                row.appendChild(select);
                row.appendChild(input);
                row.appendChild(removeBtn);

                if (initial) {
                    if (initial.attribute) {
                        select.value = `attr:${initial.attribute}`;
                    } else if (initial.skill) {
                        select.value = `skill:${initial.skill}`;
                    } else if (initial.name) {
                        const needKey = normalizeNeedBarKey(initial.name);
                        if (needKey) {
                            select.value = `need:${needKey}`;
                        }
                    }
                    const numeric = Number.isFinite(initial.modifier)
                        ? initial.modifier
                        : (Number.isFinite(initial.delta) ? initial.delta : null);
                    if (numeric !== null) {
                        input.value = numeric;
                    }
                }

                return row;
            },
            renderList(container, entries = []) {
                if (!container) return;
                container.innerHTML = '';
                if (!Array.isArray(entries) || !entries.length) {
                    container.appendChild(this.createRow(null));
                    return;
                }
                entries.forEach(entry => container.appendChild(this.createRow(entry)));
            },
            collect(container) {
                const result = { attributes: [], skills: [], needBars: [] };
                if (!container) return result;
                container.querySelectorAll('.thing-modifier-row').forEach(row => {
                    const select = row.querySelector('.thing-modifier-select');
                    const input = row.querySelector('.thing-modifier-value');
                    const selection = select?.value || '';
                    const [type, key] = selection.split(':');
                    const modRaw = input?.value ?? '';
                    const modifier = Number(modRaw);
                    if (!key || !Number.isFinite(modifier)) {
                        return;
                    }
                    if (type === 'attr') {
                        result.attributes.push({ attribute: key, modifier });
                    } else if (type === 'skill') {
                        result.skills.push({ skill: key, modifier });
                    } else if (type === 'need') {
                        result.needBars.push({ name: key, delta: modifier });
                    }
                });
                return result;
            }
        };

        const craftingModalBackdrop = document.getElementById('craftingModalBackdrop');
        const craftingModal = document.getElementById('craftingModal');
        const craftingModalTitle = document.getElementById('craftingModalTitle');
        const craftingWorkspaceTitle = document.getElementById('craftingWorkspaceTitle');
        const craftingModalHint = document.getElementById('craftingModalHint');
        const craftingModalCloseBtn = document.getElementById('craftingModalCloseBtn');
        const craftingInventoryGrid = document.getElementById('craftingInventoryGrid');
        const craftingInventoryEmpty = document.getElementById('craftingInventoryEmpty');
        const craftingInventoryFilterInput = document.getElementById('craftingInventoryFilterInput');
        const craftingSlotsContainer = document.getElementById('craftingSlots');
        const craftingActionButton = document.getElementById('craftingActionButton');
        const craftingCancelButton = document.getElementById('craftingCancelButton');
        const craftingNotesInput = document.getElementById('craftingNotesInput');
        const salvageIntentBackdrop = document.getElementById('salvageIntentBackdrop');
        const salvageIntentModal = document.getElementById('salvageIntentModal');
        const salvageIntentTitle = document.getElementById('salvageIntentTitle');
        const salvageIntentMessage = document.getElementById('salvageIntentMessage');
        const salvageIntentInput = document.getElementById('salvageIntentInput');
        const salvageIntentSubmitBtn = document.getElementById('salvageIntentSubmitBtn');
        const salvageIntentCancelBtn = document.getElementById('salvageIntentCancelBtn');
        const salvageIntentCloseBtn = document.getElementById('salvageIntentCloseBtn');

        let currentCraftingMode = 'craft';
        let currentCraftingTargetType = 'item';
        let currentCraftingSlotCount = 4;
        let craftingSlotAssignments = new Map();
        let craftingInventoryLookup = new Map();
        let craftingInventoryCardRefs = new Map();
        let craftingInventoryAllItems = [];
        let craftingSourceThing = null;
        let craftingIsOpen = false;
        let salvageIntentContext = { mode: 'salvage', thingId: null, thing: null };
        // Allow concurrent craft/harvest requests; only dedupe identical payloads to avoid double-clicks.
        const craftingRequestsInFlight = new Set();
        const salvageRequestsInFlight = new Set();

        let locationMenuContextOverride = null;

        function clearLocationMenuContext() {
            locationMenuContextOverride = null;
        }

        function setLocationMenuContext(locationRecord) {
            if (locationRecord && lastRenderedLocation?.id && locationRecord.id === lastRenderedLocation.id) {
                locationMenuContextOverride = null;
                return;
            }
            if (locationRecord && typeof locationRecord === 'object') {
                try {
                    locationMenuContextOverride = JSON.parse(JSON.stringify(locationRecord));
                } catch (_) {
                    locationMenuContextOverride = { ...locationRecord };
                }
            } else {
                locationMenuContextOverride = null;
            }
        }

        function getLocationMenuContext() {
            return locationMenuContextOverride || lastRenderedLocation || null;
        }

        function isCurrentLocationContext(target) {
            if (!target || !target.id || !lastRenderedLocation?.id) {
                return false;
            }
            return target.id === lastRenderedLocation.id;
        }

        let locationImageMenuOpen = false;
        let mapLocationMenuOpen = false;

        function openLocationImageMenu() {
            if (!locationImageMenu || !locationImageMenuButton) {
                return;
            }
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                alert('No location is currently available for these actions.');
                clearLocationMenuContext();
                return;
            }
            locationImageMenu.hidden = false;
            locationImageMenu.classList.add('is-open');
            locationImageMenuButton.setAttribute('aria-expanded', 'true');
            locationImageMenuOpen = true;
            if (locationImageWrapper) {
                locationImageWrapper.classList.add('context-menu-open');
            }

            const firstItem = locationImageMenu.querySelector('.location-image-menu-item');
            if (firstItem) {
                requestAnimationFrame(() => {
                    if (locationImageMenuOpen) {
                        firstItem.focus();
                    }
                });
            }
        }

        function closeLocationImageMenu(options = {}) {
            const preserveContext = Boolean(options?.preserveContext);
            if (!locationImageMenu || !locationImageMenuButton) {
                if (!preserveContext) {
                    clearLocationMenuContext();
                }
                return;
            }
            if (!locationImageMenuOpen) {
                if (!preserveContext) {
                    clearLocationMenuContext();
                }
                return;
            }

            locationImageMenu.hidden = true;
            locationImageMenu.classList.remove('is-open');
            locationImageMenuButton.setAttribute('aria-expanded', 'false');
            locationImageMenuOpen = false;
            if (locationImageWrapper) {
                locationImageWrapper.classList.remove('context-menu-open');
            }
            if (!preserveContext) {
                clearLocationMenuContext();
            }

            requestAnimationFrame(() => {
                if (document.activeElement && locationImageMenu?.contains(document.activeElement)) {
                    locationImageMenuButton.focus();
                }
            });
        }

        function toggleLocationImageMenu() {
            if (locationImageMenuOpen) {
                closeLocationImageMenu();
            } else {
                openLocationImageMenu();
            }
        }

        function openMapLocationContextMenu(anchorPoint = null) {
            if (!mapLocationContextMenu) {
                alert('Location context menu is unavailable.');
                return;
            }
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                alert('No location is currently available for these actions.');
                clearLocationMenuContext();
                return;
            }

            const point = anchorPoint || { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            mapLocationContextMenu.style.left = '0px';
            mapLocationContextMenu.style.top = '0px';
            mapLocationContextMenu.hidden = false;
            mapLocationContextMenu.classList.add('is-open');
            mapLocationMenuOpen = true;

            requestAnimationFrame(() => {
                const rect = mapLocationContextMenu.getBoundingClientRect();
                const padding = 12;
                let left = typeof point.x === 'number' ? point.x : window.innerWidth / 2;
                let top = typeof point.y === 'number' ? point.y : window.innerHeight / 2;

                if (left + rect.width + padding > window.innerWidth) {
                    left = window.innerWidth - rect.width - padding;
                }
                if (top + rect.height + padding > window.innerHeight) {
                    top = window.innerHeight - rect.height - padding;
                }
                left = Math.max(padding, left);
                top = Math.max(padding, top);

                mapLocationContextMenu.style.left = `${Math.round(left)}px`;
                mapLocationContextMenu.style.top = `${Math.round(top)}px`;
            });
        }

        function closeMapLocationContextMenu(options = {}) {
            const preserveContext = Boolean(options?.preserveContext);
            if (!mapLocationContextMenu) {
                if (!preserveContext) {
                    clearLocationMenuContext();
                }
                return;
            }
            if (!mapLocationMenuOpen) {
                if (!preserveContext) {
                    clearLocationMenuContext();
                }
                return;
            }
            mapLocationContextMenu.classList.remove('is-open');
            mapLocationContextMenu.hidden = true;
            mapLocationContextMenu.style.left = '-9999px';
            mapLocationContextMenu.style.top = '-9999px';
            mapLocationMenuOpen = false;
            if (!preserveContext) {
                clearLocationMenuContext();
            }
        }

        async function openLocationContextMenuForLocationId(locationId, options = {}) {
            if (!locationId) {
                return;
            }

            const useFloatingMenu = Boolean(options?.useFloatingMenu && mapLocationContextMenu);
            const anchorPoint = options?.anchorPoint || null;
            const shouldFocusAdventureTab = options?.focusAdventureTab ?? !useFloatingMenu;

            if (locationImageMenuOpen) {
                closeLocationImageMenu({ preserveContext: true });
            }
            if (mapLocationMenuOpen) {
                closeMapLocationContextMenu({ preserveContext: true });
            }

            let targetLocation = null;
            if (lastRenderedLocation?.id === locationId) {
                targetLocation = lastRenderedLocation;
                clearLocationMenuContext();
            } else if (locationMenuContextOverride?.id === locationId) {
                targetLocation = locationMenuContextOverride;
            }

            if (!targetLocation) {
                try {
                    const response = await fetch(`/api/locations/${encodeURIComponent(locationId)}?expandStubs=false&_=${Date.now()}`, { cache: 'no-store' });
                    const data = await response.json().catch(() => ({}));
                    if (!response.ok || !data?.location) {
                        throw new Error(data?.error || `HTTP ${response.status}`);
                    }
                    setLocationMenuContext(data.location);
                    targetLocation = getLocationMenuContext();
                } catch (error) {
                    console.warn('Failed to load location for context menu:', error);
                    alert(`Failed to load location: ${error?.message || 'Unknown error'}`);
                    return;
                }
            } else if (!isCurrentLocationContext(targetLocation)) {
                setLocationMenuContext(targetLocation);
                targetLocation = getLocationMenuContext();
            }

            if (useFloatingMenu) {
                openMapLocationContextMenu(anchorPoint);
                return;
            }

            if (shouldFocusAdventureTab) {
                if (typeof window.activateTab === 'function') {
                    window.activateTab('adventure');
                } else {
                    document.querySelector('[data-tab="adventure"]')?.click();
                }
            }

            openLocationImageMenu();
        }

        window.openLocationContextMenuForLocationId = openLocationContextMenuForLocationId;

        function safeJsonStringify(value, fallback = '') {
            try {
                return JSON.stringify(value, null, 2);
            } catch (_) {
                return fallback;
            }
        }

        const THING_BADGE_DEFINITIONS = [
            { key: 'isVehicle', icon: 'üöó', label: 'Vehicle' },
            { key: 'isHarvestable', icon: 'üåæ', label: 'Harvestable Resource' },
            { key: 'isCraftingStation', icon: '‚öíÔ∏è', label: 'Crafting Station' },
            { key: 'isProcessingStation', icon: '‚öôÔ∏è', label: 'Processing Station' },
            { key: 'isSalvageable', icon: '‚ôªÔ∏è', label: 'Salvageable' }
        ];
        const THING_BOOLEAN_METADATA_KEYS = THING_BADGE_DEFINITIONS.map(def => def.key);

        function formatThingMetadataValue(value) {
            if (value === undefined || value === null) {
                return '';
            }
            if (typeof value === 'object') {
                return safeJsonStringify(value, '');
            }
            return String(value);
        }

        function extractEditableThingMetadata(thing = {}) {
            if (!thing || typeof thing !== 'object') {
                return {};
            }
            const metadata = thing.metadata && typeof thing.metadata === 'object'
                ? { ...thing.metadata }
                : {};
            delete metadata.slot;
            delete metadata.attributeBonuses;
            delete metadata.causeStatusEffect;
            delete metadata.level;
            delete metadata.relativeLevel;
            delete metadata.location;
            delete metadata.locationId;
            THING_BOOLEAN_METADATA_KEYS.forEach(key => {
                delete metadata[key];
            });
            return metadata;
        }

        function createThingMetadataRow(entry = {}) {
            if (!thingMetadataList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-metadata-row';

            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.className = 'thing-edit-metadata-key';
            keyInput.placeholder = 'Key';
            keyInput.autocomplete = 'off';
            keyInput.value = entry.key || '';

            const valueInput = document.createElement('textarea');
            valueInput.className = 'thing-edit-metadata-value';
            valueInput.rows = 1;
            valueInput.placeholder = 'Value (text, number, or JSON)';
            valueInput.value = entry.value !== undefined ? formatThingMetadataValue(entry.value) : '';

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(keyInput);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);

            thingMetadataList.appendChild(row);

            return row;
        }

        function renderThingMetadataEntries(metadata = {}) {
            if (!thingMetadataList) {
                return;
            }
            thingMetadataList.innerHTML = '';
            const entries = metadata && typeof metadata === 'object'
                ? Object.entries(metadata)
                : [];
            if (!entries.length) {
                createThingMetadataRow({});
                return;
            }
            entries.forEach(([key, value]) => {
                createThingMetadataRow({ key, value });
            });
        }

        function collectThingMetadataEntries() {
            if (!thingMetadataList) {
                return {};
            }
            const metadata = {};
            thingMetadataList.querySelectorAll('.thing-edit-metadata-row').forEach(row => {
                const key = row.querySelector('.thing-edit-metadata-key')?.value?.trim();
                if (!key) {
                    return;
                }
                const rawValue = row.querySelector('.thing-edit-metadata-value')?.value ?? '';
                const trimmed = rawValue.trim();
                if (!trimmed) {
                    metadata[key] = '';
                    return;
                }
                let parsed = trimmed;
                try {
                    parsed = JSON.parse(trimmed);
                } catch (_) {
                    parsed = trimmed;
                }
                metadata[key] = parsed;
            });
            return metadata;
        }

        function coerceBooleanFlag(value) {
            if (typeof value === 'string') {
                const normalized = value.trim().toLowerCase();
                if (!normalized) {
                    return false;
                }
                return normalized === 'true' || normalized === '1' || normalized === 'yes';
            }
            return Boolean(value);
        }

        function resolveThingBooleanFlag(thing, key) {
            if (!thing || typeof thing !== 'object') {
                return false;
            }
            if (thing[key] !== undefined && thing[key] !== null) {
                return coerceBooleanFlag(thing[key]);
            }
            const metadataValue = thing.metadata?.[key];
            if (metadataValue !== undefined && metadataValue !== null) {
                return coerceBooleanFlag(metadataValue);
            }
            return false;
        }

        function getThingPropertyBadges(thing) {
            if (!thing) {
                return [];
            }
            return THING_BADGE_DEFINITIONS
                .filter(definition => resolveThingBooleanFlag(thing, definition.key))
                .map(definition => ({
                    key: definition.key,
                    icon: definition.icon,
                    label: definition.label
                }));
        }

        function populateAttributeSelect(selectElement, selectedAttribute = '') {
            if (!selectElement) {
                return;
            }

            const normalized = typeof selectedAttribute === 'string' ? selectedAttribute.trim() : '';
            const normalizedLower = normalized.toLowerCase();

            selectElement.innerHTML = '';

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select attribute';
            selectElement.appendChild(placeholder);

            let hasMatch = false;
            if (Array.isArray(attributeOptions) && attributeOptions.length) {
                attributeOptions.forEach(attr => {
                    if (!attr || !attr.key) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.value = attr.key;
                    option.textContent = attr.label || titleCase(attr.key);
                    if (attr.description) {
                        option.dataset.description = attr.description;
                    }
                    if (normalizedLower && attr.keyLower === normalizedLower) {
                        option.selected = true;
                        hasMatch = true;
                    }
                    selectElement.appendChild(option);
                });
            }

            if (normalized && !hasMatch) {
                const customOption = document.createElement('option');
                customOption.value = normalized;
                customOption.textContent = titleCase(normalized);
                customOption.selected = true;
                selectElement.appendChild(customOption);
            }
        }

        function createThingAttributeBonusRow(entry = {}) {
            if (!thingAttributeBonusesList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-bonus-row';

            const attributeSelect = document.createElement('select');
            attributeSelect.className = 'thing-edit-bonus-attribute';
            populateAttributeSelect(attributeSelect, entry.attribute || entry.attributeName || '');

            const bonusInput = document.createElement('input');
            bonusInput.type = 'number';
            bonusInput.step = '1';
            bonusInput.className = 'thing-edit-bonus-value';
            bonusInput.placeholder = 'Bonus';
            if (entry.bonus !== undefined && entry.bonus !== null && entry.bonus !== '') {
                const numericBonus = Number(entry.bonus);
                if (!Number.isNaN(numericBonus)) {
                    bonusInput.value = numericBonus;
                }
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(attributeSelect);
            row.appendChild(bonusInput);
            row.appendChild(removeBtn);

            thingAttributeBonusesList.appendChild(row);

            return row;
        }

        function renderThingAttributeBonuses(bonuses = []) {
            if (!thingAttributeBonusesList) {
                return;
            }
            thingAttributeBonusesList.innerHTML = '';
            const entries = Array.isArray(bonuses) ? bonuses : [];
            if (!entries.length) {
                createThingAttributeBonusRow({});
                return;
            }
            entries.forEach(entry => createThingAttributeBonusRow(entry));
        }

        function collectThingAttributeBonuses() {
            if (!thingAttributeBonusesList) {
                return [];
            }
            const bonuses = [];
            thingAttributeBonusesList.querySelectorAll('.thing-edit-bonus-row').forEach(row => {
                const attribute = row.querySelector('.thing-edit-bonus-attribute')?.value?.trim();
                if (!attribute) {
                    return;
                }
                const rawBonus = row.querySelector('.thing-edit-bonus-value')?.value ?? '';
                const numeric = Number.parseFloat(rawBonus);
                bonuses.push({
                    attribute,
                    bonus: Number.isFinite(numeric) ? numeric : 0
                });
            });
            return bonuses;
        }

        function populateThingCauseStatusEffect(effectOnTarget = null, effectOnEquipper = null) {
            if (thingCauseEffectNameInput) {
                thingCauseEffectNameInput.value = effectOnTarget?.name || '';
            }
            if (thingCauseEffectDescriptionInput) {
                thingCauseEffectDescriptionInput.value = effectOnTarget?.description || effectOnTarget?.text || '';
            }
            if (thingCauseEffectDurationInput) {
                if (effectOnTarget && effectOnTarget.duration !== undefined && effectOnTarget.duration !== null) {
                    thingCauseEffectDurationInput.value = String(effectOnTarget.duration);
                } else {
                    thingCauseEffectDurationInput.value = '';
                }
            }

            if (thingCauseEffectEquipperNameInput) {
                thingCauseEffectEquipperNameInput.value = effectOnEquipper?.name || '';
            }
            if (thingCauseEffectEquipperDescriptionInput) {
                thingCauseEffectEquipperDescriptionInput.value = effectOnEquipper?.description || effectOnEquipper?.text || '';
            }
            if (thingCauseEffectEquipperDurationInput) {
                if (effectOnEquipper && effectOnEquipper.duration !== undefined && effectOnEquipper.duration !== null) {
                    thingCauseEffectEquipperDurationInput.value = String(effectOnEquipper.duration);
                } else {
                    thingCauseEffectEquipperDurationInput.value = '';
                }
            }

            if (thingCauseEffectTargetModifiers) {
                thingModifierTemplates.renderList(thingCauseEffectTargetModifiers, [
                    ...(Array.isArray(effectOnTarget?.attributes) ? effectOnTarget.attributes.map(entry => ({ attribute: entry.attribute || entry.name, modifier: entry.modifier })) : []),
                    ...(Array.isArray(effectOnTarget?.skills) ? effectOnTarget.skills.map(entry => ({ skill: entry.skill || entry.name, modifier: entry.modifier })) : []),
                    ...(Array.isArray(effectOnTarget?.needBars) ? effectOnTarget.needBars.map(entry => ({ name: entry.name || entry.bar, delta: entry.delta })) : [])
                ]);
            }

            if (thingCauseEffectEquipperModifiers) {
                thingModifierTemplates.renderList(thingCauseEffectEquipperModifiers, [
                    ...(Array.isArray(effectOnEquipper?.attributes) ? effectOnEquipper.attributes.map(entry => ({ attribute: entry.attribute || entry.name, modifier: entry.modifier })) : []),
                    ...(Array.isArray(effectOnEquipper?.skills) ? effectOnEquipper.skills.map(entry => ({ skill: entry.skill || entry.name, modifier: entry.modifier })) : []),
                    ...(Array.isArray(effectOnEquipper?.needBars) ? effectOnEquipper.needBars.map(entry => ({ name: entry.name || entry.bar, delta: entry.delta })) : [])
                ]);
            }
        }

        function collectThingCauseStatusEffect() {
            const collectSingle = (nameInput, descInput, durationInput) => {
                const name = nameInput?.value?.trim();
                const description = descInput?.value?.trim();
                const durationRaw = durationInput?.value?.trim();
                if (!name && !description && !durationRaw) {
                    return null;
                }
                const effect = {};
                if (name) effect.name = name;
                if (description) effect.description = description;
                if (durationRaw) {
                    const numeric = Number.parseInt(durationRaw, 10);
                    effect.duration = Number.isFinite(numeric) ? numeric : durationRaw;
                }
                return Object.keys(effect).length ? effect : null;
            };

            return {
                target: (() => {
                    const base = collectSingle(thingCauseEffectNameInput, thingCauseEffectDescriptionInput, thingCauseEffectDurationInput);
                    if (!base) return null;
                    const modifiers = thingModifierTemplates.collect(thingCauseEffectTargetModifiers);
                    if (modifiers.attributes.length) base.attributes = modifiers.attributes;
                    if (modifiers.skills.length) base.skills = modifiers.skills;
                    if (modifiers.needBars.length) base.needBars = modifiers.needBars;
                    return base;
                })(),
                equipper: (() => {
                    const base = collectSingle(thingCauseEffectEquipperNameInput, thingCauseEffectEquipperDescriptionInput, thingCauseEffectEquipperDurationInput);
                    if (!base) return null;
                    const modifiers = thingModifierTemplates.collect(thingCauseEffectEquipperModifiers);
                    if (modifiers.attributes.length) base.attributes = modifiers.attributes;
                    if (modifiers.skills.length) base.skills = modifiers.skills;
                    if (modifiers.needBars.length) base.needBars = modifiers.needBars;
                    return base;
                })()
            };
        }

        function populateThingRarityOptions(selectedRarity = '') {
            if (!thingEditRarityInput) {
                return;
            }

            const normalized = typeof selectedRarity === 'string' ? selectedRarity.trim().toLowerCase() : '';

            thingEditRarityInput.innerHTML = '';

            const unspecifiedOption = document.createElement('option');
            unspecifiedOption.value = '';
            unspecifiedOption.textContent = 'Not specified';
            thingEditRarityInput.appendChild(unspecifiedOption);

            rarityClassLookup.forEach(({ key, className, label }) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = label || getRarityLabel(key);
                option.className = className;
                if (normalized && (normalized === key || normalized.includes(key))) {
                    option.selected = true;
                }
                thingEditRarityInput.appendChild(option);
            });

            if (normalized && !rarityClassLookup.some(entry => entry.key === normalized)) {
                const customOption = document.createElement('option');
                customOption.value = normalized;
                customOption.textContent = getRarityLabel(normalized);
                const customClass = getRarityClass(normalized);
                if (customClass) {
                    customOption.className = customClass;
                }
                customOption.selected = true;
                thingEditRarityInput.appendChild(customOption);
            }

            if (!thingEditRarityInput.value && normalized) {
                thingEditRarityInput.value = normalized;
            }
        }

        function populateThingSlotOptions(selectedSlot = '') {
            if (!thingEditSlotSelect) {
                return;
            }

            const normalized = normalizeSlotType(selectedSlot);
            if (normalized) {
                addAvailableSlotType(normalized);
            }
            const slotTypes = Array.from(availableSlotTypes);
            if (normalized && !slotTypes.includes(normalized)) {
                slotTypes.push(normalized);
            }

            slotTypes.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

            thingEditSlotSelect.innerHTML = '';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = 'Not equippable';
            thingEditSlotSelect.appendChild(emptyOption);

            slotTypes.forEach(slotType => {
                if (!slotType) {
                    return;
                }
                const option = document.createElement('option');
                option.value = slotType;
                option.textContent = formatSlotTypeLabel(slotType);
                if (slotType === normalized) {
                    option.selected = true;
                }
                thingEditSlotSelect.appendChild(option);
            });

            if (!thingEditSlotSelect.value && normalized) {
                thingEditSlotSelect.value = normalized;
            }
        }

        function isThingEquippable() {
            const typeValue = (thingEditTypeSelect?.value || '').toLowerCase();
            const slotValue = (thingEditSlotSelect?.value || '').trim();
            return typeValue === 'item' && Boolean(slotValue);
        }

        function updateThingStatusEffectVisibility() {
            const equippable = isThingEquippable();
            if (thingEquipSection) {
                if (equippable) {
                    thingEquipSection.removeAttribute('hidden');
                    thingEquipSection.classList.remove('is-hidden');
                } else {
                    thingEquipSection.setAttribute('hidden', '');
                    thingEquipSection.classList.add('is-hidden');
                }
            }
            if (thingOnHitTitle) {
                thingOnHitTitle.textContent = equippable ? 'On-Hit Status Effect' : 'Status Effect';
            }
        }

        function populateThingEditForm(thing, options = {}) {
            if (!thingEditForm) {
                return;
            }

            thingEditForm.reset();

            const mode = options.mode === 'create' ? 'create' : 'edit';
            if (thingEditNotesGroup) {
                if (mode === 'create') {
                    thingEditNotesGroup.removeAttribute('hidden');
                } else {
                    thingEditNotesGroup.setAttribute('hidden', '');
                }
            }
            if (thingEditShortDescriptionGroup) {
                thingEditShortDescriptionGroup.removeAttribute('hidden');
            }
            if (thingEditNotesInput) {
                thingEditNotesInput.value = '';
            }
            if (thingEditShortDescriptionInput) {
                thingEditShortDescriptionInput.disabled = false;
                const resolvedShort = thing?.shortDescription ?? thing?.metadata?.shortDescription ?? '';
                thingEditShortDescriptionInput.value = mode === 'edit'
                    ? resolvedShort
                    : '';
            }

            if (thingEditModalTitle) {
                if (mode === 'create') {
                    const defaultTitle = options.itemOrScenery === 'scenery' ? 'Create Scenery' : 'Create Item';
                    thingEditModalTitle.textContent = options.title || defaultTitle;
                } else {
                    thingEditModalTitle.textContent = thing?.name ? `Edit ${thing.name}` : 'Edit Item';
                }
            }

            if (thingEditIdInput) {
                thingEditIdInput.value = thing?.id || '';
            }

            if (thingEditNameInput) {
                thingEditNameInput.value = thing?.name || '';
            }

            if (thingEditTypeSelect) {
                const explicitType = options.itemOrScenery ? String(options.itemOrScenery).toLowerCase() : null;
                const typeValue = explicitType
                    || (thing?.thingType || thing?.type || thing?.itemOrScenery || 'item').toString().toLowerCase();
                thingEditTypeSelect.value = typeValue === 'scenery' ? 'scenery' : 'item';
            }

            const rarityValue = thing?.rarity || thing?.metadata?.rarity || '';
            populateThingRarityOptions(rarityValue);

            if (thingEditItemDetailInput) {
                const detail = thing?.itemTypeDetail || thing?.itemDetail || '';
                thingEditItemDetailInput.value = detail;
            }

            populateThingSlotOptions(thing?.slot || thing?.metadata?.slot || '');

            if (thingEditLevelInput) {
                const numericLevel = Number.parseInt(thing?.level, 10);
                thingEditLevelInput.value = Number.isFinite(numericLevel) ? numericLevel : '';
            }


            if (thingEditImageIdInput) {
                thingEditImageIdInput.value = thing?.imageId || '';
            }

            if (thingEditDescriptionInput) {
                thingEditDescriptionInput.value = thing?.description || '';
            }

            if (thingEditIsVehicleInput) {
                thingEditIsVehicleInput.checked = resolveThingBooleanFlag(thing, 'isVehicle');
            }
            if (thingEditIsCraftingStationInput) {
                thingEditIsCraftingStationInput.checked = resolveThingBooleanFlag(thing, 'isCraftingStation');
            }
            if (thingEditIsProcessingStationInput) {
                thingEditIsProcessingStationInput.checked = resolveThingBooleanFlag(thing, 'isProcessingStation');
            }
            if (thingEditIsHarvestableInput) {
                thingEditIsHarvestableInput.checked = resolveThingBooleanFlag(thing, 'isHarvestable');
            }
            if (thingEditIsSalvageableInput) {
                thingEditIsSalvageableInput.checked = resolveThingBooleanFlag(thing, 'isSalvageable');
            }

            currentThingLockedMetadata = {};
            if (thing && typeof thing.metadata === 'object' && thing.metadata) {
                const locked = {};
                if (thing.metadata.location !== undefined) {
                    locked.location = thing.metadata.location;
                }
                if (thing.metadata.locationId !== undefined) {
                    locked.locationId = thing.metadata.locationId;
                }
                currentThingLockedMetadata = locked;
            }

            const metadata = extractEditableThingMetadata(thing);
            renderThingMetadataEntries(metadata);

            const bonuses = Array.isArray(thing?.attributeBonuses)
                ? thing.attributeBonuses
                : Array.isArray(thing?.metadata?.attributeBonuses)
                    ? thing.metadata.attributeBonuses
                    : [];
            renderThingAttributeBonuses(bonuses);
            refreshAllAttributeSelects();

            const causeStatusEffectOnTarget = thing?.causeStatusEffectOnTarget
                || thing?.metadata?.causeStatusEffectOnTarget
                || (thing?.causeStatusEffect?.applyToTarget ? thing.causeStatusEffect : null)
                || null;
            const causeStatusEffectOnEquipper = thing?.causeStatusEffectOnEquipper
                || thing?.metadata?.causeStatusEffectOnEquipper
                || (thing?.causeStatusEffect?.applyToEquipper ? thing.causeStatusEffect : null)
                || null;
            populateThingCauseStatusEffect(causeStatusEffectOnTarget, causeStatusEffectOnEquipper);

            updateThingStatusEffectVisibility();
            updateThingEditStatus('');
        }

        function formatPossessiveName(name, fallback = 'Character') {
            const base = typeof name === 'string' && name.trim() ? name.trim() : fallback;
            if (!base) {
                return fallback;
            }
            const lastChar = base.charAt(base.length - 1);
            return lastChar.toLowerCase() === 's' ? `${base}'` : `${base}'s`;
        }

        function scrollModalToTop(modal) {
            if (!modal) {
                return;
            }

            const safeScrollTo = (element) => {
                if (!element) {
                    return;
                }
                try {
                    if (typeof element.scrollTo === 'function') {
                        element.scrollTo(0, 0);
                        return;
                    }
                } catch (_) {
                    // fallback to scrollTop assignment below
                }
                element.scrollTop = 0;
            };

            safeScrollTo(modal);
            safeScrollTo(modal.querySelector('.modal__dialog'));
            safeScrollTo(modal.querySelector('.modal__body'));
        }

        async function showThingEditModal(thing, context = 'general', options = {}) {
            if (!thingEditModal || !thingEditForm || !npcModalBackdrop) {
                return;
            }

            const mode = options.mode === 'create' ? 'create' : 'edit';
            let resolvedThing = thing ? { ...thing } : {};

            if (mode === 'edit') {
                if (!thing || !thing.id) {
                    return;
                }

                const needsDetails = resolvedThing.level === undefined
                    || (resolvedThing.metadata && typeof resolvedThing.metadata === 'object'
                        && ('level' in resolvedThing.metadata));

                if (needsDetails) {
                    try {
                        const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data?.thing) {
                                resolvedThing = { ...data.thing };
                                cacheThingData(resolvedThing);
                            }
                        }
                    } catch (error) {
                        console.warn('Failed to fetch full item details:', error);
                    }
                }
            }

            await Promise.all([ensureGearSlotTypes(), ensureAttributeDefinitions()]);

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            populateThingEditForm(resolvedThing, {
                mode,
                itemOrScenery: options.itemOrScenery,
                title: options.title
            });

            currentThingEditContext = context;
            currentThingEditMode = mode;
            thingEditForm.dataset.thingContext = context;
            thingEditForm.dataset.thingMode = mode;

            if (mode === 'edit') {
                currentThingEditId = resolvedThing.id;
                currentThingCreationLocation = null;
                thingEditForm.dataset.thingId = resolvedThing.id;
            } else {
                currentThingEditId = null;
                currentThingCreationLocation = options.location || lastRenderedLocation || null;
                delete thingEditForm.dataset.thingId;

                if (thingEditTypeSelect) {
                    const defaultType = options.itemOrScenery === 'scenery' ? 'scenery' : 'item';
                    thingEditTypeSelect.value = defaultType;
                }
            }

            thingEditModal.removeAttribute('hidden');
            thingEditModal.setAttribute('aria-hidden', 'false');
            npcModalBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');
            scrollModalToTop(thingEditModal);

            setTimeout(() => {
                thingEditNameInput?.focus();
            }, 50);
        }

        let currentNpcEditId = null;
        let currentNpcOriginalHealthAttribute = '';
        let currentNpcOriginalMaxHealth = null;
        let currentNpcInventory = [];
        let currentNpcInventoryNpcId = null;
        let currentNpcViewId = null;
        let currentNpcDispositionId = null;
        let currentNpcDispositionData = null;
        let currentNpcNeedsTargetId = null;
        let currentNpcNeedsTargetType = null;
        let currentNpcNeedsData = null;
        let currentNpcMemoriesId = null;
        let currentNpcMemoriesName = '';
        let npcMemoriesDirty = false;
        let draggedNpcMemoryRow = null;
        let currentNpcGoalsId = null;
        let currentNpcGoalsName = '';
        let npcGoalsDirty = false;
        let draggedNpcGoalRow = null;
        let locationImageGenerationEnabled = true;
        let lastRenderedLocation = null;
        let currentThingEditId = null;
        let currentThingEditContext = null;
        let currentThingEditMode = 'edit';
        let currentThingCreationLocation = null;
        let currentThingLockedMetadata = {};

        function isNpcEditorAvailable() {
            return Boolean(npcEditModal && npcEditForm && npcModalBackdrop);
        }

        function formatNpcLabel(value) {
            if (!value) {
                return '';
            }
            return String(value)
                .replace(/_/g, ' ')
                .replace(/\b\w/g, (char) => char.toUpperCase());
        }

        function updateNpcEditStatus(message = '', type = null) {
            if (!npcEditStatus) {
                return;
            }
            npcEditStatus.textContent = message || '';
            npcEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcEditStatus.classList.add('is-success');
            }
        }

        function normalizeFactionId(value) {
            if (typeof value !== 'string') {
                return '';
            }
            const trimmed = value.trim();
            return trimmed || '';
        }

        async function loadFactionOptions({ force = false } = {}) {
            if (!force && Array.isArray(factionOptionsCache?.list) && factionOptionsCache.list.length) {
                return factionOptionsCache;
            }
            if (!force && factionOptionsPromise) {
                return factionOptionsPromise;
            }

            factionOptionsPromise = (async () => {
                const response = await fetch('/api/factions', { cache: 'no-store' });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }
                const list = Array.isArray(data.factions) ? data.factions : [];
                const map = new Map();
                list.forEach(entry => {
                    if (entry && entry.id) {
                        map.set(entry.id, entry);
                    }
                });
                factionOptionsCache = {
                    list,
                    map,
                    loadedAt: Date.now()
                };
                return factionOptionsCache;
            })();

            try {
                return await factionOptionsPromise;
            } finally {
                factionOptionsPromise = null;
            }
        }

        function resetFactionSelect(selectEl, noneLabel = 'None') {
            if (!selectEl) {
                return;
            }
            selectEl.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = noneLabel;
            selectEl.appendChild(option);
        }

        async function populateFactionSelect(selectEl, {
            selectedId = null,
            includeNone = true,
            noneLabel = 'None',
            allowUnknown = true,
            force = false
        } = {}) {
            if (!selectEl) {
                return;
            }

            const desired = normalizeFactionId(selectedId ?? selectEl.dataset.selectedFactionId);
            selectEl.dataset.selectedFactionId = desired;

            if (includeNone) {
                resetFactionSelect(selectEl, noneLabel);
            } else {
                selectEl.innerHTML = '';
            }
            selectEl.disabled = true;

            try {
                const { list, map } = await loadFactionOptions({ force });

                list.forEach(entry => {
                    if (!entry || !entry.id) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.value = entry.id;
                    option.textContent = entry.name || entry.id;
                    selectEl.appendChild(option);
                });

                if (desired && allowUnknown && !(map instanceof Map && map.has(desired))) {
                    const unknownOption = document.createElement('option');
                    unknownOption.value = desired;
                    unknownOption.textContent = `Unknown faction (${desired})`;
                    selectEl.appendChild(unknownOption);
                }

                selectEl.value = desired || '';
                selectEl.disabled = false;
            } catch (error) {
                console.warn('Failed to load factions:', error);
                selectEl.innerHTML = '';
                const option = document.createElement('option');
                option.value = desired || '';
                option.textContent = desired
                    ? `Factions unavailable (current: ${desired})`
                    : 'Factions unavailable';
                selectEl.appendChild(option);
                selectEl.value = desired || '';
                selectEl.disabled = true;
            }
        }

        async function resolveSelectedFactionId(selectEl, { label = 'faction' } = {}) {
            if (!selectEl) {
                return null;
            }
            const rawValue = normalizeFactionId(selectEl.value);
            const fallbackValue = normalizeFactionId(selectEl.dataset.selectedFactionId);
            const selectedValue = rawValue || (selectEl.disabled ? fallbackValue : rawValue);
            if (!selectedValue) {
                return null;
            }

            let directory = null;
            try {
                directory = await loadFactionOptions();
            } catch (error) {
                throw new Error(`Failed to load factions: ${error?.message || 'Unknown error'}`);
            }

            const map = directory?.map;
            if (!(map instanceof Map) || !map.has(selectedValue)) {
                throw new Error(`Selected ${label} "${selectedValue}" no longer exists. Choose another or None.`);
            }

            return selectedValue;
        }

        function clampDispositionValue(value, range = {}) {
            const numeric = Number(value);
            let resolved = Number.isFinite(numeric) ? numeric : 0;
            const min = Number.isFinite(range?.min) ? range.min : null;
            const max = Number.isFinite(range?.max) ? range.max : null;
            if (Number.isFinite(min) && resolved < min) {
                resolved = min;
            }
            if (Number.isFinite(max) && resolved > max) {
                resolved = max;
            }
            return Math.round(resolved);
        }

        function formatSignedValue(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric) || numeric === 0) {
                return '0';
            }
            return numeric > 0 ? `+${numeric}` : `${numeric}`;
        }

        function resolveDispositionIntensityLabel(thresholds, value, fallback = 'neutral') {
            if (!Array.isArray(thresholds) || thresholds.length === 0) {
                return fallback;
            }
            const sorted = thresholds
                .map(entry => ({
                    threshold: Number(entry?.threshold),
                    name: entry?.name || ''
                }))
                .filter(entry => Number.isFinite(entry.threshold) && entry.name)
                .sort((a, b) => a.threshold - b.threshold);

            if (!sorted.length) {
                return fallback;
            }

            let label = fallback;
            for (const entry of sorted) {
                if (value >= entry.threshold) {
                    label = entry.name;
                }
            }
            return label || fallback;
        }

        function formatDispositionThresholds(thresholds) {
            if (!Array.isArray(thresholds) || !thresholds.length) {
                return '';
            }
            const parts = thresholds
                .map(entry => {
                    const thresholdValue = Number(entry?.threshold);
                    const name = entry?.name || '';
                    if (!Number.isFinite(thresholdValue) || !name) {
                        return null;
                    }
                    return `${formatSignedValue(thresholdValue)} ‚Üí ${name}`;
                })
                .filter(Boolean);
            return parts.length ? `Thresholds: ${parts.join(' ¬∑ ')}` : '';
        }

        function setNpcDispositionStatus(message = '', type = null) {
            if (!npcDispositionStatus) {
                return;
            }
            npcDispositionStatus.textContent = message || '';
            npcDispositionStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcDispositionStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcDispositionStatus.classList.add('is-success');
            }
        }

        function setNpcDispositionDirty() {
            if (!npcDispositionSaveBtn) {
                return;
            }
            if (!currentNpcDispositionData || !Array.isArray(currentNpcDispositionData.dispositions)) {
                npcDispositionSaveBtn.disabled = true;
                return;
            }
            const hasChanges = currentNpcDispositionData.dispositions.some(entry => entry.value !== entry.originalValue);
            npcDispositionSaveBtn.disabled = !hasChanges;
        }

        function updateNpcDispositionSummary(payload) {
            if (!npcDispositionSummary) {
                return;
            }
            if (!payload || !payload.npc) {
                npcDispositionSummary.textContent = '';
                return;
            }

            const npcName = payload.npc?.name || 'NPC';
            const playerName = payload.player?.name || 'the player';
            const min = Number.isFinite(payload.range?.min) ? payload.range.min : null;
            const max = Number.isFinite(payload.range?.max) ? payload.range.max : null;
            const step = Number.isFinite(payload.range?.typicalStep) ? payload.range.typicalStep : null;
            const bigStep = Number.isFinite(payload.range?.typicalBigStep) ? payload.range.typicalBigStep : null;

            const parts = [`Adjust ${npcName}'s dispositions toward ${playerName}.`];
            if (Number.isFinite(min) && Number.isFinite(max)) {
                parts.push(`Range ${formatSignedValue(min)} to ${formatSignedValue(max)}.`);
            }
            const stepParts = [];
            if (Number.isFinite(step)) {
                stepParts.push(`${step}`);
            }
            if (Number.isFinite(bigStep)) {
                stepParts.push(`${bigStep}`);
            }
            if (stepParts.length) {
                const descriptor = stepParts.length === 1 ? stepParts[0] : stepParts.join(' / ');
                parts.push(`Use quick adjust buttons for ${descriptor} changes.`);
            }
            npcDispositionSummary.textContent = parts.join(' ');
        }

        function updateCachedNpcDispositions(npcId, payload) {
            const cache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            if (!cache || !npcId) {
                return null;
            }
            const baseNpc = cache.get(npcId) || { id: npcId, isNPC: true };
            const dispositionsTowardsPlayer = Array.isArray(payload?.dispositions)
                ? payload.dispositions.map(entry => ({
                    type: entry.label || entry.key || 'Disposition',
                    intensityName: entry.intensity || resolveDispositionIntensityLabel(entry.thresholds, entry.value, 'neutral'),
                    value: entry.value
                }))
                : [];
            const updatedNpc = {
                ...baseNpc,
                dispositionsTowardsPlayer
            };
            cache.set(npcId, updatedNpc);
            return updatedNpc;
        }

        function renderNpcDispositionEntries(data) {
            if (!npcDispositionList || !npcDispositionEmpty) {
                return;
            }

            npcDispositionList.innerHTML = '';

            if (!data || !Array.isArray(data.dispositions) || data.dispositions.length === 0) {
                npcDispositionEmpty.removeAttribute('hidden');
                setNpcDispositionDirty();
                return;
            }

            npcDispositionEmpty.setAttribute('hidden', '');

            const range = data.range || {};
            const min = Number.isFinite(range.min) ? range.min : -200;
            const max = Number.isFinite(range.max) ? range.max : 200;
            const step = Number.isFinite(range.typicalStep) ? range.typicalStep : null;
            const bigStep = Number.isFinite(range.typicalBigStep) ? range.typicalBigStep : null;

            data.dispositions.forEach(entry => {
                const normalizedValue = clampDispositionValue(entry.value, range);
                entry.value = normalizedValue;
                if (entry.originalValue === undefined || entry.originalValue === null) {
                    entry.originalValue = normalizedValue;
                }
                const intensityLabel = resolveDispositionIntensityLabel(entry.thresholds, normalizedValue, entry.intensity || 'neutral');
                entry.intensity = intensityLabel;

                const card = document.createElement('div');
                card.className = 'npc-disposition-entry';
                card.dataset.key = entry.key || '';

                const heading = document.createElement('div');
                heading.className = 'npc-disposition-heading';

                const labelEl = document.createElement('div');
                labelEl.className = 'npc-disposition-label';
                labelEl.textContent = entry.label || entry.key || 'Disposition';
                heading.appendChild(labelEl);

                const intensityEl = document.createElement('div');
                intensityEl.className = 'npc-disposition-intensity';
                intensityEl.textContent = `Intensity: ${intensityLabel} (${formatSignedValue(normalizedValue)})`;
                heading.appendChild(intensityEl);

                card.appendChild(heading);

                if (entry.description) {
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'npc-disposition-description';
                    descriptionEl.textContent = entry.description;
                    card.appendChild(descriptionEl);
                }

                const sliderRow = document.createElement('div');
                sliderRow.className = 'npc-disposition-slider-row';

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.className = 'npc-disposition-slider';
                slider.min = String(min);
                slider.max = String(max);
                slider.step = '1';
                slider.value = String(normalizedValue);
                sliderRow.appendChild(slider);
                card.appendChild(sliderRow);

                const controlRow = document.createElement('div');
                controlRow.className = 'npc-disposition-control-row';

                const valueWrapper = document.createElement('label');
                valueWrapper.className = 'npc-disposition-value-input';
                valueWrapper.textContent = 'Value';

                const numberInput = document.createElement('input');
                numberInput.type = 'number';
                numberInput.value = String(normalizedValue);
                numberInput.step = '1';
                numberInput.min = String(min);
                numberInput.max = String(max);
                valueWrapper.appendChild(numberInput);
                controlRow.appendChild(valueWrapper);

                const buttonsWrapper = document.createElement('div');
                buttonsWrapper.className = 'npc-disposition-buttons';

                const seenAdjustments = new Set();
                const addAdjustmentButton = (delta, label) => {
                    if (!Number.isFinite(delta) || seenAdjustments.has(delta)) {
                        return;
                    }
                    seenAdjustments.add(delta);
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.dataset.delta = String(delta);
                    button.textContent = label;
                    buttonsWrapper.appendChild(button);
                };

                if (Number.isFinite(bigStep) && bigStep > 0) {
                    addAdjustmentButton(-bigStep, `-${bigStep}`);
                }
                if (Number.isFinite(step) && step > 0) {
                    addAdjustmentButton(-step, `-${step}`);
                    addAdjustmentButton(step, `+${step}`);
                }
                if (Number.isFinite(bigStep) && bigStep > 0) {
                    addAdjustmentButton(bigStep, `+${bigStep}`);
                }
                if (!buttonsWrapper.childElementCount) {
                    addAdjustmentButton(-1, '-1');
                    addAdjustmentButton(1, '+1');
                }

                controlRow.appendChild(buttonsWrapper);
                card.appendChild(controlRow);

                const thresholdsLabel = formatDispositionThresholds(entry.thresholds);
                if (thresholdsLabel) {
                    const thresholdsEl = document.createElement('div');
                    thresholdsEl.className = 'npc-disposition-thresholds';
                    thresholdsEl.textContent = thresholdsLabel;
                    card.appendChild(thresholdsEl);
                }

                const applyValue = (nextValue) => {
                    const clampedValue = clampDispositionValue(nextValue, range);
                    slider.value = String(clampedValue);
                    numberInput.value = String(clampedValue);
                    const label = resolveDispositionIntensityLabel(entry.thresholds, clampedValue, entry.intensity || 'neutral');
                    intensityEl.textContent = `Intensity: ${label} (${formatSignedValue(clampedValue)})`;
                    entry.value = clampedValue;
                    entry.intensity = label;
                    setNpcDispositionDirty();
                };

                slider.addEventListener('input', () => {
                    applyValue(Number(slider.value));
                });

                numberInput.addEventListener('input', () => {
                    const parsed = Number(numberInput.value);
                    if (Number.isFinite(parsed)) {
                        applyValue(parsed);
                    }
                });

                numberInput.addEventListener('blur', () => {
                    applyValue(Number(numberInput.value));
                });

                buttonsWrapper.querySelectorAll('button').forEach(button => {
                    button.addEventListener('click', (event) => {
                        event.preventDefault();
                        const delta = Number(button.dataset.delta);
                        if (!Number.isFinite(delta)) {
                            return;
                        }
                        applyValue(entry.value + delta);
                    });
                });

                npcDispositionList.appendChild(card);
            });

            setNpcDispositionDirty();
        }

        function clampNeedValue(value, min, max) {
            let numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                numeric = Number.isFinite(min) ? min : 0;
            }
            if (Number.isFinite(min)) {
                numeric = Math.max(min, numeric);
            }
            if (Number.isFinite(max)) {
                numeric = Math.min(max, numeric);
            }
            return Math.round(numeric);
        }

        function resolveNeedThreshold(effectThresholds, value) {
            if (!Array.isArray(effectThresholds) || !effectThresholds.length) {
                return null;
            }
            if (!Number.isFinite(value)) {
                return null;
            }

            let resolved = null;
            for (const entry of effectThresholds) {
                if (!entry) {
                    continue;
                }
                const threshold = Number(entry.threshold);
                if (!Number.isFinite(threshold)) {
                    continue;
                }
                if (value >= threshold && (!resolved || threshold >= resolved.threshold)) {
                    resolved = {
                        threshold,
                        name: typeof entry.name === 'string' ? entry.name : '',
                        effect: typeof entry.effect === 'string' ? entry.effect : ''
                    };
                }
            }
            return resolved;
        }

        function updateCachedNpcNeeds(npcId, needs, options = {}) {
            const cache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            if (!cache || !npcId) {
                return null;
            }

            const baseNpc = cache.get(npcId) || { id: npcId, isNPC: options.isNPC !== undefined ? options.isNPC : true };
            const needBars = Array.isArray(needs)
                ? needs.map(bar => ({ ...bar }))
                : [];

            const updatedNpc = {
                ...baseNpc,
                isNPC: options.isNPC !== undefined ? options.isNPC : baseNpc.isNPC,
                needBars
            };

            cache.set(npcId, updatedNpc);
            return updatedNpc;
        }

        function setNpcNeedsStatus(message = '', type = null) {
            if (!npcNeedsStatus) {
                return;
            }
            npcNeedsStatus.textContent = message || '';
            npcNeedsStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcNeedsStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcNeedsStatus.classList.add('is-success');
            }
        }

        function setNpcNeedsDirty() {
            if (!npcNeedsSaveBtn) {
                return;
            }
            if (!currentNpcNeedsData || !Array.isArray(currentNpcNeedsData.needs)) {
                npcNeedsSaveBtn.disabled = true;
                return;
            }
            const hasChanges = currentNpcNeedsData.needs.some(entry => entry.value !== entry.originalValue);
            npcNeedsSaveBtn.disabled = !hasChanges;
        }

        function updateNpcNeedsSummary(payload) {
            if (!npcNeedsSummary) {
                return;
            }
            if (!payload) {
                npcNeedsSummary.textContent = '';
                return;
            }

            const subject = payload.player || payload.npc || {};
            const name = subject.name || 'the character';
            const isPlayer = Boolean(payload.player && !payload.player.isNPC);

            const notes = [`Adjust the need bars for ${name}.`];
            if (!isPlayer && payload.includePlayerOnly === false) {
                notes.push('Player-only needs are hidden for NPCs.');
            }
            npcNeedsSummary.textContent = notes.join(' ');
        }

        function renderNpcNeedsEntries(data) {
            if (!npcNeedsList || !npcNeedsEmpty) {
                return;
            }

            npcNeedsList.innerHTML = '';

            const needs = Array.isArray(data?.needs) ? data.needs : [];
            if (!needs.length) {
                npcNeedsEmpty.removeAttribute('hidden');
                setNpcNeedsDirty();
                return;
            }

            npcNeedsEmpty.setAttribute('hidden', '');

            needs.forEach(entry => {
                const min = Number.isFinite(Number(entry.min)) ? Number(entry.min) : 0;
                let max = Number.isFinite(Number(entry.max)) ? Number(entry.max) : null;
                if (!Number.isFinite(max)) {
                    max = min + Math.max(100, Math.abs(min) || 100);
                }
                if (max <= min) {
                    max = min + 100;
                }

                const normalizedValue = clampNeedValue(entry.value, min, max);
                entry.value = normalizedValue;
                if (entry.originalValue === undefined || entry.originalValue === null) {
                    entry.originalValue = normalizedValue;
                }

                const card = document.createElement('div');
                card.className = 'npc-needs-entry';
                card.dataset.needId = entry.id || '';

                const heading = document.createElement('div');
                heading.className = 'npc-needs-heading';

                const labelEl = document.createElement('div');
                labelEl.className = 'npc-needs-label';
                if (entry.icon) {
                    const iconEl = document.createElement('span');
                    iconEl.textContent = entry.icon;
                    iconEl.setAttribute('aria-hidden', 'true');
                    labelEl.appendChild(iconEl);
                }
                const nameSpan = document.createElement('span');
                nameSpan.textContent = entry.name || entry.id || 'Need';
                labelEl.appendChild(nameSpan);
                heading.appendChild(labelEl);

                const metaEl = document.createElement('div');
                metaEl.className = 'npc-needs-meta';
                const rangeLabel = document.createElement('span');
                rangeLabel.textContent = `Range ${min} ‚Äì ${max}`;
                metaEl.appendChild(rangeLabel);
                if (Number.isFinite(entry.changePerTurn) && entry.changePerTurn !== 0) {
                    const rateLabel = document.createElement('span');
                    rateLabel.textContent = `Œî/turn ${entry.changePerTurn > 0 ? `+${entry.changePerTurn}` : entry.changePerTurn}`;
                    metaEl.appendChild(rateLabel);
                }
                if (entry.playerOnly) {
                    const badge = document.createElement('span');
                    badge.textContent = 'Player-only';
                    badge.style.color = '#fde68a';
                    metaEl.appendChild(badge);
                }
                heading.appendChild(metaEl);
                card.appendChild(heading);

                if (entry.description) {
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'npc-needs-description';
                    descriptionEl.textContent = entry.description;
                    card.appendChild(descriptionEl);
                }

                const progress = document.createElement('div');
                progress.className = 'npc-needs-progress';
                if (entry.color) {
                    progress.style.setProperty('--npc-needs-color', entry.color);
                }
                const progressFill = document.createElement('div');
                progressFill.className = 'npc-needs-progress-fill';
                progress.appendChild(progressFill);
                card.appendChild(progress);

                const sliderRow = document.createElement('div');
                sliderRow.className = 'npc-needs-slider-row';

                const valueDisplay = document.createElement('span');
                valueDisplay.className = 'npc-needs-value-display';
                sliderRow.appendChild(valueDisplay);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.className = 'npc-needs-slider';
                slider.min = String(min);
                slider.max = String(max);
                slider.step = '1';
                slider.value = String(normalizedValue);
                sliderRow.appendChild(slider);

                card.appendChild(sliderRow);

                const inputRow = document.createElement('div');
                inputRow.className = 'npc-needs-input-row';

                const valueWrapper = document.createElement('label');
                valueWrapper.className = 'npc-needs-value-input';
                valueWrapper.textContent = 'Value';
                const numberInput = document.createElement('input');
                numberInput.type = 'number';
                numberInput.value = String(normalizedValue);
                numberInput.step = '1';
                numberInput.min = String(min);
                numberInput.max = String(max);
                valueWrapper.appendChild(numberInput);
                inputRow.appendChild(valueWrapper);

                const buttonsWrapper = document.createElement('div');
                buttonsWrapper.className = 'npc-needs-buttons';

                const addButton = (label, action, delta = 0) => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.dataset.action = action;
                    button.dataset.delta = String(delta);
                    button.textContent = label;
                    buttonsWrapper.appendChild(button);
                };

                addButton('Min', 'min');
                const rangeSpan = max - min;
                const step = Math.max(1, Math.round(rangeSpan / 10));
                addButton(`-${step}`, 'delta', -step);
                addButton(`+${step}`, 'delta', step);
                addButton('Max', 'max');

                inputRow.appendChild(buttonsWrapper);
                card.appendChild(inputRow);

                const thresholdLabel = resolveNeedThreshold(entry.effectThresholds, normalizedValue);
                const thresholdEl = document.createElement('div');
                thresholdEl.className = 'npc-needs-thresholds';
                thresholdEl.textContent = thresholdLabel
                    ? `Current effect: ${thresholdLabel.name || thresholdLabel.effect || 'None'}`
                    : 'Current effect: None';
                card.appendChild(thresholdEl);

                const updateDisplays = (current) => {
                    const denominator = max - min;
                    const ratio = denominator ? Math.max(0, Math.min(1, (current - min) / denominator)) : 1;
                    progressFill.style.width = `${(ratio * 100).toFixed(1)}%`;
                    valueDisplay.textContent = `${current} / ${max}`;
                    const resolvedThreshold = resolveNeedThreshold(entry.effectThresholds, current);
                    thresholdEl.textContent = resolvedThreshold
                        ? `Current effect: ${resolvedThreshold.name || resolvedThreshold.effect || 'None'}`
                        : 'Current effect: None';
                };

                updateDisplays(normalizedValue);

                const applyValue = (nextValue) => {
                    const clampedValue = clampNeedValue(nextValue, min, max);
                    slider.value = String(clampedValue);
                    numberInput.value = String(clampedValue);
                    entry.value = clampedValue;
                    updateDisplays(clampedValue);
                    setNpcNeedsDirty();
                };

                slider.addEventListener('input', () => {
                    applyValue(Number(slider.value));
                });

                numberInput.addEventListener('input', () => {
                    const parsed = Number(numberInput.value);
                    if (Number.isFinite(parsed)) {
                        applyValue(parsed);
                    }
                });

                numberInput.addEventListener('blur', () => {
                    applyValue(Number(numberInput.value));
                });

                buttonsWrapper.querySelectorAll('button').forEach(button => {
                    button.addEventListener('click', (event) => {
                        event.preventDefault();
                        const action = button.dataset.action;
                        if (action === 'min') {
                            applyValue(min);
                        } else if (action === 'max') {
                            applyValue(max);
                        } else if (action === 'delta') {
                            const delta = Number(button.dataset.delta);
                            if (Number.isFinite(delta)) {
                                applyValue(entry.value + delta);
                            }
                        }
                    });
                });

                npcNeedsList.appendChild(card);
            });

            setNpcNeedsDirty();
        }

        function updateThingEditStatus(message = '', type = null) {
            if (!thingEditStatus) {
                return;
            }
            thingEditStatus.textContent = message || '';
            thingEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                thingEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                thingEditStatus.classList.add('is-success');
            }
        }

        function resolveDefaultHealthAttributeKey(attributeKeys = [], preferred = '') {
            if (!Array.isArray(attributeKeys)) {
                return preferred || '';
            }

            const normalizedPreferred = typeof preferred === 'string' ? preferred.trim().toLowerCase() : '';
            if (normalizedPreferred) {
                const preferredMatch = attributeKeys.find(key => typeof key === 'string' && key.toLowerCase() === normalizedPreferred);
                if (preferredMatch) {
                    return preferredMatch;
                }
            }

            const preferredList = ['constitution', 'endurance', 'stamina', 'vitality'];
            for (const candidate of preferredList) {
                const match = attributeKeys.find(key => typeof key === 'string' && key.toLowerCase() === candidate);
                if (match) {
                    return match;
                }
            }

            return attributeKeys[0] || '';
        }

        function getNpcAttributesFromInputs() {
            const attributes = {};
            if (!npcEditAttributesContainer) {
                return attributes;
            }
            npcEditAttributesContainer.querySelectorAll('input[data-attribute]').forEach(input => {
                const attributeKey = input.dataset.attribute;
                if (!attributeKey) {
                    return;
                }
                const attributeValue = Number.parseInt(input.value ?? '', 10);
                if (Number.isFinite(attributeValue)) {
                    attributes[attributeKey] = attributeValue;
                }
            });
            return attributes;
        }

        function populateHealthAttributeOptions(attributes = {}, current = '') {
            if (!npcEditHealthAttributeSelect) {
                return;
            }

            const attributeKeys = Object.keys(attributes || {});
            const uniqueKeys = Array.from(new Set(attributeKeys.filter(key => typeof key === 'string' && key.trim().length > 0)));
            const normalizedCurrent = typeof current === 'string' ? current.trim() : '';
            if (normalizedCurrent && !uniqueKeys.some(key => key.toLowerCase() === normalizedCurrent.toLowerCase())) {
                uniqueKeys.push(normalizedCurrent);
            }

            npcEditHealthAttributeSelect.innerHTML = '';

            if (!uniqueKeys.length) {
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = 'No attributes available';
                npcEditHealthAttributeSelect.appendChild(placeholder);
                npcEditHealthAttributeSelect.disabled = true;
                return;
            }

            npcEditHealthAttributeSelect.disabled = false;
            const resolved = resolveDefaultHealthAttributeKey(uniqueKeys, normalizedCurrent);

            uniqueKeys.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = formatNpcLabel(key);
                if (key === resolved) {
                    option.selected = true;
                }
                npcEditHealthAttributeSelect.appendChild(option);
            });

            npcEditHealthAttributeSelect.value = resolved || '';
        }

        function updateNpcMaxHealth() {
            if (!npcEditMaxHealthDisplay) {
                return;
            }

            const resolvedValue = Number.isFinite(currentNpcOriginalMaxHealth)
                ? Math.round(currentNpcOriginalMaxHealth)
                : null;
            npcEditMaxHealthDisplay.textContent = resolvedValue !== null ? resolvedValue : '‚Äî';
        }

        function populateNpcAttributes(attributes = {}) {
            if (!npcEditAttributesContainer) {
                return;
            }
            npcEditAttributesContainer.innerHTML = '';
            const entries = Object.entries(attributes || {});
            if (!entries.length) {
                const empty = document.createElement('div');
                empty.className = 'npc-edit-empty';
                empty.textContent = 'No attributes available.';
                npcEditAttributesContainer.appendChild(empty);
                return;
            }
            entries.sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));
            entries.forEach(([key, value]) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'npc-attribute-item';

                const label = document.createElement('label');
                const inputId = `npc-attribute-${key.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
                label.setAttribute('for', inputId);
                label.textContent = formatNpcLabel(key);

                const input = document.createElement('input');
                input.type = 'number';
                input.id = inputId;
                input.dataset.attribute = key;
                input.step = '1';
                input.value = Number.isFinite(Number(value)) ? Number(value) : '';

                wrapper.appendChild(label);
                wrapper.appendChild(input);
                input.addEventListener('input', updateNpcMaxHealth);
                input.addEventListener('change', updateNpcMaxHealth);
                npcEditAttributesContainer.appendChild(wrapper);
            });
        }

        function createSkillRow(skill = {}) {
            if (!npcEditSkillsContainer) {
                return null;
            }
            const row = document.createElement('div');
            row.className = 'npc-skill-row';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'npc-skill-name';
            nameInput.placeholder = 'Skill name';
            nameInput.autocomplete = 'off';
            nameInput.value = skill.name || '';

            const valueInput = document.createElement('input');
            valueInput.type = 'number';
            valueInput.className = 'npc-skill-value';
            valueInput.placeholder = 'Value';
            valueInput.step = '1';
            if (skill.value !== undefined && skill.value !== null && skill.value !== '') {
                const numeric = Number(skill.value);
                valueInput.value = Number.isFinite(numeric) ? numeric : '';
            } else {
                valueInput.value = '';
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(nameInput);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);
            npcEditSkillsContainer.appendChild(row);
            return row;
        }

        function populateNpcSkills(skills = {}) {
            if (!npcEditSkillsContainer) {
                return;
            }
            npcEditSkillsContainer.innerHTML = '';
            const entries = Array.isArray(skills)
                ? skills
                : Object.entries(skills || {}).map(([name, value]) => ({ name, value }));
            if (!entries.length) {
                createSkillRow({ name: '', value: '' });
                return;
            }
            entries.sort((a, b) => (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' }));
            entries.forEach(entry => createSkillRow(entry));
        }

        function createAbilityRow(ability = {}) {
            if (!npcEditAbilitiesContainer) {
                return null;
            }
            const row = document.createElement('div');
            row.className = 'npc-ability-row';

            const main = document.createElement('div');
            main.className = 'npc-ability-row-main';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'npc-ability-name';
            nameInput.placeholder = 'Ability name';
            nameInput.autocomplete = 'off';
            nameInput.value = ability.name || '';

            const typeSelect = document.createElement('select');
            typeSelect.className = 'npc-ability-type';
            ['Passive', 'Active', 'Triggered'].forEach(optionValue => {
                const option = document.createElement('option');
                option.value = optionValue;
                option.textContent = optionValue;
                typeSelect.appendChild(option);
            });
            const normalizedType = typeof ability.type === 'string'
                ? ability.type.trim().toLowerCase()
                : '';
            if (normalizedType) {
                const match = ['passive', 'active', 'triggered'].find(value => value === normalizedType);
                if (match) {
                    typeSelect.value = match.charAt(0).toUpperCase() + match.slice(1);
                }
            }

            const levelInput = document.createElement('input');
            levelInput.type = 'number';
            levelInput.className = 'npc-ability-level';
            levelInput.min = '1';
            levelInput.max = '20';
            levelInput.step = '1';
            const numericLevel = Number.parseInt(ability.level, 10);
            levelInput.value = Number.isFinite(numericLevel) ? numericLevel : 1;

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            main.appendChild(nameInput);
            main.appendChild(typeSelect);
            main.appendChild(levelInput);
            main.appendChild(removeBtn);

            const descriptionTextarea = document.createElement('textarea');
            descriptionTextarea.className = 'npc-ability-description';
            descriptionTextarea.rows = 2;
            descriptionTextarea.placeholder = 'Description';
            descriptionTextarea.value = ability.description || '';

            row.appendChild(main);
            const shortDescriptionInput = document.createElement('input');
            shortDescriptionInput.type = 'text';
            shortDescriptionInput.className = 'npc-ability-short-description';
            shortDescriptionInput.placeholder = 'Short description';
            shortDescriptionInput.autocomplete = 'off';
            shortDescriptionInput.required = true;
            shortDescriptionInput.value = ability.shortDescription || '';

            row.appendChild(shortDescriptionInput);
            row.appendChild(descriptionTextarea);
            npcEditAbilitiesContainer.appendChild(row);
            return row;
        }

        function populateNpcAbilities(abilities = []) {
            if (!npcEditAbilitiesContainer) {
                return;
            }
            npcEditAbilitiesContainer.innerHTML = '';
            const entries = Array.isArray(abilities) ? abilities : [];
            if (!entries.length) {
                createAbilityRow({});
                return;
            }
            entries.forEach(ability => createAbilityRow(ability));
        }

        function createNpcStatusEffectRow(effect = {}) {
            if (!npcStatusEffectsList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-status-row';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'thing-edit-status-name';
            nameInput.placeholder = 'Name (optional)';
            nameInput.autocomplete = 'off';
            nameInput.value = effect.name || '';

            const descriptionInput = document.createElement('textarea');
            descriptionInput.className = 'thing-edit-status-description';
            descriptionInput.rows = 2;
            descriptionInput.placeholder = 'Description';
            descriptionInput.value = effect.description || effect.text || '';

            const durationInput = document.createElement('input');
            durationInput.type = 'text';
            durationInput.className = 'thing-edit-status-duration';
            durationInput.placeholder = 'Duration (e.g. 3 or permanent)';
            if (effect.duration !== undefined && effect.duration !== null && effect.duration !== '') {
                durationInput.value = String(effect.duration);
            }

            const modifiersContainer = document.createElement('div');
            modifiersContainer.className = 'thing-modifier-list';

            const addModifierBtn = document.createElement('button');
            addModifierBtn.type = 'button';
            addModifierBtn.className = 'npc-edit-add-btn';
            addModifierBtn.textContent = 'Add Modifier';
            addModifierBtn.addEventListener('click', () => {
                modifiersContainer.appendChild(thingModifierTemplates.createRow(null));
            });

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(nameInput);
            row.appendChild(descriptionInput);
            row.appendChild(durationInput);
            row.appendChild(modifiersContainer);
            row.appendChild(addModifierBtn);
            row.appendChild(removeBtn);

            npcStatusEffectsList.appendChild(row);

            const existingModifiers = [
                ...(Array.isArray(effect.attributes) ? effect.attributes.map(entry => ({ attribute: entry.attribute || entry.name, modifier: entry.modifier })) : []),
                ...(Array.isArray(effect.skills) ? effect.skills.map(entry => ({ skill: entry.skill || entry.name, modifier: entry.modifier })) : []),
                ...(Array.isArray(effect.needBars) ? effect.needBars.map(entry => ({ name: entry.name || entry.bar, delta: entry.delta })) : [])
            ];
            thingModifierTemplates.renderList(modifiersContainer, existingModifiers);

            return row;
        }

        function renderNpcStatusEffects(effects = []) {
            if (!npcStatusEffectsList) {
                return;
            }
            npcStatusEffectsList.innerHTML = '';
            const entries = Array.isArray(effects) ? effects : [];
            if (!entries.length) {
                createNpcStatusEffectRow({});
                return;
            }
            entries.forEach(effect => createNpcStatusEffectRow(effect));
        }

        function collectNpcStatusEffects() {
            if (!npcStatusEffectsList) {
                return [];
            }
            const effects = [];
            npcStatusEffectsList.querySelectorAll('.thing-edit-status-row').forEach(row => {
                const name = row.querySelector('.thing-edit-status-name')?.value?.trim();
                const description = row.querySelector('.thing-edit-status-description')?.value?.trim();
                if (!name && !description) {
                    return;
                }
                const effect = {};
                if (name) {
                    effect.name = name;
                }
                effect.description = description || name || '';

                const durationRaw = row.querySelector('.thing-edit-status-duration')?.value?.trim();
                if (durationRaw) {
                    const numeric = Number.parseInt(durationRaw, 10);
                    effect.duration = Number.isFinite(numeric) ? numeric : durationRaw;
                }

                const modifierContainer = row.querySelector('.thing-modifier-list');
                const modifiers = thingModifierTemplates.collect(modifierContainer);
                if (modifiers.attributes.length) {
                    effect.attributes = modifiers.attributes;
                }
                if (modifiers.skills.length) {
                    effect.skills = modifiers.skills;
                }
                if (modifiers.needBars.length) {
                    effect.needBars = modifiers.needBars;
                }

                effects.push(effect);
            });
            return effects;
        }

        function showNpcEditModal(npc) {
            if (!isNpcEditorAvailable() || !npc) {
                return;
            }

            currentNpcEditId = npc.id || null;
            currentNpcOriginalHealthAttribute = npc.healthAttribute || '';
            if (npcEditModalTitle) {
                npcEditModalTitle.textContent = npc.name ? `Edit ${npc.name}` : 'Edit NPC';
            }

            if (npcEditIdInput) {
                npcEditIdInput.value = npc.id || '';
            }
            if (npcEditNameInput) {
                npcEditNameInput.value = npc.name || '';
            }
            if (npcEditShortDescriptionInput) {
                npcEditShortDescriptionInput.value = npc.shortDescription || '';
            }
            if (npcEditRaceInput) {
                npcEditRaceInput.value = npc.race || '';
            }
            if (npcEditClassInput) {
                npcEditClassInput.value = npc.class || '';
            }
            if (npcEditFactionSelect) {
                populateFactionSelect(npcEditFactionSelect, {
                    selectedId: npc.factionId || ''
                });
            }
            if (npcEditLevelInput) {
                const numericLevel = Number.parseInt(npc.level, 10);
                npcEditLevelInput.value = Number.isFinite(numericLevel) ? numericLevel : '';
            }
            if (npcEditHealthInput) {
                const numericHealth = Number.parseInt(npc.health, 10);
                npcEditHealthInput.value = Number.isFinite(numericHealth) ? numericHealth : '';
            }
            const numericMax = Number.parseInt(npc.maxHealth, 10);
            currentNpcOriginalMaxHealth = Number.isFinite(numericMax) ? numericMax : null;
            updateNpcMaxHealth();
            if (npcEditUnspentInput) {
                const numericUnspent = Number.parseInt(npc.unspentSkillPoints, 10);
                npcEditUnspentInput.value = Number.isFinite(numericUnspent) ? numericUnspent : 0;
            }
            if (npcEditCurrencyInput) {
                const numericCurrency = Number.parseInt(npc.currency, 10);
                npcEditCurrencyInput.value = Number.isFinite(numericCurrency) && numericCurrency >= 0 ? numericCurrency : '';
            }
            if (npcEditExperienceInput) {
                const numericExperience = Number.parseInt(npc.experience, 10);
                npcEditExperienceInput.value = Number.isFinite(numericExperience) && numericExperience >= 0 ? numericExperience : '';
            }
            if (npcEditDescriptionInput) {
                npcEditDescriptionInput.value = npc.description || '';
            }
            const personalityDetails = npc.personality || {};
            if (npcEditPersonalityTypeInput) {
                npcEditPersonalityTypeInput.value = npc.personalityType
                    ?? personalityDetails.type
                    ?? '';
            }
            if (npcEditPersonalityTraitsInput) {
                npcEditPersonalityTraitsInput.value = npc.personalityTraits
                    ?? personalityDetails.traits
                    ?? '';
            }
            if (npcEditPersonalityNotesInput) {
                npcEditPersonalityNotesInput.value = npc.personalityNotes
                    ?? personalityDetails.notes
                    ?? '';
            }

            populateNpcAttributes(npc.attributes || {});
            populateNpcSkills(npc.skills || {});
            populateNpcAbilities(Array.isArray(npc.abilities) ? npc.abilities : []);
            const intrinsicStatusEffects = Array.isArray(npc.intrinsicStatusEffects)
                ? npc.intrinsicStatusEffects
                : (Array.isArray(npc.statusEffects) ? npc.statusEffects : []);
            renderNpcStatusEffects(intrinsicStatusEffects);
            populateHealthAttributeOptions(npc.attributes || {}, npc.healthAttribute || '');
            updateNpcMaxHealth();

            updateNpcEditStatus('');

            npcEditForm.dataset.npcId = currentNpcEditId || '';
            npcEditModal.removeAttribute('hidden');
            npcEditModal.setAttribute('aria-hidden', 'false');
            npcEditBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');
            scrollModalToTop(npcEditModal);

            setTimeout(() => {
                npcEditNameInput?.focus();
            }, 50);
        }

        function closeNpcEditModal() {
            if (!isNpcEditorAvailable()) {
                return;
            }
            npcEditModal.setAttribute('aria-hidden', 'true');
            npcEditModal.setAttribute('hidden', '');
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
            currentNpcEditId = null;
            currentNpcOriginalHealthAttribute = '';
            currentNpcOriginalMaxHealth = null;
            updateNpcEditStatus('');
        }

        function closeNpcInventoryModal() {
            if (!npcInventoryModal) {
                return;
            }
            npcInventoryModal.setAttribute('aria-hidden', 'true');
            npcInventoryModal.setAttribute('hidden', '');
            npcInventoryGrid.innerHTML = '';
            npcInventoryEmpty.style.display = 'block';
            npcInventoryCount.textContent = '0 items';
            if (npcInventoryFilterInput) {
                npcInventoryFilterInput.value = '';
            }
            if (npcInventoryShowAllRadio) {
                npcInventoryShowAllRadio.checked = true;
            }
            if (npcInventoryEquippedOnlyRadio) {
                npcInventoryEquippedOnlyRadio.checked = false;
            }
            if (npcInventoryEquippableOnlyRadio) {
                npcInventoryEquippableOnlyRadio.checked = false;
            }
            if (npcInventoryNonEquippableOnlyRadio) {
                npcInventoryNonEquippableOnlyRadio.checked = false;
            }
            if (npcInventoryEmpty) {
                npcInventoryEmpty.textContent = npcInventoryEmptyDefaultText;
            }
            currentNpcInventory = [];
            currentNpcInventoryNpcId = null;
            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (editHidden && viewHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeNpcDispositionModal() {
            if (!npcDispositionModal) {
                return;
            }
            npcDispositionModal.setAttribute('aria-hidden', 'true');
            npcDispositionModal.setAttribute('hidden', '');
            currentNpcDispositionId = null;
            currentNpcDispositionData = null;
            if (npcDispositionList) {
                npcDispositionList.innerHTML = '';
                npcDispositionList.removeAttribute('aria-busy');
            }
            if (npcDispositionSummary) {
                npcDispositionSummary.textContent = '';
            }
            if (npcDispositionLoading) {
                npcDispositionLoading.setAttribute('hidden', '');
            }
            setNpcDispositionStatus('', null);
            if (npcDispositionSaveBtn) {
                npcDispositionSaveBtn.disabled = true;
            }
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeNpcNeedsModal() {
            if (!npcNeedsModal) {
                return;
            }
            npcNeedsModal.setAttribute('aria-hidden', 'true');
            npcNeedsModal.setAttribute('hidden', '');
            currentNpcNeedsTargetId = null;
            currentNpcNeedsTargetType = null;
            currentNpcNeedsData = null;
            if (npcNeedsList) {
                npcNeedsList.innerHTML = '';
                npcNeedsList.removeAttribute('aria-busy');
            }
            if (npcNeedsSummary) {
                npcNeedsSummary.textContent = '';
            }
            if (npcNeedsLoading) {
                npcNeedsLoading.setAttribute('hidden', '');
            }
            setNpcNeedsStatus('', null);
            if (npcNeedsSaveBtn) {
                npcNeedsSaveBtn.disabled = true;
            }
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function setNpcMemoriesStatus(message = '', type = null) {
            if (!npcMemoriesStatus) {
                return;
            }
            npcMemoriesStatus.textContent = message || '';
            npcMemoriesStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcMemoriesStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcMemoriesStatus.classList.add('is-success');
            }
        }

        function resetNpcMemoriesDirty() {
            npcMemoriesDirty = false;
            if (npcMemoriesSaveBtn) {
                npcMemoriesSaveBtn.disabled = true;
            }
        }

        function markNpcMemoriesDirty() {
            npcMemoriesDirty = true;
            if (npcMemoriesSaveBtn) {
                npcMemoriesSaveBtn.disabled = false;
            }
        }

        function setNpcGoalsStatus(message = '', type = null) {
            if (!npcGoalsStatus) {
                return;
            }
            npcGoalsStatus.textContent = message || '';
            npcGoalsStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcGoalsStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcGoalsStatus.classList.add('is-success');
            }
        }

        function resetNpcGoalsDirty() {
            npcGoalsDirty = false;
            if (npcGoalsSaveBtn) {
                npcGoalsSaveBtn.disabled = true;
            }
        }

        function markNpcGoalsDirty() {
            npcGoalsDirty = true;
            if (npcGoalsSaveBtn) {
                npcGoalsSaveBtn.disabled = false;
            }
        }

        function createNpcMemoryRow(value = '') {
            const row = document.createElement('div');
            row.className = 'npc-memory-row';
            row.setAttribute('role', 'listitem');

            const handle = document.createElement('button');
            handle.type = 'button';
            handle.className = 'npc-memory-handle';
            handle.setAttribute('aria-label', 'Reorder memory');
            handle.textContent = '‚â°';
            handle.draggable = true;

            const textarea = document.createElement('textarea');
            textarea.className = 'npc-memory-text';
            textarea.rows = 3;
            textarea.value = value || '';
            textarea.addEventListener('input', () => {
                markNpcMemoriesDirty();
            });

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'npc-memory-delete';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
                row.remove();
                markNpcMemoriesDirty();
                if (npcMemoriesList && !npcMemoriesList.children.length) {
                    npcMemoriesList.appendChild(createNpcMemoryRow(''));
                }
            });

            handle.addEventListener('dragstart', (event) => {
                draggedNpcMemoryRow = row;
                row.classList.add('dragging');
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', 'memory');
            });

            handle.addEventListener('dragend', () => {
                if (draggedNpcMemoryRow === row) {
                    draggedNpcMemoryRow = null;
                }
                row.classList.remove('dragging');
            });

            row.append(handle, textarea, deleteButton);
            return row;
        }

        function renderNpcMemories(memories = []) {
            if (!npcMemoriesList) {
                return;
            }
            npcMemoriesList.innerHTML = '';
            const entries = Array.isArray(memories) && memories.length ? memories : [''];
            entries.forEach(memory => {
                npcMemoriesList.appendChild(createNpcMemoryRow(memory));
            });
            resetNpcMemoriesDirty();
        }

        function createNpcGoalRow(value = '') {
            const row = document.createElement('div');
            row.className = 'npc-goal-row';
            row.setAttribute('role', 'listitem');

            const handle = document.createElement('button');
            handle.type = 'button';
            handle.className = 'npc-goal-handle';
            handle.setAttribute('aria-label', 'Reorder goal');
            handle.textContent = '‚â°';
            handle.draggable = true;

            const textarea = document.createElement('textarea');
            textarea.className = 'npc-goal-text';
            textarea.rows = 2;
            textarea.value = value || '';
            textarea.addEventListener('input', () => {
                markNpcGoalsDirty();
            });

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'npc-goal-delete';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
                row.remove();
                markNpcGoalsDirty();
                if (npcGoalsList && !npcGoalsList.children.length) {
                    npcGoalsList.appendChild(createNpcGoalRow(''));
                }
            });

            handle.addEventListener('dragstart', (event) => {
                draggedNpcGoalRow = row;
                row.classList.add('dragging');
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', 'goal');
            });

            handle.addEventListener('dragend', () => {
                if (draggedNpcGoalRow === row) {
                    draggedNpcGoalRow = null;
                }
                row.classList.remove('dragging');
            });

            row.append(handle, textarea, deleteButton);
            return row;
        }

        function renderNpcGoals(goals = []) {
            if (!npcGoalsList) {
                return;
            }
            npcGoalsList.innerHTML = '';
            const entries = Array.isArray(goals) && goals.length ? goals : [''];
            entries.forEach(goal => {
                npcGoalsList.appendChild(createNpcGoalRow(goal));
            });
            resetNpcGoalsDirty();
        }

        function collectNpcMemories() {
            if (!npcMemoriesList) {
                return [];
            }
            return Array.from(npcMemoriesList.querySelectorAll('.npc-memory-text'))
                .map(field => (typeof field.value === 'string' ? field.value.trim() : ''))
                .filter(entry => entry.length > 0);
        }

        function closeNpcMemoriesModal() {
            if (!npcMemoriesModal) {
                return;
            }
            npcMemoriesModal.setAttribute('aria-hidden', 'true');
            npcMemoriesModal.setAttribute('hidden', '');
            currentNpcMemoriesId = null;
            currentNpcMemoriesName = '';
            draggedNpcMemoryRow = null;
            if (npcMemoriesList) {
                npcMemoriesList.innerHTML = '';
            }
            setNpcMemoriesStatus('', null);
            resetNpcMemoriesDirty();
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        async function showNpcMemoriesModal(target) {
            if (!target || !npcMemoriesModal || !npcModalBackdrop) {
                return;
            }

            const npcId = typeof target.id === 'string' ? target.id : null;
            if (!npcId) {
                console.warn('Unable to open memories editor: NPC id missing');
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            const latestNpc = npcDataCache?.get(npcId) || target;
            const memories = Array.isArray(latestNpc?.importantMemories)
                ? latestNpc.importantMemories.map(entry => (typeof entry === 'string' ? entry : '')).filter(Boolean)
                : [];

            currentNpcMemoriesId = npcId;
            currentNpcMemoriesName = latestNpc?.name || target.name || 'Character';
            draggedNpcMemoryRow = null;
            setNpcMemoriesStatus('', null);
            renderNpcMemories(memories);

            npcModalBackdrop.removeAttribute('hidden');
            npcMemoriesModal.removeAttribute('hidden');
            npcMemoriesModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcMemoriesModalTitle) {
                npcMemoriesModalTitle.textContent = `${formatPossessiveName(currentNpcMemoriesName, 'Character')} Memories`;
            }
            scrollModalToTop(npcMemoriesModal);

            const firstField = npcMemoriesList?.querySelector('.npc-memory-text');
            if (firstField) {
                firstField.focus();
            }
        }

        async function saveNpcMemories() {
            if (!currentNpcMemoriesId) {
                return;
            }
            const memories = collectNpcMemories();

            try {
                setNpcMemoriesStatus('Saving memories...');
                if (npcMemoriesSaveBtn) {
                    npcMemoriesSaveBtn.disabled = true;
                }

                const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcMemoriesId)}/memories`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ memories })
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setNpcMemoriesStatus('Memories saved.', 'success');
                resetNpcMemoriesDirty();

                const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                if (npcDataCache) {
                    const cached = npcDataCache.get(currentNpcMemoriesId) || {};
                    npcDataCache.set(currentNpcMemoriesId, { ...cached, importantMemories: memories.slice(0) });
                }

                if (typeof window.loadCurrentLocation === 'function') {
                    await window.loadCurrentLocation();
                }
                window.refreshParty?.();

                closeNpcMemoriesModal();
            } catch (error) {
                console.warn('Failed to save NPC memories:', error);
                setNpcMemoriesStatus(error?.message || 'Failed to save memories.', 'error');
                if (npcMemoriesSaveBtn) {
                    npcMemoriesSaveBtn.disabled = false;
                }
            }
        }

        function collectNpcGoals() {
            if (!npcGoalsList) {
                return [];
            }
            return Array.from(npcGoalsList.querySelectorAll('.npc-goal-text'))
                .map(field => (typeof field.value === 'string' ? field.value.trim() : ''))
                .filter(entry => entry.length > 0);
        }

        function closeNpcGoalsModal() {
            if (!npcGoalsModal) {
                return;
            }
            npcGoalsModal.setAttribute('aria-hidden', 'true');
            npcGoalsModal.setAttribute('hidden', '');
            currentNpcGoalsId = null;
            currentNpcGoalsName = '';
            draggedNpcGoalRow = null;
            if (npcGoalsList) {
                npcGoalsList.innerHTML = '';
            }
            setNpcGoalsStatus('', null);
            resetNpcGoalsDirty();
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        async function showNpcGoalsModal(target) {
            if (!target || !npcGoalsModal || !npcModalBackdrop) {
                return;
            }

            const npcId = typeof target.id === 'string' ? target.id : null;
            if (!npcId) {
                console.warn('Unable to open goals editor: NPC id missing');
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            const latestNpc = npcDataCache?.get(npcId) || target;
            let goals = [];
            if (Array.isArray(latestNpc?.personality?.goals)) {
                goals = latestNpc.personality.goals
                    .map(entry => (typeof entry === 'string' ? entry : ''))
                    .filter(Boolean);
            } else if (Array.isArray(latestNpc?.goals)) {
                goals = latestNpc.goals
                    .map(entry => (typeof entry === 'string' ? entry : ''))
                    .filter(Boolean);
            }

            currentNpcGoalsId = npcId;
            currentNpcGoalsName = latestNpc?.name || target.name || 'Character';
            draggedNpcGoalRow = null;
            setNpcGoalsStatus('', null);
            renderNpcGoals(goals);

            npcModalBackdrop.removeAttribute('hidden');
            npcGoalsModal.removeAttribute('hidden');
            npcGoalsModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcGoalsModalTitle) {
                npcGoalsModalTitle.textContent = `${formatPossessiveName(currentNpcGoalsName, 'Character')} Goals`;
            }
            scrollModalToTop(npcGoalsModal);

            const firstField = npcGoalsList?.querySelector('.npc-goal-text');
            if (firstField) {
                firstField.focus();
            }
        }

        async function saveNpcGoals() {
            if (!currentNpcGoalsId) {
                return;
            }
            const goals = collectNpcGoals();

            try {
                setNpcGoalsStatus('Saving goals...');
                if (npcGoalsSaveBtn) {
                    npcGoalsSaveBtn.disabled = true;
                }

                const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcGoalsId)}/goals`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ goals })
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setNpcGoalsStatus('Goals saved.', 'success');
                resetNpcGoalsDirty();

                const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                if (npcDataCache) {
                    const cached = npcDataCache.get(currentNpcGoalsId) || {};
                    const updatedPersonality = {
                        ...(cached.personality || {}),
                        goals: goals.slice(0)
                    };
                    npcDataCache.set(currentNpcGoalsId, { ...cached, personality: updatedPersonality, goals: goals.slice(0) });
                }

                if (typeof window.loadCurrentLocation === 'function') {
                    await window.loadCurrentLocation();
                }
                window.refreshParty?.();

                closeNpcGoalsModal();
            } catch (error) {
                console.warn('Failed to save NPC goals:', error);
                setNpcGoalsStatus(error?.message || 'Failed to save goals.', 'error');
                if (npcGoalsSaveBtn) {
                    npcGoalsSaveBtn.disabled = false;
                }
            }
        }

        async function resolveCurrentPlayerId() {
            if (window.currentPlayerData && typeof window.currentPlayerData.id === 'string' && window.currentPlayerData.id.trim()) {
                return window.currentPlayerData.id.trim();
            }
            try {
                const response = await fetch('/api/player', { cache: 'no-store' });
                const result = await response.json().catch(() => ({}));
                if (response.ok && result?.success && result.player?.id) {
                    window.currentPlayerData = result.player;
                    if (typeof result.player.id === 'string' && result.player.id.trim()) {
                        return result.player.id.trim();
                    }
                }
            } catch (error) {
                console.warn('Failed to resolve current player ID:', error);
            }
            throw new Error('Unable to determine current player ID.');
        }

        function updateNpcPartyMembershipCache(npcId, inPlayerParty, fallbackNpc = null) {
            if (!npcId) {
                return;
            }
            const isMember = Boolean(inPlayerParty);
            if (fallbackNpc && typeof fallbackNpc === 'object') {
                fallbackNpc.isInPlayerParty = isMember;
            }
            if (window.currentNpcData instanceof Map) {
                const snapshot = window.currentNpcData.get(npcId) || fallbackNpc || { id: npcId };
                const updated = cloneActorRecord(snapshot) || { ...snapshot };
                updated.isInPlayerParty = isMember;
                window.currentNpcData.set(npcId, updated);
            }
            if (window.currentPlayerData) {
                const existingMembers = Array.isArray(window.currentPlayerData.partyMembers)
                    ? new Set(window.currentPlayerData.partyMembers)
                    : new Set();
                if (isMember) {
                    existingMembers.add(npcId);
                } else {
                    existingMembers.delete(npcId);
                }
                window.currentPlayerData = {
                    ...window.currentPlayerData,
                    partyMembers: Array.from(existingMembers)
                };
            }
        }

        let draggedPartyNpc = null;

        function resetPartyDragState() {
            draggedPartyNpc = null;
            document.querySelectorAll('.party-drop-target.is-drop-hover').forEach(el => {
                el.classList.remove('is-drop-hover');
            });
        }

        function isNpcInParty(npcId) {
            if (!npcId) {
                return false;
            }
            const memberList = Array.isArray(window.currentPlayerData?.partyMembers)
                ? window.currentPlayerData.partyMembers
                : [];
            const targetId = String(npcId);
            return memberList.some(member => {
                if (!member) {
                    return false;
                }
                if (typeof member === 'string' || typeof member === 'number') {
                    return String(member) === targetId;
                }
                if (typeof member === 'object' && member.id) {
                    return String(member.id) === targetId;
                }
                return false;
            });
        }

        function resolveDraggedNpcRecord(dragState) {
            if (!dragState) {
                throw new Error('No character is being dragged.');
            }
            const rawId = dragState.npcId || dragState.npc?.id;
            if (!rawId) {
                throw new Error('Unable to resolve dragged character ID.');
            }
            const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            const stringId = String(rawId);
            const cached = npcDataCache
                ? (npcDataCache.get(rawId) || npcDataCache.get(stringId))
                : null;
            const record = cached || dragState.npc || null;
            if (!record) {
                throw new Error(`Unable to resolve character data for ${stringId}.`);
            }
            return { record, npcId: stringId };
        }

        function registerNpcPartyDragSource(card, npc, source) {
            if (!card || !npc || !npc.id) {
                return;
            }

            if (!npc.isNPC) {
                card.removeAttribute('draggable');
                return;
            }

            if (card.dataset.partyDragAttached === 'true') {
                return;
            }

            const npcId = String(npc.id);
            card.dataset.partyDragAttached = 'true';
            card.dataset.partyDragNpcId = npcId;
            card.dataset.partyDragSource = source || 'party';
            card.draggable = true;

            card.addEventListener('dragstart', (event) => {
                draggedPartyNpc = {
                    npcId,
                    source: source || 'party',
                    npc,
                    element: card
                };
                if (event.dataTransfer) {
                    event.dataTransfer.setData('text/plain', npcId);
                    event.dataTransfer.effectAllowed = 'move';
                }
                card.classList.add('is-dragging');
            });

            card.addEventListener('dragend', () => {
                card.classList.remove('is-dragging');
                resetPartyDragState();
            });
        }

        function registerPartyDropTarget(element, mode) {
            if (!element) {
                return;
            }
            const normalizedMode = mode === 'dismiss' ? 'dismiss' : 'recruit';
            if (element.dataset.partyDropTarget) {
                if (element.dataset.partyDropTarget !== normalizedMode) {
                    console.warn('Party drop target already registered with a different mode.');
                }
                return;
            }

            element.dataset.partyDropTarget = normalizedMode;
            element.classList.add('party-drop-target');

            const shouldHandleDrag = () => {
                if (!draggedPartyNpc) {
                    return false;
                }
                if (normalizedMode === 'recruit') {
                    return draggedPartyNpc.source === 'location';
                }
                if (normalizedMode === 'dismiss') {
                    return draggedPartyNpc.source === 'party';
                }
                return false;
            };

            element.addEventListener('dragover', (event) => {
                if (!shouldHandleDrag()) {
                    return;
                }
                event.preventDefault();
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = 'move';
                }
                element.classList.add('is-drop-hover');
            });

            element.addEventListener('dragenter', (event) => {
                if (!shouldHandleDrag()) {
                    return;
                }
                event.preventDefault();
                element.classList.add('is-drop-hover');
            });

            element.addEventListener('dragleave', () => {
                element.classList.remove('is-drop-hover');
            });

            element.addEventListener('drop', async (event) => {
                event.preventDefault();
                element.classList.remove('is-drop-hover');

                if (!shouldHandleDrag()) {
                    resetPartyDragState();
                    return;
                }

                try {
                    const { record, npcId } = resolveDraggedNpcRecord(draggedPartyNpc);
                    if (normalizedMode === 'recruit') {
                        if (isNpcInParty(npcId)) {
                            window.alert('That character is already in the party.');
                            return;
                        }
                        await forceRecruitNpc(record, { card: draggedPartyNpc.element || null });
                    } else if (normalizedMode === 'dismiss') {
                        if (!isNpcInParty(npcId)) {
                            window.alert('That character is not in the party.');
                            return;
                        }
                        await dismissNpcFromParty(record, { card: draggedPartyNpc.element || null });
                    }
                } catch (error) {
                    console.warn('Party drag/drop failed:', error);
                    window.alert(error?.message || 'Unable to update party membership.');
                } finally {
                    resetPartyDragState();
                }
            });
        }

        async function forceRecruitNpc(npc, { card = null } = {}) {
            const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
            const latestNpc = npcDataCache?.get(npc?.id) || npc;
            return recruitNpcToParty(latestNpc, { card });
        }

        async function recruitNpcToParty(npc, { card = null } = {}) {
            if (!npc || !npc.id) {
                throw new Error('Missing character information.');
            }
            const ownerId = await resolveCurrentPlayerId();
            const label = npc.name || 'character';
            showLocationOverlay(`Recruiting ${label}...`);
            try {
                const response = await fetch('/api/player/party', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ownerId, memberId: npc.id })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                updateNpcPartyMembershipCache(npc.id, true, npc);

                try {
                    if (typeof window.refreshParty === 'function') {
                        await window.refreshParty();
                    }
                } catch (refreshError) {
                    console.warn('Failed to refresh party after recruiting NPC:', refreshError);
                }

                try {
                    if (typeof window.loadCurrentLocation === 'function') {
                        await window.loadCurrentLocation();
                    }
                } catch (locationError) {
                    console.warn('Failed to refresh location after recruiting NPC:', locationError);
                }

                if (card && card.parentElement) {
                    card.remove();
                }

                return data;
            } finally {
                hideLocationOverlay();
            }
        }

        async function dismissNpcFromParty(npc, { card = null } = {}) {
            if (!npc || !npc.id) {
                throw new Error('Missing character information.');
            }
            const ownerId = await resolveCurrentPlayerId();
            const label = npc.name || 'character';
            showLocationOverlay(`Dismissing ${label}...`);
            try {
                const response = await fetch('/api/player/party', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ownerId, memberId: npc.id })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                updateNpcPartyMembershipCache(npc.id, false, npc);

                try {
                    if (typeof window.refreshParty === 'function') {
                        await window.refreshParty();
                    }
                } catch (refreshError) {
                    console.warn('Failed to refresh party after dismissing NPC:', refreshError);
                }

                try {
                    if (typeof window.loadCurrentLocation === 'function') {
                        await window.loadCurrentLocation();
                    }
                } catch (locationError) {
                    console.warn('Failed to refresh location after dismissing NPC:', locationError);
                }

                if (card && card.parentElement) {
                    card.remove();
                }

                return data;
            } finally {
                hideLocationOverlay();
            }
        }

        function setAddNpcStatus(message = '', type = null) {
            if (!addNpcStatus) {
                return;
            }
            addNpcStatus.textContent = message || '';
            addNpcStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                addNpcStatus.classList.add('is-error');
            } else if (type === 'success') {
                addNpcStatus.classList.add('is-success');
            }
        }

        function setLoadGameStatus(message, variant = null) {
            if (!loadGameStatus) {
                return;
            }
            loadGameStatus.textContent = message || '';
            if (variant) {
                loadGameStatus.dataset.variant = variant;
            } else {
                delete loadGameStatus.dataset.variant;
            }
        }

        function getLoadGameSourceLabel({ source = currentLoadGameSource, plural = false } = {}) {
            const normalizedSource = source === 'autosaves' ? 'autosaves' : 'saves';
            if (plural) {
                return normalizedSource === 'autosaves' ? 'autosaves' : 'saved games';
            }
            return normalizedSource === 'autosaves' ? 'autosave' : 'saved game';
        }

        function populateLoadGameOptions(saves = [], { emptyLabel = null } = {}) {
            if (!loadGameSelect) {
                return;
            }

            loadGameSelect.innerHTML = '';

            if (!Array.isArray(saves) || saves.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = emptyLabel || `No ${getLoadGameSourceLabel({ plural: true })} available`;
                option.disabled = true;
                loadGameSelect.appendChild(option);
                loadGameSelect.disabled = true;
                if (loadGameConfirmBtn) {
                    loadGameConfirmBtn.disabled = true;
                }
                return;
            }

            loadGameSelect.disabled = false;
            saves.forEach((save, index) => {
                const option = document.createElement('option');
                option.value = save.saveName;
                option.dataset.source = save.source === 'autosaves' ? 'autosaves' : currentLoadGameSource;
                const timestamp = new Date(save.timestamp);
                const playerName = save.playerName || 'Unknown';
                const levelLabel = save.playerLevel !== undefined && save.playerLevel !== null
                    ? save.playerLevel
                    : '?';
                const timestampLabel = Number.isFinite(timestamp.getTime())
                    ? timestamp.toLocaleString()
                    : 'Unknown time';
                const prefix = currentLoadGameSource === 'autosaves' ? 'Autosave' : 'Save';
                const locationName = typeof save.currentLocationName === 'string'
                    ? save.currentLocationName.trim()
                    : '';
                const locationSuffix = locationName ? ` @ ${locationName}` : '';
                option.textContent = `${prefix}: ${playerName} (Level ${levelLabel})${locationSuffix} ‚Ä¢ ${timestampLabel}`;
                if (index === 0) {
                    option.selected = true;
                }
                loadGameSelect.appendChild(option);
            });

            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = false;
            }
        }

        async function refreshLoadGameList(source = 'saves') {
            const normalizedSource = source === 'autosaves' ? 'autosaves' : 'saves';
            currentLoadGameSource = normalizedSource;

            loadGameSourceRadios.forEach(radio => {
                radio.checked = radio.value === normalizedSource;
            });

            const requestId = ++loadGameFetchToken;
            const pluralLabel = getLoadGameSourceLabel({ source: normalizedSource, plural: true });

            if (loadGameSelect) {
                loadGameSelect.innerHTML = '';
                const loadingOption = document.createElement('option');
                loadingOption.value = '';
                loadingOption.textContent = `Loading ${pluralLabel}‚Ä¶`;
                loadingOption.disabled = true;
                loadingOption.selected = true;
                loadGameSelect.appendChild(loadingOption);
                loadGameSelect.disabled = true;
            }

            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = true;
            }

            setLoadGameStatus(`Loading ${pluralLabel}‚Ä¶`, 'info');

            try {
                const response = await fetch(`/api/saves?type=${normalizedSource}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json().catch(() => ({}));
                const rawSaves = Array.isArray(result?.saves) ? result.saves : [];

                if (requestId !== loadGameFetchToken) {
                    return;
                }

                const safeParseTimestamp = (value) => {
                    const parsed = new Date(value || '').getTime();
                    return Number.isFinite(parsed) ? parsed : 0;
                };

                loadGameSaves = [...rawSaves].sort((a, b) => {
                    return safeParseTimestamp(b.timestamp) - safeParseTimestamp(a.timestamp);
                });

                populateLoadGameOptions(loadGameSaves, {
                    emptyLabel: `No ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })} available`
                });

                if (loadGameSaves.length) {
                    setLoadGameStatus('', null);
                    if (loadGameSelect && !loadGameSelect.disabled) {
                        loadGameSelect.focus();
                    }
                } else {
                    setLoadGameStatus(`No ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })} available.`, 'info');
                }
            } catch (error) {
                if (requestId !== loadGameFetchToken) {
                    return;
                }

                loadGameSaves = [];
                populateLoadGameOptions([], {
                    emptyLabel: `Unable to load ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })}`
                });
                setLoadGameStatus(`Failed to load ${getLoadGameSourceLabel({ source: normalizedSource, plural: true })}: ${error.message}`, 'error');
            }
        }

        function openLoadGameModal({ initialSource = 'saves' } = {}) {
            if (!loadGameModal || !npcModalBackdrop) {
                return;
            }

            loadGameSaves = [];
            currentLoadGameSource = initialSource === 'autosaves' ? 'autosaves' : 'saves';
            loadGameSourceRadios.forEach(radio => {
                radio.checked = radio.value === currentLoadGameSource;
            });
            if (loadGameSelect) {
                loadGameSelect.innerHTML = '';
                loadGameSelect.disabled = true;
            }
            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = true;
            }
            setLoadGameStatus('', null);

            npcModalBackdrop.removeAttribute('hidden');
            loadGameModal.removeAttribute('hidden');
            loadGameModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(loadGameModal);

            setTimeout(() => {
                if (loadGameSelect && !loadGameSelect.disabled) {
                    loadGameSelect.focus();
                } else if (loadGameCancelBtn) {
                    loadGameCancelBtn.focus();
                }
            }, 50);
        }

        function closeLoadGameModal({ focusTrigger = false } = {}) {
            if (!loadGameModal) {
                return;
            }

            loadGameFetchToken += 1;
            currentLoadGameSource = 'saves';
            loadGameModal.setAttribute('aria-hidden', 'true');
            loadGameModal.setAttribute('hidden', '');
            setLoadGameStatus('');
            loadGameSaves = [];
            if (loadGameSelect) {
                loadGameSelect.innerHTML = '';
                loadGameSelect.disabled = false;
            }
            loadGameSourceRadios.forEach(radio => {
                radio.checked = radio.value === 'saves';
            });
            if (loadGameConfirmBtn) {
                loadGameConfirmBtn.disabled = false;
                loadGameConfirmBtn.textContent = 'Load Game';
            }
            if (loadGameCancelBtn) {
                loadGameCancelBtn.disabled = false;
            }

            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalBackdrop && inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }

            if (focusTrigger && loadGameTriggerButton) {
                loadGameTriggerButton.focus();
            }
            loadGameTriggerButton = null;
        }

        function openAddNpcModal() {
            if (!addNpcModal || !npcModalBackdrop) {
                return;
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                alert('No active location available to add NPCs.');
                return;
            }

            if (addNpcForm) {
                addNpcForm.reset();
            }
            const baseLevel = Number.isFinite(Number(lastRenderedLocation.baseLevel))
                ? Number(lastRenderedLocation.baseLevel)
                : (Number.isFinite(Number(lastRenderedLocation.level)) ? Number(lastRenderedLocation.level) : '');
            if (addNpcLevelInput) {
                addNpcLevelInput.value = Number.isFinite(baseLevel) ? baseLevel : '';
            }
            if (addNpcIsHostileInput) {
                addNpcIsHostileInput.checked = false;
            }
            if (addNpcNotesInput) {
                addNpcNotesInput.value = '';
            }
            setAddNpcStatus('', null);
            if (addNpcSaveBtn) {
                addNpcSaveBtn.disabled = false;
            }

            npcModalBackdrop.removeAttribute('hidden');
            addNpcModal.removeAttribute('hidden');
            addNpcModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(addNpcModal);

            setTimeout(() => {
                addNpcNameInput?.focus();
            }, 50);
        }

        async function openAddThingModal({ itemOrScenery = 'item' } = {}) {
            if (!thingEditModal || !npcModalBackdrop) {
                return;
            }

            const activeLocation = (lastRenderedLocation && lastRenderedLocation.id)
                ? lastRenderedLocation
                : null;
            if (!activeLocation) {
                alert('No active location available to add items.');
                return;
            }

            const baseLevel = Number.isFinite(Number(activeLocation.baseLevel))
                ? Number(activeLocation.baseLevel)
                : (Number.isFinite(Number(activeLocation.level)) ? Number(activeLocation.level) : null);

            try {
                await showThingEditModal({}, 'location', {
                    mode: 'create',
                    itemOrScenery,
                    location: activeLocation
                });
            } catch (error) {
                console.warn('Failed to open item creation modal:', error);
                return;
            }

            if (thingEditLevelInput) {
                if (Number.isFinite(baseLevel)) {
                    thingEditLevelInput.value = baseLevel;
                } else {
                    thingEditLevelInput.value = '';
                }
            }

            updateThingEditStatus('');
        }

        function closeAddNpcModal({ focusTrigger = false } = {}) {
            if (!addNpcModal) {
                return;
            }

            addNpcModal.setAttribute('aria-hidden', 'true');
            addNpcModal.setAttribute('hidden', '');

            if (addNpcForm) {
                addNpcForm.reset();
            }
            if (addNpcIsHostileInput) {
                addNpcIsHostileInput.checked = false;
            }
            if (addNpcImageInput) {
                addNpcImageInput.value = '';
            }
            if (addNpcNotesInput) {
                addNpcNotesInput.value = '';
            }
            if (addNpcSaveBtn) {
                addNpcSaveBtn.disabled = false;
            }
            setAddNpcStatus('', null);

            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalBackdrop && inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }

            if (focusTrigger && addNpcButton) {
                addNpcButton.focus();
            }
        }

        async function readAddNpcImageData(file) {
            if (!file) {
                return null;
            }
            if (!file.type || !file.type.startsWith('image/')) {
                throw new Error('NPC image must be an image file.');
            }
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof reader.result === 'string') {
                        resolve(reader.result);
                        return;
                    }
                    reject(new Error('NPC image could not be read.'));
                };
                reader.onerror = () => reject(new Error('NPC image could not be read.'));
                reader.readAsDataURL(file);
            });
            const downscaledDataUrl = await downscaleImageDataUrl(dataUrl, file.type, 'NPC image');
            const portraitDataUrl = file.type === 'image/png'
                ? dataUrl
                : await normalizeImageDataUrlToPng(dataUrl, 'NPC portrait');
            return {
                downscaledDataUrl,
                portraitDataUrl
            };
        }

        async function readNewExitImageData(file) {
            if (!file) {
                return null;
            }
            if (!file.type || !file.type.startsWith('image/')) {
                throw new Error('Reference image must be an image file.');
            }
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof reader.result === 'string') {
                        resolve(reader.result);
                        return;
                    }
                    reject(new Error('Reference image could not be read.'));
                };
                reader.onerror = () => reject(new Error('Reference image could not be read.'));
                reader.readAsDataURL(file);
            });
            const downscaledDataUrl = await downscaleImageDataUrl(dataUrl, file.type, 'Reference image');
            const originalDataUrl = file.type === 'image/png'
                ? dataUrl
                : await normalizeImageDataUrlToPng(dataUrl, 'Reference image');
            return {
                downscaledDataUrl,
                originalDataUrl
            };
        }

        async function downscaleImageDataUrl(dataUrl, outputType, label = 'Image') {
            const maxPixels = 2000000;
            const labelText = label || 'Image';
            return new Promise((resolve, reject) => {
                if (!dataUrl) {
                    reject(new Error(`${labelText} data is missing.`));
                    return;
                }
                const image = new Image();
                image.onload = () => {
                    const width = image.naturalWidth || image.width;
                    const height = image.naturalHeight || image.height;
                    if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
                        reject(new Error(`${labelText} dimensions are invalid.`));
                        return;
                    }

                    const pixelCount = width * height;
                    if (pixelCount <= maxPixels) {
                        resolve(dataUrl);
                        return;
                    }

                    const scale = Math.sqrt(maxPixels / pixelCount);
                    const targetWidth = Math.max(1, Math.round(width * scale));
                    const targetHeight = Math.max(1, Math.round(height * scale));
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        reject(new Error(`${labelText} resizing failed to initialize.`));
                        return;
                    }
                    ctx.drawImage(image, 0, 0, targetWidth, targetHeight);

                    const normalizedType = outputType && outputType.startsWith('image/')
                        ? outputType
                        : 'image/jpeg';
                    const supportsQuality = normalizedType === 'image/jpeg' || normalizedType === 'image/webp';
                    const resizedDataUrl = supportsQuality
                        ? canvas.toDataURL(normalizedType, 0.9)
                        : canvas.toDataURL(normalizedType);
                    resolve(resizedDataUrl);
                };
                image.onerror = () => reject(new Error(`${labelText} could not be loaded.`));
                image.src = dataUrl;
            });
        }

        async function normalizeImageDataUrlToPng(dataUrl, label = 'Image') {
            return new Promise((resolve, reject) => {
                if (!dataUrl) {
                    const labelText = label || 'Image';
                    reject(new Error(`${labelText} data is missing.`));
                    return;
                }
                const labelText = label || 'Image';
                const image = new Image();
                image.onload = () => {
                    const width = image.naturalWidth || image.width;
                    const height = image.naturalHeight || image.height;
                    if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
                        reject(new Error(`${labelText} dimensions are invalid.`));
                        return;
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        reject(new Error(`${labelText} conversion failed to initialize.`));
                        return;
                    }
                    ctx.drawImage(image, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/png'));
                };
                image.onerror = () => reject(new Error(`${labelText} image could not be loaded.`));
                image.src = dataUrl;
            });
        }

        async function submitAddNpc(event) {
            if (event) {
                event.preventDefault();
            }

            if (addNpcSubmitting) {
                alert('NPC creation is already in progress.');
                return;
            }

            if (!addNpcForm || !addNpcSaveBtn) {
                return;
            }

            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                alert('No active location is available for adding NPCs.');
                return;
            }

            const name = addNpcNameInput?.value?.trim();

            const payload = {};
            if (name) {
                payload.name = name;
            }
            const shortDescription = addNpcShortDescriptionInput?.value?.trim();
            if (shortDescription) {
                payload.shortDescription = shortDescription;
            }
            const description = addNpcDescriptionInput?.value?.trim();
            if (description) {
                payload.description = description;
            }
            const notes = addNpcNotesInput?.value?.trim();
            if (notes) {
                payload.notes = notes;
            }
            const role = addNpcRoleInput?.value?.trim();
            if (role) {
                payload.role = role;
            }
            const className = addNpcClassInput?.value?.trim();
            if (className) {
                payload.class = className;
            }
            const race = addNpcRaceInput?.value?.trim();
            if (race) {
                payload.race = race;
            }

            const levelValueRaw = addNpcLevelInput?.value;
            if (levelValueRaw !== undefined && levelValueRaw !== null && String(levelValueRaw).trim() !== '') {
                const levelNumber = Number(levelValueRaw);
                if (Number.isFinite(levelNumber)) {
                    payload.level = Math.max(1, Math.round(levelNumber));
                }
            }

            const currencyValueRaw = addNpcCurrencyInput?.value;
            if (currencyValueRaw !== undefined && currencyValueRaw !== null && String(currencyValueRaw).trim() !== '') {
                const currencyNumber = Number(currencyValueRaw);
                if (Number.isFinite(currencyNumber) && currencyNumber >= 0) {
                    payload.currency = Math.round(currencyNumber);
                }
            }

            if (addNpcIsHostileInput) {
                payload.isHostile = Boolean(addNpcIsHostileInput.checked);
            }

            const imageFile = addNpcImageInput?.files?.[0] || null;
            addNpcSubmitting = true;
            closeAddNpcModal({ focusTrigger: false });
            try {
                if (imageFile) {
                    const imagePayload = await readAddNpcImageData(imageFile);
                    if (!imagePayload?.downscaledDataUrl || !imagePayload?.portraitDataUrl) {
                        throw new Error('NPC image processing failed.');
                    }
                    payload.imageDataUrl = imagePayload.downscaledDataUrl;
                    payload.imageDataUrlOriginal = imagePayload.portraitDataUrl;
                }

                const response = await fetch(`/api/locations/${encodeURIComponent(lastRenderedLocation.id)}/npcs`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                if (data.location) {
                    lastRenderedLocation = JSON.parse(JSON.stringify(data.location));
                    await window.updateLocationDisplay(data.location);
                }
            } catch (error) {
                console.warn('Failed to create NPC:', error);
                alert(`Failed to create NPC: ${error?.message || 'Unknown error'}`);
            } finally {
                addNpcSubmitting = false;
            }
        }

        function setNewExitStatus(message = '', type = null) {
            if (!newExitStatus) {
                return;
            }
            newExitStatus.textContent = message || '';
            newExitStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                newExitStatus.classList.add('is-error');
            } else if (type === 'success') {
                newExitStatus.classList.add('is-success');
            }
        }

        function getNewExitRegionOption(regionId) {
            if (!regionId) {
                return null;
            }
            return newExitRegionsById.get(regionId) || null;
        }

        function findRegionAndLocationOptionForLocationId(locationId) {
            if (!locationId || !(newExitRegionsById instanceof Map)) {
                return null;
            }
            for (const region of newExitRegionsById.values()) {
                if (!region || !Array.isArray(region.locations)) {
                    continue;
                }
                const match = region.locations.find(loc => loc && loc.id === locationId);
                if (match) {
                    return { region, location: match };
                }
            }
            return null;
        }

        function findExitMatchForPayload(locationData = {}, payload = {}, createdInfo = {}) {
            const exits = Object.values(locationData.exits || {});
            if (!exits.length) {
                return null;
            }

            const normalizedType = (payload.type || '').toLowerCase();

            if (normalizedType === 'region') {
                const regionId = createdInfo?.regionId || payload.regionId || null;
                const stubId = createdInfo?.stubId || null;
                if (stubId) {
                    const stubMatch = exits.find(exit => exit && exit.destination === stubId);
                    if (stubMatch) {
                        return stubMatch;
                    }
                }
                if (regionId) {
                    const regionMatch = exits.find(exit => exit && exit.destinationRegion === regionId);
                    if (regionMatch) {
                        return regionMatch;
                    }
                }
            }

            const targetLocationId = payload.locationId
                || createdInfo?.destinationId
                || createdInfo?.stubId
                || null;

            if (targetLocationId) {
                const locationMatch = exits.find(exit => exit && exit.destination === targetLocationId);
                if (locationMatch) {
                    return locationMatch;
                }
            }

            return null;
        }

        async function ensureNewExitOptionsLoaded(force = false) {
            if (!force && newExitOptionsCache && Array.isArray(newExitOptionsCache.regions)) {
                return newExitOptionsCache;
            }

            const originLocationId = newExitOriginLocationId
                || editingExitContext?.locationId
                || lastRenderedLocation?.id
                || null;
            const query = originLocationId ? `?originLocationId=${encodeURIComponent(originLocationId)}` : '';
            const response = await fetch(`/api/exits/options${query}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            if (!data?.success || !Array.isArray(data.regions)) {
                throw new Error(data?.error || 'Invalid response when loading region data');
            }

            const filteredRegions = Array.isArray(data.regions)
                ? data.regions
                    .filter(region => {
                        const name = typeof region?.name === 'string' ? region.name.trim() : '';
                        return Boolean(name);
                    })
                    .map(region => ({
                        ...region,
                        name: region.name.trim(),
                        locations: Array.isArray(region.locations)
                            ? region.locations
                                .filter(loc => {
                                    const name = typeof loc?.name === 'string' ? loc.name.trim() : '';
                                    return Boolean(name);
                                })
                                .map(loc => ({
                                    ...loc,
                                    name: loc.name.trim()
                                }))
                            : []
                    }))
                : [];

            newExitOptionsCache = {
                ...data,
                regions: filteredRegions
            };
            newExitRegionsById = new Map();
            filteredRegions.forEach(region => {
                const normalizedLocations = Array.isArray(region.locations)
                    ? region.locations.map(loc => ({
                        id: loc.id,
                        name: loc.name,
                        isStub: Boolean(loc.isStub),
                        regionId: loc.regionId || region.id,
                        isRegionEntryStub: Boolean(loc.isRegionEntryStub)
                    }))
                    : [];
                newExitRegionsById.set(region.id, {
                    id: region.id,
                    name: region.name,
                    isStub: Boolean(region.isStub),
                    locations: normalizedLocations
                });
            });

            return newExitOptionsCache;
        }

        function populateNewExitRegionSelect(defaultRegionId = '') {
            if (!newExitRegionSelect) {
                return;
            }

            const previousValue = defaultRegionId !== undefined ? defaultRegionId : newExitRegionSelect.value;
            newExitRegionSelect.innerHTML = '';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Create new region';
            newExitRegionSelect.appendChild(defaultOption);

            if (newExitOptionsCache?.regions) {
                newExitOptionsCache.regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region.id;
                    option.textContent = region.isStub ? `${region.name} (pending)` : region.name;
                    option.dataset.isStub = region.isStub ? 'true' : 'false';
                    newExitRegionSelect.appendChild(option);
                });
            }

            if (previousValue && Array.from(newExitRegionSelect.options).some(opt => opt.value === previousValue)) {
                newExitRegionSelect.value = previousValue;
            } else {
                newExitRegionSelect.value = '';
            }

            handleNewExitRegionChange();
        }

        function populateNewExitLocationSelect(regionId) {
            if (!newExitLocationSelect || !newExitLocationGroup) {
                return;
            }

            if (!regionId) {
                newExitLocationSelect.innerHTML = '';
                newExitLocationGroup.setAttribute('hidden', '');
                return;
            }

            const regionOption = getNewExitRegionOption(regionId);

            newExitLocationGroup.removeAttribute('hidden');
            newExitLocationSelect.innerHTML = '';

            const createOption = document.createElement('option');
            createOption.value = '';
            createOption.textContent = 'Create new location';
            createOption.dataset.isCreateOption = 'true';
            newExitLocationSelect.appendChild(createOption);

            if (regionOption && Array.isArray(regionOption.locations)) {
                regionOption.locations.forEach(loc => {
                    const option = document.createElement('option');
                    option.value = loc.id;
                    option.textContent = loc.name;
                    option.dataset.isStub = loc.isStub ? 'true' : 'false';
                    option.dataset.regionId = loc.regionId || regionOption.id;
                    newExitLocationSelect.appendChild(option);
                });
            }

            newExitLocationSelect.selectedIndex = 0;

            handleNewExitLocationChange();
        }

        function shouldShowNewExitTextFields() {
            const selectedLocationId = newExitLocationSelect?.value || '';
            return !selectedLocationId;
        }

        function shouldShowExitRelativeLevelField() {
            const selectedRegionId = newExitRegionSelect?.value?.trim() || '';
            const creatingNewRegion = !selectedRegionId;
            if (!editingExitContext) {
                return creatingNewRegion;
            }
            const exit = editingExitContext?.exit || null;
            const regionOption = selectedRegionId ? getNewExitRegionOption(selectedRegionId) : null;
            const regionIsStub = Boolean(regionOption?.isStub);
            const exitIsStub = Boolean(exit?.destinationIsRegionEntryStub || (exit?.destinationRegion && !exit?.destinationRegionExpanded));
            return creatingNewRegion || regionIsStub || exitIsStub;
        }

        function syncNewExitFieldVisibility() {
            const selectedRegionId = newExitRegionSelect?.value?.trim() || '';
            const selectedLocationId = newExitLocationSelect?.value?.trim() || '';
            const showFields = !selectedLocationId;
            const creatingNewRegion = !selectedRegionId;
            const currentRegionId = newExitOriginRegionId
                || lastRenderedLocation?.regionId
                || lastRenderedLocation?.stubMetadata?.regionId
                || null;
            if (newExitNameGroup) {
                if (showFields) {
                    newExitNameGroup.removeAttribute('hidden');
                } else {
                    newExitNameGroup.setAttribute('hidden', '');
                }
            }
            if (newExitDescriptionGroup) {
                if (showFields) {
                    newExitDescriptionGroup.removeAttribute('hidden');
                } else {
                    newExitDescriptionGroup.setAttribute('hidden', '');
                }
            }
            if (newExitImageGroup) {
                if (showFields) {
                    newExitImageGroup.removeAttribute('hidden');
                } else {
                    newExitImageGroup.setAttribute('hidden', '');
                    if (newExitImageInput) {
                        newExitImageInput.value = '';
                    }
                }
            }
            if (newExitVehicleGroup) {
                if (showFields) {
                    newExitVehicleGroup.removeAttribute('hidden');
                } else {
                    newExitVehicleGroup.setAttribute('hidden', '');
                    if (newExitVehicleInput) {
                        newExitVehicleInput.value = '';
                    }
                }
            }
            if (newExitRelativeLevelGroup) {
                if (shouldShowExitRelativeLevelField()) {
                    newExitRelativeLevelGroup.removeAttribute('hidden');
                } else {
                    newExitRelativeLevelGroup.setAttribute('hidden', '');
                    if (newExitRelativeLevelInput) {
                        newExitRelativeLevelInput.value = '';
                    }
                }
            }
            if (newExitChildRegionGroup) {
                if (creatingNewRegion && currentRegionId) {
                    newExitChildRegionGroup.removeAttribute('hidden');
                } else {
                    newExitChildRegionGroup.setAttribute('hidden', '');
                    if (newExitChildRegionCheckbox) {
                        newExitChildRegionCheckbox.checked = false;
                    }
                }
            }
        }

        function handleNewExitRegionChange() {
            const regionId = newExitRegionSelect?.value || '';
            populateNewExitLocationSelect(regionId);
            syncNewExitFieldVisibility();
        }

        function handleNewExitLocationChange() {
            syncNewExitFieldVisibility();
            const selectedLocationId = newExitLocationSelect?.value || '';
            if (selectedLocationId) {
                if (newExitNameInput) {
                    newExitNameInput.value = '';
                }
                if (newExitDescriptionInput) {
                    newExitDescriptionInput.value = '';
                }
                if (newExitVehicleInput) {
                    newExitVehicleInput.value = '';
                }
                if (newExitImageInput) {
                    newExitImageInput.value = '';
                }
            }
        }


        async function openNewExitModal(context = null) {
            if (!newExitModal || !npcModalBackdrop) {
                return;
            }
            const isMapMode = Boolean(context && context.mode === 'map');
            newExitMapMode = isMapMode;
            newExitOriginLocationId = null;
            newExitOriginRegionId = null;
            newExitPreferredRegionId = null;
            if (isMapMode) {
                const originId = typeof context?.originLocationId === 'string' ? context.originLocationId.trim() : '';
                const originRegionId = typeof context?.originRegionId === 'string' ? context.originRegionId.trim() : '';
                if (originId) {
                    newExitOriginLocationId = originId;
                }
                if (originRegionId) {
                    newExitOriginRegionId = originRegionId;
                }
                const preferredRegionId = typeof context?.preferredRegionId === 'string' ? context.preferredRegionId.trim() : '';
                newExitPreferredRegionId = preferredRegionId || newExitOriginRegionId || null;
                const mapPosition = context?.mapPosition;
                if (mapPosition && Number.isFinite(mapPosition.x) && Number.isFinite(mapPosition.y)) {
                    newExitMapPosition = { x: mapPosition.x, y: mapPosition.y };
                }
            }
            if (!lastRenderedLocation || !lastRenderedLocation.id) {
                if (!newExitOriginLocationId) {
                    alert('No active location available to add an exit.');
                    return;
                }
            }

            const isEditing = Boolean(context && context.mode === 'edit' && context.exit && context.exitId);
            editingExitContext = isEditing
                ? {
                    locationId: context.locationId || lastRenderedLocation.id,
                    exitId: context.exitId,
                    exit: context.exit,
                    direction: context.direction || null
                }
                : null;

            if (newExitForm) {
                newExitForm.reset();
            }
            if (newExitRegionSelect) {
                newExitRegionSelect.value = '';
            }
            if (newExitLocationSelect) {
                newExitLocationSelect.innerHTML = '';
            }
            if (newExitLocationGroup) {
                newExitLocationGroup.setAttribute('hidden', '');
            }
            if (newExitNameGroup) {
                newExitNameGroup.removeAttribute('hidden');
            }
            if (newExitDescriptionGroup) {
                newExitDescriptionGroup.removeAttribute('hidden');
            }
            if (newExitVehicleGroup) {
                newExitVehicleGroup.removeAttribute('hidden');
            }
            if (newExitImageInput) {
                newExitImageInput.value = '';
            }
            if (newExitVehicleInput) {
                newExitVehicleInput.value = '';
            }
            if (newExitRelativeLevelGroup) {
                newExitRelativeLevelGroup.setAttribute('hidden', '');
            }
            if (newExitRelativeLevelInput) {
                newExitRelativeLevelInput.value = '';
            }
            if (newExitChildRegionGroup) {
                newExitChildRegionGroup.setAttribute('hidden', '');
            }
            if (newExitChildRegionCheckbox) {
                newExitChildRegionCheckbox.checked = false;
            }

            if (newExitModalTitle) {
                newExitModalTitle.textContent = isEditing ? 'Edit Exit' : 'Add New Exit';
            }
            if (newExitSaveBtn) {
                newExitSaveBtn.textContent = isEditing ? 'Update Exit' : 'Create Exit';
                newExitSaveBtn.disabled = false;
            }
            setNewExitStatus('', null);
            syncNewExitFieldVisibility();

            let loadError = null;
            try {
                await ensureNewExitOptionsLoaded();
                populateNewExitRegionSelect('');
                if (isEditing && editingExitContext?.exit) {
                    const exit = editingExitContext.exit;
                    const destinationId = exit.destination || null;
                    const destinationRegionId = exit.destinationRegion || null;

                    let selectedRegionId = null;
                    let selectedLocationId = null;

                    if (destinationId) {
                        const regionMatch = findRegionAndLocationOptionForLocationId(destinationId);
                        if (regionMatch) {
                            selectedRegionId = regionMatch.region.id;
                            selectedLocationId = regionMatch.location.id;
                        }
                    }

                    if (!selectedRegionId && destinationRegionId) {
                        selectedRegionId = destinationRegionId;
                        selectedLocationId = destinationId || '';
                    }

                    if (newExitRegionSelect) {
                        if (selectedRegionId && Array.from(newExitRegionSelect.options).some(opt => opt.value === selectedRegionId)) {
                            newExitRegionSelect.value = selectedRegionId;
                        } else {
                            newExitRegionSelect.value = '';
                        }
                    }

                    handleNewExitRegionChange();

                    if (selectedLocationId && newExitLocationSelect) {
                        if (Array.from(newExitLocationSelect.options).some(opt => opt.value === selectedLocationId)) {
                            newExitLocationSelect.value = selectedLocationId;
                        } else {
                            newExitLocationSelect.value = '';
                        }
                        handleNewExitLocationChange();
                    } else {
                        handleNewExitLocationChange();
                    }

                    const showTextFields = shouldShowNewExitTextFields();
                    if (showTextFields && newExitNameInput) {
                        newExitNameInput.value = exit.destinationRegionName
                            || exit.destinationName
                            || exit.description
                            || '';
                    }
                    if (newExitDescriptionInput) {
                        newExitDescriptionInput.value = exit.description || '';
                    }
                    if (newExitVehicleInput) {
                        newExitVehicleInput.value = exit.vehicleType || '';
                    }
                    if (newExitRelativeLevelInput) {
                        const relativeLevelValue = Number(exit.relativeLevel);
                        newExitRelativeLevelInput.value = Number.isFinite(relativeLevelValue)
                            ? Math.round(relativeLevelValue)
                            : '';
                    }
                } else if (newExitPreferredRegionId && newExitRegionSelect) {
                    if (Array.from(newExitRegionSelect.options).some(opt => opt.value === newExitPreferredRegionId)) {
                        newExitRegionSelect.value = newExitPreferredRegionId;
                    }
                    handleNewExitRegionChange();
                } else {
                    handleNewExitRegionChange();
                }
            } catch (error) {
                loadError = error;
                setNewExitStatus(`Failed to load region information: ${error?.message || 'Unknown error'}`, 'error');
                if (newExitSaveBtn) {
                    newExitSaveBtn.disabled = true;
                }
            }

            npcModalBackdrop.removeAttribute('hidden');
            newExitModal.removeAttribute('hidden');
            newExitModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(newExitModal);

            setTimeout(() => {
                if (loadError) {
                    newExitCloseBtn?.focus();
                } else if (newExitRegionSelect) {
                    newExitRegionSelect.focus();
                } else {
                    newExitNameInput?.focus();
                }
            }, 50);
        }

        window.openNewExitModalFromMap = (context = {}) => {
            const originLocationId = typeof context?.originLocationId === 'string' ? context.originLocationId.trim() : '';
            if (!originLocationId) {
                throw new Error('Map exit creation requires an origin location id.');
            }
            const originRegionId = typeof context?.originRegionId === 'string' ? context.originRegionId.trim() : '';
            const preferredRegionId = typeof context?.preferredRegionId === 'string' ? context.preferredRegionId.trim() : '';
            const mapPosition = context?.mapPosition;
            openNewExitModal({
                mode: 'map',
                originLocationId,
                originRegionId,
                preferredRegionId: preferredRegionId || originRegionId || null,
                mapPosition
            });
        };

        async function submitNewExit(event) {
            if (event) {
                event.preventDefault();
            }

            if (newExitSubmitting) {
                alert('An exit request is already in progress.');
                return;
            }

            if (!newExitForm || !newExitSaveBtn) {
                return;
            }

            const isEditing = Boolean(editingExitContext);
            const activeLocationId = isEditing
                ? (editingExitContext?.locationId || newExitOriginLocationId || lastRenderedLocation?.id || null)
                : (newExitOriginLocationId || lastRenderedLocation?.id || null);

            if (!activeLocationId) {
                alert('No active location is available for managing exits.');
                return;
            }

            const selectedRegionId = newExitRegionSelect?.value?.trim() || '';
            const selectedLocationId = newExitLocationSelect?.value?.trim() || '';
            const nameFieldsVisible = shouldShowNewExitTextFields();
            const name = newExitNameInput?.value?.trim() || '';
            const description = newExitDescriptionInput?.value?.trim() || '';
            const vehicleTypeInput = newExitVehicleInput?.value?.trim() || '';
            const relativeLevelRaw = newExitRelativeLevelInput?.value;
            let relativeLevelValue = null;

            if (newExitRelativeLevelGroup && !newExitRelativeLevelGroup.hasAttribute('hidden')) {
                const trimmedRelativeLevel = typeof relativeLevelRaw === 'string' ? relativeLevelRaw.trim() : '';
                if (trimmedRelativeLevel) {
                    const parsedRelativeLevel = Number(trimmedRelativeLevel);
                    if (!Number.isFinite(parsedRelativeLevel)) {
                        alert('Relative level must be a number.');
                        return;
                    }
                    relativeLevelValue = parsedRelativeLevel;
                }
            }

            if (nameFieldsVisible && !name) {
                alert('Please provide a name for the exit.');
                return;
            }

            const creatingNewRegion = !selectedRegionId;
            const creatingNewLocation = Boolean(
                selectedRegionId
                && (!selectedLocationId || !Array.from(newExitLocationSelect?.options || []).some(opt => opt.value === selectedLocationId))
            );
            const usingExistingLocation = Boolean(selectedRegionId && selectedLocationId);
            const childRegionSelected = Boolean(creatingNewRegion && newExitChildRegionCheckbox?.checked);
            const parentRegionIdForChild = childRegionSelected
                ? (lastRenderedLocation?.regionId || lastRenderedLocation?.stubMetadata?.regionId || null)
                : null;

            const type = creatingNewRegion ? 'region' : 'location';
            const locationOption = selectedLocationId
                ? Array.from(newExitLocationSelect?.options || []).find(opt => opt.value === selectedLocationId)
                : null;
            const regionOption = getNewExitRegionOption(selectedRegionId);
            const locationName = usingExistingLocation
                ? (locationOption?.textContent?.trim() || locationOption?.value || '')
                : creatingNewLocation
                    ? name || 'New location'
                    : '';

            const payload = { type };
            if (!usingExistingLocation || name) {
                payload.name = name;
            }
            if (nameFieldsVisible || description) {
                payload.description = description;
            }
            if (selectedRegionId) {
                payload.regionId = selectedRegionId;
            }
            if (selectedLocationId) {
                payload.locationId = selectedLocationId;
            }
            if (creatingNewRegion && parentRegionIdForChild) {
                payload.parentRegionId = parentRegionIdForChild;
            }
            if (vehicleTypeInput) {
                payload.vehicleType = vehicleTypeInput;
            }
            if (relativeLevelValue !== null) {
                payload.relativeLevel = relativeLevelValue;
            }

            const imageFile = newExitImageInput?.files?.[0] || null;
            let imageDataUrl = '';
            let imageDataUrlOriginal = '';
            if (imageFile) {
                if (!creatingNewRegion && !creatingNewLocation) {
                    alert('Reference images are only supported when creating a new location or region.');
                    removePlaceholder();
                    return;
                }
                try {
                    const imagePayload = await readNewExitImageData(imageFile);
                    if (!imagePayload?.downscaledDataUrl || !imagePayload?.originalDataUrl) {
                        throw new Error('Reference image processing failed.');
                    }
                    imageDataUrl = imagePayload.downscaledDataUrl;
                    imageDataUrlOriginal = imagePayload.originalDataUrl;
                    payload.imageDataUrl = imageDataUrl;
                    payload.imageDataUrlOriginal = imageDataUrlOriginal;
                } catch (error) {
                    alert(error?.message || 'Failed to read reference image.');
                    return;
                }
            }

            const clientId = window.AIRPG_CLIENT_ID || null;
            if (clientId) {
                payload.clientId = clientId;
            }

            newExitSubmitting = true;
            closeNewExitModal();
            try {
                const response = await fetch(`/api/locations/${encodeURIComponent(activeLocationId)}/exits`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                newExitOptionsCache = null;
                newExitRegionsById = new Map();

                if (!isEditing) {
                    const mapMode = newExitMapMode;
                    const mapPosition = newExitMapPosition;
                    const shouldUpdateAdventure = !mapMode
                        || (lastRenderedLocation?.id && activeLocationId === lastRenderedLocation.id);
                    let mapUpdated = false;
                    if (mapMode && data?.created && typeof window.addMapStubNodeAndEdge === 'function') {
                        try {
                            const matchedExit = data.location
                                ? findExitMatchForPayload(data.location, payload, data.created)
                                : null;
                            mapUpdated = window.addMapStubNodeAndEdge({
                                sourceId: activeLocationId,
                                created: data.created,
                                position: mapPosition,
                                exitId: matchedExit?.id || null,
                                preservePosition: true
                            }) === true;
                        } catch (mapError) {
                            console.warn('Failed to update map after exit creation:', mapError);
                            mapUpdated = false;
                        }
                    }

                    if (shouldUpdateAdventure && data.location) {
                        lastRenderedLocation = JSON.parse(JSON.stringify(data.location));
                        const exits = Array.isArray(data.location.exits)
                            ? data.location.exits
                            : Object.values(data.location.exits || {});
                        exits.forEach(exit => {
                            if (exit && exit.destination && typeof exit.destinationName === 'string' && exit.destinationName.trim()) {
                                locationCache[exit.destination] = exit.destinationName.trim();
                            }
                        });
                        await window.updateLocationDisplay(data.location);
                    }

                    const mapTab = document.querySelector('[data-tab="map"]');
                    if (!mapUpdated && mapTab && mapTab.classList.contains('active')) {
                        window.loadRegionMap?.();
                    }
                } else {
                    let finalLocation = data.location || null;
                    const createdInfo = data.created || {};
                    const originalExitId = editingExitContext?.exitId || null;

                    const newExitMatch = findExitMatchForPayload(finalLocation, payload, createdInfo);
                    const newExitId = newExitMatch?.id || null;

                    let shouldRemoveOriginal = false;
                    if (originalExitId && newExitId && originalExitId !== newExitId) {
                        shouldRemoveOriginal = true;
                    } else if (!newExitId && originalExitId) {
                        // If destination changed but we couldn't identify the new exit, fall back to comparing existing exit
                        const originalStillPresent = Object.values(finalLocation?.exits || {})
                            .some(exit => exit?.id === originalExitId);
                        if (originalStillPresent) {
                            const desiredDestination = payload.locationId
                                || createdInfo?.destinationId
                                || null;
                            const originalExit = Object.values(finalLocation?.exits || {})
                                .find(exit => exit?.id === originalExitId);
                            if (originalExit && desiredDestination && originalExit.destination !== desiredDestination) {
                                shouldRemoveOriginal = true;
                            }
                        }
                    }

                    if (shouldRemoveOriginal && originalExitId) {
                        try {
                            const deleteResponse = await fetch(`/api/locations/${encodeURIComponent(activeLocationId)}/exits/${encodeURIComponent(originalExitId)}`, {
                                method: 'DELETE',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ clientId })
                            });
                            const deleteData = await deleteResponse.json().catch(() => ({}));
                            if (!deleteResponse.ok || !deleteData?.success) {
                                throw new Error(deleteData?.error || `HTTP ${deleteResponse.status}`);
                            }
                            finalLocation = deleteData.location || finalLocation;
                        } catch (deleteError) {
                            console.warn('Failed to remove previous exit during edit:', deleteError);
                            alert(`Exit update succeeded, but removing the previous exit failed: ${deleteError?.message || deleteError}`);
                        }
                    }

                    const locationPayload = finalLocation || (await (async () => {
                        try {
                            const cacheBuster = Date.now().toString(36);
                            const locationResponse = await fetch(`/api/locations/${encodeURIComponent(activeLocationId)}?_=${cacheBuster}`, { cache: 'no-store' });
                            const locationData = await locationResponse.json().catch(() => ({}));
                            return locationResponse.ok && locationData?.success ? locationData.location : null;
                        } catch (_) {
                            return null;
                        }
                    })());

                    if (locationPayload) {
                        lastRenderedLocation = JSON.parse(JSON.stringify(locationPayload));
                        await window.updateLocationDisplay(locationPayload);
                    } else {
                        await window.loadCurrentLocation?.();
                    }

                    const mapTab = document.querySelector('[data-tab="map"]');
                    if (mapTab && mapTab.classList.contains('active')) {
                        window.loadRegionMap?.();
                    }

                }
            } catch (error) {
                console.warn('Failed to create exit:', error);
                alert(`${isEditing ? 'Failed to update exit' : 'Failed to create exit'}: ${error?.message || 'Unknown error'}`);
            } finally {
                newExitSubmitting = false;
            }
        }

        function closeNewExitModal() {
            if (!newExitModal) {
                return;
            }
            newExitModal.setAttribute('aria-hidden', 'true');
            newExitModal.setAttribute('hidden', '');
            editingExitContext = null;
            newExitMapMode = false;
            newExitOriginLocationId = null;
            newExitOriginRegionId = null;
            newExitPreferredRegionId = null;
            newExitMapPosition = null;
            if (newExitForm) {
                newExitForm.reset();
            }
            if (newExitRegionSelect) {
                newExitRegionSelect.value = '';
            }
            if (newExitLocationSelect) {
                newExitLocationSelect.innerHTML = '';
            }
            if (newExitLocationGroup) {
                newExitLocationGroup.setAttribute('hidden', '');
            }
            if (newExitNameGroup) {
                newExitNameGroup.removeAttribute('hidden');
            }
            if (newExitDescriptionGroup) {
                newExitDescriptionGroup.removeAttribute('hidden');
            }
            if (newExitVehicleGroup) {
                newExitVehicleGroup.removeAttribute('hidden');
            }
            if (newExitImageInput) {
                newExitImageInput.value = '';
            }
            if (newExitVehicleInput) {
                newExitVehicleInput.value = '';
            }
            if (newExitRelativeLevelGroup) {
                newExitRelativeLevelGroup.setAttribute('hidden', '');
            }
            if (newExitRelativeLevelInput) {
                newExitRelativeLevelInput.value = '';
            }
            if (newExitChildRegionGroup) {
                newExitChildRegionGroup.setAttribute('hidden', '');
            }
            if (newExitChildRegionCheckbox) {
                newExitChildRegionCheckbox.checked = false;
            }
            setNewExitStatus('', null);
            if (newExitSaveBtn) {
                newExitSaveBtn.textContent = 'Create Exit';
                newExitSaveBtn.disabled = false;
            }
            if (newExitModalTitle) {
                newExitModalTitle.textContent = 'Add New Exit';
            }
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalBackdrop && inventoryHidden && viewHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
            if (newExitButton) {
                newExitButton.focus();
            }
        }

        function closeNpcViewModal() {
            if (!npcViewModal) {
                return;
            }
            npcViewModal.setAttribute('aria-hidden', 'true');
            npcViewModal.setAttribute('hidden', '');
            currentNpcViewId = null;
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (inventoryHidden && editHidden && thingHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeThingEditModal() {
            if (!thingEditModal) {
                return;
            }
            thingEditModal.setAttribute('aria-hidden', 'true');
            thingEditModal.setAttribute('hidden', '');
            updateThingEditStatus('');
            currentThingEditId = null;
            currentThingEditContext = null;
            currentThingEditMode = 'edit';
            currentThingCreationLocation = null;
            if (thingEditForm) {
                thingEditForm.reset();
                delete thingEditForm.dataset.thingId;
                delete thingEditForm.dataset.thingContext;
                delete thingEditForm.dataset.thingMode;
            }
            if (thingMetadataList) {
                thingMetadataList.innerHTML = '';
            }
            if (thingAttributeBonusesList) {
                thingAttributeBonusesList.innerHTML = '';
            }
            populateThingCauseStatusEffect(null, null);
            if (thingEditRarityInput) {
                thingEditRarityInput.innerHTML = '';
            }
            if (thingEditSlotSelect) {
                thingEditSlotSelect.innerHTML = '';
            }
            if (thingEditNotesInput) {
                thingEditNotesInput.value = '';
            }
            if (thingEditNotesGroup) {
                thingEditNotesGroup.setAttribute('hidden', '');
            }
            currentThingLockedMetadata = {};
            const npcModalHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const npcInventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const npcViewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const dispositionHidden = !npcDispositionModal || npcDispositionModal.hasAttribute('hidden');
            const needsHidden = !npcNeedsModal || npcNeedsModal.hasAttribute('hidden');
            const memoriesHidden = !npcMemoriesModal || npcMemoriesModal.hasAttribute('hidden');
            const goalsHidden = !npcGoalsModal || npcGoalsModal.hasAttribute('hidden');
            const newExitHidden = !newExitModal || newExitModal.hasAttribute('hidden');
            const addNpcHidden = !addNpcModal || addNpcModal.hasAttribute('hidden');
            const loadGameHidden = !loadGameModal || loadGameModal.hasAttribute('hidden');
            if (npcModalHidden && npcInventoryHidden && npcViewHidden && dispositionHidden && needsHidden && memoriesHidden && goalsHidden && newExitHidden && addNpcHidden && loadGameHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        if (loadGameCancelBtn) {
            loadGameCancelBtn.addEventListener('click', () => {
                closeLoadGameModal({ focusTrigger: true });
            });
        }

        if (loadGameCloseBtn) {
            loadGameCloseBtn.addEventListener('click', () => {
                closeLoadGameModal({ focusTrigger: true });
            });
        }

        if (loadGameSourceRadios && loadGameSourceRadios.length) {
            loadGameSourceRadios.forEach(radio => {
                radio.addEventListener('change', (event) => {
                    if (!event.target.checked) {
                        return;
                    }
                    const selectedSource = event.target.value === 'autosaves' ? 'autosaves' : 'saves';
                    refreshLoadGameList(selectedSource);
                });
            });
        }

        if (loadGameSelect && loadGameConfirmBtn) {
            loadGameSelect.addEventListener('dblclick', () => {
                if (!loadGameConfirmBtn.disabled) {
                    loadGameConfirmBtn.click();
                }
            });
            loadGameSelect.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    if (!loadGameConfirmBtn.disabled) {
                        loadGameConfirmBtn.click();
                    }
                }
            });
        }

        if (loadGameConfirmBtn) {
            loadGameConfirmBtn.addEventListener('click', async () => {
                if (!loadGameSelect || loadGameSelect.disabled) {
                    setLoadGameStatus(`No ${getLoadGameSourceLabel({ plural: true })} available.`, 'error');
                    return;
                }

                const saveName = loadGameSelect.value;
                if (!saveName) {
                    setLoadGameStatus(`Select a ${getLoadGameSourceLabel()} to load.`, 'error');
                    loadGameSelect.focus();
                    return;
                }

                const selectedSave = loadGameSaves.find(save => save.saveName === saveName);
                if (!selectedSave) {
                    setLoadGameStatus(`Selected ${getLoadGameSourceLabel()} could not be found.`, 'error');
                    return;
                }

                const selectedOption = loadGameSelect.selectedOptions ? loadGameSelect.selectedOptions[0] : null;
                const optionSource = selectedOption?.dataset?.source === 'autosaves' ? 'autosaves' : null;
                const saveSource = optionSource
                    || (selectedSave?.source === 'autosaves' ? 'autosaves' : (currentLoadGameSource === 'autosaves' ? 'autosaves' : 'saves'));
                const singularLabel = getLoadGameSourceLabel({ source: saveSource, plural: false });

                const originalLabel = loadGameConfirmBtn.textContent;
                try {
                    loadGameConfirmBtn.disabled = true;
                    loadGameConfirmBtn.textContent = 'Loading...';
                    if (loadGameCancelBtn) {
                        loadGameCancelBtn.disabled = true;
                    }
                    setLoadGameStatus(`Loading ${singularLabel}‚Ä¶`, 'info');
                    const clientId = window.AIRPG_CLIENT_ID
                        || (window.localStorage ? window.localStorage.getItem('airpg:clientId') : null);

                    const loadResponse = await fetch('/api/load', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ saveName, saveType: saveSource, clientId })
                    });

                    const loadResult = await loadResponse.json().catch(() => ({}));

                    if (loadResponse.ok && loadResult?.success) {
                        closeLoadGameModal();
                        window.location.reload();
                    } else {
                        const errorMessage = loadResult?.error || `HTTP ${loadResponse.status}`;
                        setLoadGameStatus(errorMessage, 'error');
                        loadGameConfirmBtn.disabled = false;
                        loadGameConfirmBtn.textContent = originalLabel;
                        if (loadGameCancelBtn) {
                            loadGameCancelBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    setLoadGameStatus(error.message, 'error');
                    loadGameConfirmBtn.disabled = false;
                    loadGameConfirmBtn.textContent = originalLabel;
                    if (loadGameCancelBtn) {
                        loadGameCancelBtn.disabled = false;
                    }
                }
            });
        }

        if (npcAddSkillBtn) {
            npcAddSkillBtn.addEventListener('click', () => {
                createSkillRow({ name: '', value: '' });
                if (npcEditSkillsContainer) {
                    npcEditSkillsContainer.scrollTop = npcEditSkillsContainer.scrollHeight;
                }
            });
        }

        if (npcAddAbilityBtn) {
            npcAddAbilityBtn.addEventListener('click', () => {
                createAbilityRow({});
                if (npcEditAbilitiesContainer) {
                    npcEditAbilitiesContainer.scrollTop = npcEditAbilitiesContainer.scrollHeight;
                }
            });
        }

        if (npcStatusEffectAddBtn) {
            npcStatusEffectAddBtn.addEventListener('click', () => {
                const row = createNpcStatusEffectRow({});
                row?.querySelector('.thing-edit-status-description')?.focus();
            });
        }

        if (npcEditCancelBtn) {
            npcEditCancelBtn.addEventListener('click', () => {
                closeNpcEditModal();
            });
        }

        if (npcEditCloseBtn) {
            npcEditCloseBtn.addEventListener('click', () => {
                closeNpcEditModal();
            });
        }

        if (npcInventoryCloseBtn) {
            npcInventoryCloseBtn.addEventListener('click', () => {
                closeNpcInventoryModal();
            });
        }

        if (craftingCancelButton) {
            craftingCancelButton.addEventListener('click', () => {
                closeCraftingModal();
            });
        }

        if (craftingActionButton) {
            craftingActionButton.addEventListener('click', async () => {
                await submitCraftingRequest();
            });
        }

        if (craftingModalCloseBtn) {
            craftingModalCloseBtn.addEventListener('click', () => {
                closeCraftingModal();
            });
        }
        if (craftingInventoryFilterInput) {
            craftingInventoryFilterInput.addEventListener('input', () => renderCraftingInventory());
        }

        if (craftingModalBackdrop) {
            craftingModalBackdrop.addEventListener('click', () => {
                closeCraftingModal();
            });
        }

        if (salvageIntentSubmitBtn) {
            salvageIntentSubmitBtn.addEventListener('click', () => submitSalvageIntent());
        }

        if (salvageIntentCancelBtn) {
            salvageIntentCancelBtn.addEventListener('click', () => closeSalvageIntentModal());
        }

        if (salvageIntentCloseBtn) {
            salvageIntentCloseBtn.addEventListener('click', () => closeSalvageIntentModal());
        }

        if (salvageIntentBackdrop) {
            salvageIntentBackdrop.addEventListener('click', () => closeSalvageIntentModal());
        }

        document.addEventListener('keydown', (event) => {
            if (event.key !== 'Escape') {
                return;
            }
            const salvageModalOpen = salvageIntentModal && salvageIntentModal.getAttribute('aria-hidden') === 'false';
            if (salvageModalOpen) {
                event.preventDefault();
                closeSalvageIntentModal();
                return;
            }
            if (craftingIsOpen) {
                event.preventDefault();
                closeCraftingModal();
            }
        });

        function setupCtrlEnterSubmission() {
            const handleCtrlEnter = (event) => {
                if (event.isComposing || event.key !== 'Enter' || !(event.ctrlKey || event.metaKey)) {
                    return;
                }

                const active = document.activeElement;

                const triggerSubmitForScope = (root) => {
                    if (!root) return false;
                    const submitBtn = root.querySelector('button[type="submit"]:not([disabled])')
                        || root.querySelector('.button-primary:not([disabled])');
                    if (submitBtn) {
                        event.preventDefault();
                        submitBtn.click();
                        return true;
                    }
                    return false;
                };

                // Prefer the nearest form to the focused element
                const form = active?.closest?.('form');
                if (form && triggerSubmitForScope(form)) {
                    return;
                }

                // If a modal is open, try its primary action
                const openModal = document.querySelector('.modal[aria-hidden="false"]');
                if (openModal && triggerSubmitForScope(openModal)) {
                    return;
                }

                // Fallback: chat send button when focus is in the message input
                if (messageInput && (active === messageInput || messageInput.contains(active)) && sendButton && !sendButton.disabled) {
                    event.preventDefault();
                    sendButton.click();
                }
            };

            document.addEventListener('keydown', handleCtrlEnter);
        }

        setupCtrlEnterSubmission();

        if (npcDispositionCancelBtn) {
            npcDispositionCancelBtn.addEventListener('click', () => {
                closeNpcDispositionModal();
            });
        }

        if (npcDispositionCloseBtn) {
            npcDispositionCloseBtn.addEventListener('click', () => {
                closeNpcDispositionModal();
            });
        }

        if (npcDispositionForm) {
            npcDispositionForm.addEventListener('submit', submitNpcDispositions);
        }

        if (npcNeedsCancelBtn) {
            npcNeedsCancelBtn.addEventListener('click', () => {
                closeNpcNeedsModal();
            });
        }

        if (npcNeedsCloseBtn) {
            npcNeedsCloseBtn.addEventListener('click', () => {
                closeNpcNeedsModal();
            });
        }

        if (npcNeedsForm) {
            npcNeedsForm.addEventListener('submit', submitNpcNeeds);
        }

        if (npcMemoriesCancelBtn) {
            npcMemoriesCancelBtn.addEventListener('click', () => {
                closeNpcMemoriesModal();
            });
        }

        if (npcMemoriesCloseBtn) {
            npcMemoriesCloseBtn.addEventListener('click', () => {
                closeNpcMemoriesModal();
            });
        }

        if (npcMemoriesSaveBtn) {
            npcMemoriesSaveBtn.addEventListener('click', async () => {
                await saveNpcMemories();
            });
            npcMemoriesSaveBtn.disabled = true;
        }

        if (npcMemoriesAddBtn) {
            npcMemoriesAddBtn.addEventListener('click', () => {
                if (!npcMemoriesList) {
                    return;
                }
                const row = createNpcMemoryRow('');
                npcMemoriesList.appendChild(row);
                const textarea = row.querySelector('.npc-memory-text');
                if (textarea) {
                    textarea.focus();
                }
                markNpcMemoriesDirty();
            });
        }

        if (npcMemoriesList) {
            npcMemoriesList.addEventListener('dragover', (event) => {
                if (!draggedNpcMemoryRow) {
                    return;
                }
                event.preventDefault();
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = 'move';
                }
                const targetRow = event.target.closest('.npc-memory-row');
                if (!targetRow) {
                    if (npcMemoriesList.lastElementChild !== draggedNpcMemoryRow) {
                        npcMemoriesList.appendChild(draggedNpcMemoryRow);
                        markNpcMemoriesDirty();
                    }
                    return;
                }
                if (targetRow === draggedNpcMemoryRow) {
                    return;
                }
                const targetRect = targetRow.getBoundingClientRect();
                const shouldInsertBefore = event.clientY < targetRect.top + targetRect.height / 2;
                if (shouldInsertBefore) {
                    npcMemoriesList.insertBefore(draggedNpcMemoryRow, targetRow);
                } else {
                    npcMemoriesList.insertBefore(draggedNpcMemoryRow, targetRow.nextSibling);
                }
                markNpcMemoriesDirty();
            });

            npcMemoriesList.addEventListener('drop', (event) => {
                if (!draggedNpcMemoryRow) {
                    return;
                }
                event.preventDefault();
                draggedNpcMemoryRow.classList.remove('dragging');
                draggedNpcMemoryRow = null;
                markNpcMemoriesDirty();
            });

            npcMemoriesList.addEventListener('dragend', () => {
                if (draggedNpcMemoryRow) {
                    draggedNpcMemoryRow.classList.remove('dragging');
                    draggedNpcMemoryRow = null;
                }
            });
        }

        if (npcGoalsCancelBtn) {
            npcGoalsCancelBtn.addEventListener('click', () => {
                closeNpcGoalsModal();
            });
        }

        if (npcGoalsCloseBtn) {
            npcGoalsCloseBtn.addEventListener('click', () => {
                closeNpcGoalsModal();
            });
        }

        if (npcGoalsSaveBtn) {
            npcGoalsSaveBtn.addEventListener('click', async () => {
                await saveNpcGoals();
            });
        }

        if (npcGoalsAddBtn) {
            npcGoalsAddBtn.addEventListener('click', () => {
                if (!npcGoalsList) {
                    return;
                }
                const row = createNpcGoalRow('');
                npcGoalsList.appendChild(row);
                const textarea = row.querySelector('.npc-goal-text');
                if (textarea) {
                    textarea.focus();
                }
                markNpcGoalsDirty();
            });
        }

        if (npcGoalsList) {
            npcGoalsList.addEventListener('dragover', (event) => {
                if (!draggedNpcGoalRow) {
                    return;
                }
                event.preventDefault();
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = 'move';
                }
                const targetRow = event.target.closest('.npc-goal-row');
                if (!targetRow) {
                    if (npcGoalsList.lastElementChild !== draggedNpcGoalRow) {
                        npcGoalsList.appendChild(draggedNpcGoalRow);
                        markNpcGoalsDirty();
                    }
                    return;
                }
                if (targetRow === draggedNpcGoalRow) {
                    return;
                }
                const targetRect = targetRow.getBoundingClientRect();
                const shouldInsertBefore = event.clientY < targetRect.top + targetRect.height / 2;
                if (shouldInsertBefore) {
                    npcGoalsList.insertBefore(draggedNpcGoalRow, targetRow);
                } else {
                    npcGoalsList.insertBefore(draggedNpcGoalRow, targetRow.nextSibling);
                }
                markNpcGoalsDirty();
            });

            npcGoalsList.addEventListener('drop', (event) => {
                if (!draggedNpcGoalRow) {
                    return;
                }
                event.preventDefault();
                draggedNpcGoalRow.classList.remove('dragging');
                draggedNpcGoalRow = null;
                markNpcGoalsDirty();
            });

            npcGoalsList.addEventListener('dragend', () => {
                if (draggedNpcGoalRow) {
                    draggedNpcGoalRow.classList.remove('dragging');
                    draggedNpcGoalRow = null;
                }
            });
        }

        if (addNpcButton) {
            addNpcButton.addEventListener('click', () => {
                openAddNpcModal();
            });
        }

        if (addThingButton) {
            addThingButton.addEventListener('click', () => {
                openAddThingModal();
            });
        }

        if (craftSceneryButton) {
            craftSceneryButton.addEventListener('click', () => {
                openCraftingModal({ mode: 'craft', sourceThing: null, targetType: 'scenery' });
            });
        }

        if (craftItemButton) {
            craftItemButton.addEventListener('click', () => {
                openCraftingModal({ mode: 'craft', sourceThing: null, targetType: 'item' });
            });
        }

        if (addNpcCancelBtn) {
            addNpcCancelBtn.addEventListener('click', () => {
                closeAddNpcModal({ focusTrigger: true });
            });
        }

        if (addNpcCloseBtn) {
            addNpcCloseBtn.addEventListener('click', () => {
                closeAddNpcModal({ focusTrigger: true });
            });
        }

        if (addNpcForm) {
            addNpcForm.addEventListener('submit', submitAddNpc);
        }

        if (newExitButton) {
            newExitButton.addEventListener('click', () => {
                openNewExitModal();
            });
        }

        if (newExitCancelBtn) {
            newExitCancelBtn.addEventListener('click', () => {
                closeNewExitModal();
            });
        }

        if (newExitCloseBtn) {
            newExitCloseBtn.addEventListener('click', () => {
                closeNewExitModal();
            });
        }

        if (newExitRegionSelect) {
            newExitRegionSelect.addEventListener('change', handleNewExitRegionChange);
        }

        if (newExitLocationSelect) {
            newExitLocationSelect.addEventListener('change', handleNewExitLocationChange);
        }

        if (newExitForm) {
            newExitForm.addEventListener('submit', submitNewExit);
        }

        if (npcInventoryFilterInput) {
            npcInventoryFilterInput.addEventListener('input', () => {
                renderNpcInventory(currentNpcInventory);
            });
        }

        if (npcInventorySlotFilter) {
            npcInventorySlotFilter.addEventListener('change', () => {
                renderNpcInventory(currentNpcInventory);
            });
        }

        const filterRadios = [
            npcInventoryShowAllRadio,
            npcInventoryEquippedOnlyRadio,
            npcInventoryEquippableOnlyRadio,
            npcInventoryNonEquippableOnlyRadio
        ].filter(Boolean);

        filterRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) {
                    renderNpcInventory(currentNpcInventory);
                }
            });
        });

        if (npcViewCloseBtn) {
            npcViewCloseBtn.addEventListener('click', () => {
                closeNpcViewModal();
            });
        }

        if (thingEditCancelBtn) {
            thingEditCancelBtn.addEventListener('click', () => {
                closeThingEditModal();
            });
        }

        if (thingEditCloseBtn) {
            thingEditCloseBtn.addEventListener('click', () => {
                closeThingEditModal();
            });
        }

        if (thingMetadataAddBtn) {
            thingMetadataAddBtn.addEventListener('click', () => {
                const row = createThingMetadataRow({});
                row?.querySelector('.thing-edit-metadata-key')?.focus();
            });
        }

        if (thingAttributeBonusAddBtn) {
            thingAttributeBonusAddBtn.addEventListener('click', async () => {
                await ensureAttributeDefinitions();
                const row = createThingAttributeBonusRow({});
                row?.querySelector('.thing-edit-bonus-attribute')?.focus();
            });
        }

        if (thingCauseEffectTargetAddModifierBtn && thingCauseEffectTargetModifiers) {
            thingCauseEffectTargetAddModifierBtn.addEventListener('click', () => {
                thingCauseEffectTargetModifiers.appendChild(thingModifierTemplates.createRow(null));
            });
        }

        if (thingCauseEffectEquipperAddModifierBtn && thingCauseEffectEquipperModifiers) {
            thingCauseEffectEquipperAddModifierBtn.addEventListener('click', () => {
                thingCauseEffectEquipperModifiers.appendChild(thingModifierTemplates.createRow(null));
            });
        }

        if (thingEditSlotSelect) {
            thingEditSlotSelect.addEventListener('change', () => updateThingStatusEffectVisibility());
        }
        if (thingEditTypeSelect) {
            thingEditTypeSelect.addEventListener('change', () => updateThingStatusEffectVisibility());
        }

        if (npcModalBackdrop) {
            npcModalBackdrop.addEventListener('click', (event) => {
                if (event.target === npcModalBackdrop) {
                    if (addNpcModal && !addNpcModal.hasAttribute('hidden')) {
                        closeAddNpcModal({ focusTrigger: true });
                    } else if (newExitModal && !newExitModal.hasAttribute('hidden')) {
                        closeNewExitModal();
                    } else if (npcNeedsModal && !npcNeedsModal.hasAttribute('hidden')) {
                        closeNpcNeedsModal();
                    } else if (npcMemoriesModal && !npcMemoriesModal.hasAttribute('hidden')) {
                        closeNpcMemoriesModal();
                    } else if (npcGoalsModal && !npcGoalsModal.hasAttribute('hidden')) {
                        closeNpcGoalsModal();
                    } else if (npcDispositionModal && !npcDispositionModal.hasAttribute('hidden')) {
                        closeNpcDispositionModal();
                    } else if (thingEditModal && !thingEditModal.hasAttribute('hidden')) {
                        closeThingEditModal();
                    } else if (npcViewModal && !npcViewModal.hasAttribute('hidden')) {
                        closeNpcViewModal();
                    } else if (npcInventoryModal && !npcInventoryModal.hasAttribute('hidden')) {
                        closeNpcInventoryModal();
                    } else if (npcEditModal && !npcEditModal.hasAttribute('hidden')) {
                        closeNpcEditModal();
                    }
                }
            });
        }

        if (npcEditModal) {
            npcEditModal.addEventListener('click', (event) => {
                if (event.target === npcEditModal) {
                    closeNpcEditModal();
                }
            });
        }

        if (npcInventoryModal) {
            npcInventoryModal.addEventListener('click', (event) => {
                if (event.target === npcInventoryModal) {
                    closeNpcInventoryModal();
                }
            });
        }

        if (npcViewModal) {
            npcViewModal.addEventListener('click', (event) => {
                if (event.target === npcViewModal) {
                    closeNpcViewModal();
                }
            });
        }

        if (thingEditModal) {
            thingEditModal.addEventListener('click', (event) => {
                if (event.target === thingEditModal) {
                    closeThingEditModal();
                }
            });
        }

        if (npcEditLevelInput) {
            npcEditLevelInput.addEventListener('input', updateNpcMaxHealth);
            npcEditLevelInput.addEventListener('change', updateNpcMaxHealth);
        }

        if (npcEditHealthAttributeSelect) {
            npcEditHealthAttributeSelect.addEventListener('change', updateNpcMaxHealth);
        }

        if (npcEditForm) {
            npcEditForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (!currentNpcEditId) {
                    updateNpcEditStatus('No NPC selected.', 'error');
                    return;
                }

                const payload = {};

                const trimmedName = npcEditNameInput?.value?.trim();
                if (trimmedName) {
                    payload.name = trimmedName;
                }
                if (npcEditDescriptionInput) {
                    payload.description = npcEditDescriptionInput.value ?? '';
                }
                if (npcEditShortDescriptionInput) {
                    payload.shortDescription = npcEditShortDescriptionInput.value ?? '';
                }
                if (npcEditRaceInput) {
                    payload.race = npcEditRaceInput.value ?? '';
                }
                if (npcEditClassInput) {
                    payload.class = npcEditClassInput.value ?? '';
                }
                if (npcEditPersonalityTypeInput) {
                    payload.personalityType = npcEditPersonalityTypeInput.value ?? '';
                }
                if (npcEditPersonalityTraitsInput) {
                    payload.personalityTraits = npcEditPersonalityTraitsInput.value ?? '';
                }
                if (npcEditPersonalityNotesInput) {
                    payload.personalityNotes = npcEditPersonalityNotesInput.value ?? '';
                }

                const parsedLevel = Number.parseInt(npcEditLevelInput?.value ?? '', 10);
                if (Number.isFinite(parsedLevel)) {
                    payload.level = parsedLevel;
                }

                const parsedHealth = Number.parseInt(npcEditHealthInput?.value ?? '', 10);
                if (Number.isFinite(parsedHealth)) {
                    payload.health = parsedHealth;
                }

                const parsedUnspent = Number.parseInt(npcEditUnspentInput?.value ?? '', 10);
                if (Number.isFinite(parsedUnspent) && parsedUnspent >= 0) {
                    payload.unspentSkillPoints = parsedUnspent;
                }

                const parsedCurrency = Number.parseInt(npcEditCurrencyInput?.value ?? '', 10);
                if (Number.isFinite(parsedCurrency) && parsedCurrency >= 0) {
                    payload.currency = parsedCurrency;
                }

                const parsedExperience = Number.parseInt(npcEditExperienceInput?.value ?? '', 10);
                if (Number.isFinite(parsedExperience) && parsedExperience >= 0) {
                    payload.experience = parsedExperience;
                }

                if (npcEditFactionSelect) {
                    try {
                        const factionId = await resolveSelectedFactionId(npcEditFactionSelect, { label: 'faction' });
                        payload.factionId = factionId;
                    } catch (error) {
                        updateNpcEditStatus(error?.message || 'Failed to validate faction.', 'error');
                        npcEditFactionSelect?.focus();
                        return;
                    }
                }

                const attributes = getNpcAttributesFromInputs();
                payload.attributes = attributes;

                const selectedHealthAttribute = npcEditHealthAttributeSelect && !npcEditHealthAttributeSelect.disabled
                    ? (npcEditHealthAttributeSelect.value || '').trim()
                    : '';
                if (selectedHealthAttribute) {
                    payload.healthAttribute = selectedHealthAttribute;
                }

                const skills = {};
                if (npcEditSkillsContainer) {
                    npcEditSkillsContainer.querySelectorAll('.npc-skill-row').forEach(row => {
                        const name = row.querySelector('.npc-skill-name')?.value?.trim();
                        if (!name) {
                            return;
                        }
                        const valueInput = row.querySelector('.npc-skill-value');
                        const numeric = Number.parseInt(valueInput?.value ?? '', 10);
                        skills[name] = Number.isFinite(numeric) ? numeric : 0;
                    });
                }
                payload.skills = skills;

                const abilityEntries = [];
                if (npcEditAbilitiesContainer) {
                    const abilityRows = npcEditAbilitiesContainer.querySelectorAll('.npc-ability-row');
                    for (const row of abilityRows) {
                        const abilityName = row.querySelector('.npc-ability-name')?.value?.trim();
                        if (!abilityName) {
                            continue;
                        }
                        const abilityType = row.querySelector('.npc-ability-type')?.value || 'Passive';
                        const abilityLevel = Number.parseInt(row.querySelector('.npc-ability-level')?.value ?? '', 10);
                        const abilityDescription = row.querySelector('.npc-ability-description')?.value?.trim() || '';
                        const abilityShortDescription = row.querySelector('.npc-ability-short-description')?.value?.trim() || '';
                        if (!abilityShortDescription) {
                            updateNpcEditStatus('Ability short descriptions are required.', 'error');
                            row.querySelector('.npc-ability-short-description')?.focus();
                            return;
                        }
                        abilityEntries.push({
                            name: abilityName,
                            type: abilityType,
                            level: Number.isFinite(abilityLevel) ? abilityLevel : 1,
                            description: abilityDescription,
                            shortDescription: abilityShortDescription
                        });
                    }
                }
                payload.abilities = abilityEntries;

                const statusEffectsPayload = collectNpcStatusEffects();
                payload.statusEffects = statusEffectsPayload;

                const knownSkillSet = typeof window.getKnownSkillNameSet === 'function'
                    ? window.getKnownSkillNameSet()
                    : new Set();
                const unseenSkillKeys = new Set();
                for (const skillName of Object.keys(skills)) {
                    if (typeof skillName !== 'string') {
                        continue;
                    }
                    const normalized = skillName.trim().toLowerCase();
                    if (normalized && !knownSkillSet.has(normalized)) {
                        unseenSkillKeys.add(normalized);
                    }
                }

                const shouldGenerateSkillDetails = unseenSkillKeys.size > 0;
                let reloadTriggered = false;

                try {
                    if (shouldGenerateSkillDetails) {
                        updateNpcEditStatus('Generating skill details...');
                        if (typeof showLocationOverlay === 'function') {
                            showLocationOverlay('Generating skill details...');
                        }
                    } else {
                        updateNpcEditStatus('Saving changes...');
                    }

                    if (npcEditSaveBtn) {
                        npcEditSaveBtn.disabled = true;
                    }

                    const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcEditId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to update NPC');
                    }

                    if (shouldGenerateSkillDetails) {
                        updateNpcEditStatus('Skills updated. Refreshing...', 'success');
                        reloadTriggered = true;
                        window.location.reload();
                        return;
                    }

                    updateNpcEditStatus('Changes saved.', 'success');

                    if (typeof window.loadCurrentLocation === 'function') {
                        await window.loadCurrentLocation();
                    }
                    window.refreshParty?.();

                    closeNpcEditModal();
                } catch (error) {
                    updateNpcEditStatus(error?.message || 'Failed to update NPC.', 'error');
                    if (shouldGenerateSkillDetails && typeof hideLocationOverlay === 'function') {
                        hideLocationOverlay();
                    }
                } finally {
                    if (npcEditSaveBtn && !reloadTriggered) {
                        npcEditSaveBtn.disabled = false;
                    }
                    if (shouldGenerateSkillDetails && !reloadTriggered && typeof hideLocationOverlay === 'function') {
                        hideLocationOverlay();
                    }
                }
            });
        }

        if (thingEditForm) {
            thingEditForm.addEventListener('submit', async (event) => {
                event.preventDefault();

                const mode = (thingEditForm.dataset.thingMode === 'create' || currentThingEditMode === 'create')
                    ? 'create'
                    : 'edit';

                if (mode === 'create') {
                    if (!currentThingCreationLocation || !currentThingCreationLocation.id) {
                        updateThingEditStatus('No active location is available for adding items.', 'error');
                        return;
                    }

                    const trimmedName = thingEditNameInput?.value?.trim();
                    if (!trimmedName) {
                        updateThingEditStatus('Please provide a name for the item.', 'error');
                        thingEditNameInput?.focus();
                        return;
                    }

                    updateThingEditStatus('Generating item...');
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = true;
                    }

                    const typeSelection = (thingEditTypeSelect?.value || '').toLowerCase() === 'scenery'
                        ? 'scenery'
                        : 'item';
                    const seed = {
                        name: trimmedName,
                        itemOrScenery: typeSelection
                    };

                    const descriptionValue = thingEditDescriptionInput?.value?.trim();
                    if (descriptionValue) {
                        seed.description = descriptionValue;
                    }
                    const shortDescriptionValue = thingEditShortDescriptionInput?.value?.trim();
                    if (shortDescriptionValue) {
                        seed.shortDescription = shortDescriptionValue;
                    }
                    const notesValue = thingEditNotesInput?.value?.trim();
                    if (notesValue) {
                        seed.notes = notesValue;
                    }

                    const detailValue = thingEditItemDetailInput?.value?.trim();
                    if (detailValue) {
                        seed.type = detailValue;
                    }

                    const slotValue = normalizeSlotType(thingEditSlotSelect?.value || '');
                    if (slotValue) {
                        addAvailableSlotType(slotValue);
                        seed.slot = slotValue;
                    }

                    const rarityKey = thingEditRarityInput?.value?.trim();
                    if (rarityKey) {
                        seed.rarity = getRarityLabel(rarityKey);
                    }

                    const payload = { seed };

                    const levelRaw = thingEditLevelInput?.value;
                    if (levelRaw !== undefined && levelRaw !== null && String(levelRaw).trim() !== '') {
                        const numericLevel = Number(levelRaw);
                        if (Number.isFinite(numericLevel)) {
                            payload.level = Math.max(1, Math.round(numericLevel));
                        }
                    }

                    let overlayShown = false;
                    try {
                        showLocationOverlay('Forging a new item...');
                        overlayShown = true;

                        const response = await fetch(`/api/locations/${encodeURIComponent(currentThingCreationLocation.id)}/things`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        const result = await response.json().catch(() => ({}));
                        if (!response.ok || !result?.success) {
                            throw new Error(result?.error || `Request failed with status ${response.status}`);
                        }

                        closeThingEditModal();

                        if (result.location) {
                            lastRenderedLocation = JSON.parse(JSON.stringify(result.location));
                            await window.updateLocationDisplay(result.location);
                        } else if (typeof window.loadCurrentLocation === 'function') {
                            await window.loadCurrentLocation();
                        }

                        window.refreshInventory?.();
                        window.refreshParty?.();
                    } catch (error) {
                        console.warn('Failed to create item:', error);
                        updateThingEditStatus(error?.message || 'Failed to create item.', 'error');
                    } finally {
                        if (overlayShown) {
                            hideLocationOverlay();
                        }
                        if (thingEditSaveBtn) {
                            thingEditSaveBtn.disabled = false;
                        }
                    }

                    return;
                }

                if (!currentThingEditId) {
                    updateThingEditStatus('No item selected.', 'error');
                    return;
                }

                updateThingEditStatus('');

                const payload = {};

                const trimmedName = thingEditNameInput?.value?.trim();
                if (trimmedName) {
                    payload.name = trimmedName;
                }

                if (thingEditDescriptionInput) {
                    payload.description = thingEditDescriptionInput.value ?? '';
                }
                if (thingEditShortDescriptionInput) {
                    payload.shortDescription = thingEditShortDescriptionInput.value?.trim() ?? '';
                }

                if (thingEditTypeSelect) {
                    const typeValue = (thingEditTypeSelect.value || '').toLowerCase();
                    payload.thingType = typeValue === 'scenery' ? 'scenery' : 'item';
                }

                if (thingEditRarityInput) {
                    const rarityKey = thingEditRarityInput.value?.trim();
                    payload.rarity = rarityKey ? getRarityLabel(rarityKey) : null;
                }

                if (thingEditItemDetailInput) {
                    const detailValue = thingEditItemDetailInput.value?.trim();
                    payload.itemTypeDetail = detailValue || null;
                }

                if (thingEditSlotSelect) {
                    const slotValue = normalizeSlotType(thingEditSlotSelect.value);
                    if (slotValue) {
                        addAvailableSlotType(slotValue);
                    }
                    payload.slot = slotValue || null;
                }

                if (thingEditLevelInput) {
                    const parsedLevel = Number.parseInt(thingEditLevelInput.value ?? '', 10);
                    payload.level = Number.isFinite(parsedLevel) ? parsedLevel : null;
                }

                if (thingEditImageIdInput) {
                    const imageValue = thingEditImageIdInput.value?.trim();
                    payload.imageId = imageValue || null;
                }

                const metadataValue = collectThingMetadataEntries();
                const finalMetadata = { ...metadataValue };
                if (currentThingLockedMetadata && typeof currentThingLockedMetadata === 'object') {
                    Object.entries(currentThingLockedMetadata).forEach(([key, value]) => {
                        if (value !== undefined) {
                            finalMetadata[key] = value;
                        }
                    });
                }
                if (thingEditIsVehicleInput) {
                    const flag = Boolean(thingEditIsVehicleInput.checked);
                    finalMetadata.isVehicle = flag;
                    payload.isVehicle = flag;
                }
                if (thingEditIsCraftingStationInput) {
                    const flag = Boolean(thingEditIsCraftingStationInput.checked);
                    finalMetadata.isCraftingStation = flag;
                    payload.isCraftingStation = flag;
                }
                if (thingEditIsProcessingStationInput) {
                    const flag = Boolean(thingEditIsProcessingStationInput.checked);
                    finalMetadata.isProcessingStation = flag;
                    payload.isProcessingStation = flag;
                }
                if (thingEditIsHarvestableInput) {
                    const flag = Boolean(thingEditIsHarvestableInput.checked);
                    finalMetadata.isHarvestable = flag;
                    payload.isHarvestable = flag;
                }
                if (thingEditIsSalvageableInput) {
                    const flag = Boolean(thingEditIsSalvageableInput.checked);
                    finalMetadata.isSalvageable = flag;
                    payload.isSalvageable = flag;
                }
                payload.metadata = finalMetadata;

                const attributeBonusesValue = collectThingAttributeBonuses();
                payload.attributeBonuses = attributeBonusesValue;

                const causeStatusEffectValue = collectThingCauseStatusEffect();
                if (causeStatusEffectValue) {
                    if (causeStatusEffectValue.target) {
                        payload.causeStatusEffectOnTarget = causeStatusEffectValue.target;
                    }
                    if (causeStatusEffectValue.equipper) {
                        payload.causeStatusEffectOnEquipper = causeStatusEffectValue.equipper;
                    }
                } else {
                    payload.causeStatusEffectOnTarget = null;
                    payload.causeStatusEffectOnEquipper = null;
                }

                if (!payload.thingType) {
                    payload.thingType = 'item';
                }

                try {
                    updateThingEditStatus('Saving changes...');
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = true;
                    }

                    const response = await fetch(`/api/things/${encodeURIComponent(currentThingEditId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    let result = {};
                    try {
                        result = await response.json();
                    } catch (_) {
                        // ignore JSON parse failures; handled below
                    }

                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to update item.');
                    }

                    const updatedThing = result?.thing || { ...thingDataCache.get(currentThingEditId), ...payload, id: currentThingEditId };
                    cacheThingData(updatedThing);

                    if (currentThingEditContext === 'npc-inventory' && Array.isArray(currentNpcInventory)) {
                        currentNpcInventory = currentNpcInventory.map(item => item && item.id === updatedThing.id ? updatedThing : item);
                        renderNpcInventory(currentNpcInventory);
                    }

                    updateThingEditStatus('Changes saved.', 'success');

                    try {
                        if (currentThingEditContext === 'location') {
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } else if (currentThingEditContext === 'npc-inventory') {
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } else {
                            if (typeof window.refreshInventory === 'function') {
                                await window.refreshInventory();
                            }
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        }
                        window.refreshParty?.();
                    } catch (refreshError) {
                        console.warn('Failed to refresh displays after item update:', refreshError);
                    }

                    closeThingEditModal();
                } catch (error) {
                    updateThingEditStatus(error?.message || 'Failed to update item.', 'error');
                } finally {
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = false;
                    }
                }
            });
        }

        function bindThingTooltip(element, thing) {
            if (!element || !thing) {
                return;
            }

            element.addEventListener('mouseenter', (event) => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.show === 'function') {
                    const description = thing.description || 'No description provided.';
                    const fallbackTooltip = `<div class="tooltip-thing is-item"><div class="tooltip-thing-description">${escapeHtml(description)}</div></div>`;
                    const tooltipContent = formatThingTooltip(thing) || fallbackTooltip;
                    window.floatingTooltipController.show(tooltipContent, event, { allowHTML: true });
                }
            });

            element.addEventListener('mousemove', (event) => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.move === 'function') {
                    window.floatingTooltipController.move(event);
                }
            });

            element.addEventListener('mouseleave', () => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.hide === 'function') {
                    window.floatingTooltipController.hide();
                }
            });
        }

        async function setNpcItemEquipped(npcId, item, shouldEquip, { slotName = null, slotType = null } = {}) {
            if (!npcId || !item || !item.id) {
                return;
            }

            try {
                const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}/equipment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        itemId: item.id,
                        action: shouldEquip ? 'equip' : 'unequip',
                        slotName: slotName || null,
                        slotType: slotType || null
                    })
                });

                const result = await response.json().catch(() => ({}));
                if (!response.ok || !result?.success) {
                    throw new Error(result?.error || `Request failed with status ${response.status}`);
                }

                const updatedInventory = Array.isArray(result.npc?.inventory) ? result.npc.inventory : [];
                currentNpcInventory = updatedInventory;
                renderNpcInventory(updatedInventory);
                window.refreshParty?.();
            } catch (error) {
                console.warn('Failed to update NPC equipment:', error);
                alert(`Failed to update equipment: ${error.message || error}`);
            }
        }

        function renderNpcInventory(items = []) {
            if (!npcInventoryGrid || !npcInventoryEmpty || !npcInventoryCount) {
                return;
            }

            const safeItems = Array.isArray(items) ? items : [];
            const filterValueRaw = typeof npcInventoryFilterInput?.value === 'string'
                ? npcInventoryFilterInput.value.trim().toLowerCase()
                : '';
            const equippedOnlyActive = Boolean(npcInventoryEquippedOnlyRadio?.checked);
            const equippableOnlyActive = Boolean(npcInventoryEquippableOnlyRadio?.checked);
            const nonEquippableOnlyActive = Boolean(npcInventoryNonEquippableOnlyRadio?.checked);

            // If both equippable-only and non-equippable-only are checked, treat as no equippable filter (show all)
            const applyEquippableFilter = !(equippableOnlyActive && nonEquippableOnlyActive);

            const normalizeSlotLabel = (value) => {
                if (value === undefined || value === null) {
                    return null;
                }
                const text = typeof value === 'string' ? value.trim() : String(value).trim();
                if (!text || text.toLowerCase() === 'n/a') {
                    return null;
                }
                return text;
            };

            const getItemSlotInfo = (item) => {
                const slotTypeValueRaw = typeof item?.slot === 'string' && item.slot.trim()
                    ? item.slot.trim()
                    : (typeof item?.metadata?.slot === 'string' && item.metadata.slot.trim()
                        ? item.metadata.slot.trim()
                        : null);
                const equippedSlot = normalizeSlotLabel(item?.equippedSlot);
                const rawSlot = normalizeSlotLabel(slotTypeValueRaw);
                const slotLabel = equippedSlot || rawSlot || null;
                const canModifyEquipment = Boolean(slotTypeValueRaw || equippedSlot);
                return {
                    slotTypeValueRaw,
                    equippedSlot,
                    rawSlot,
                    slotLabel,
                    canModifyEquipment
                };
            };

            const slotMap = new Map();
            if (npcInventorySlotFilter) {
                safeItems.forEach(item => {
                    const slotInfo = getItemSlotInfo(item);
                    const candidates = [
                        slotInfo.slotLabel,
                        slotInfo.rawSlot,
                        slotInfo.equippedSlot,
                        normalizeSlotLabel(item?.slot),
                        normalizeSlotLabel(item?.metadata?.slot)
                    ].filter(Boolean);
                    for (const candidate of candidates) {
                        const normalized = candidate.toLowerCase();
                        if (!slotMap.has(normalized)) {
                            slotMap.set(normalized, candidate);
                        }
                    }
                });

                const slotEntries = Array.from(slotMap.entries())
                    .sort((a, b) => a[1].localeCompare(b[1], undefined, { sensitivity: 'base' }));
                const signature = JSON.stringify(slotEntries.map(([value]) => value));
                if (npcInventorySlotFilter.dataset.optionSignature !== signature) {
                    npcInventorySlotFilter.innerHTML = '';
                    const allOption = document.createElement('option');
                    allOption.value = '';
                    allOption.textContent = 'All slots';
                    npcInventorySlotFilter.appendChild(allOption);
                    slotEntries.forEach(([value, label]) => {
                        const option = document.createElement('option');
                        option.value = value;
                        option.textContent = label;
                        npcInventorySlotFilter.appendChild(option);
                    });
                    npcInventorySlotFilter.dataset.optionSignature = signature;
                    if (npcInventorySlotFilter.value && !slotMap.has(npcInventorySlotFilter.value)) {
                        npcInventorySlotFilter.value = '';
                    }
                }
            }

            const filteredItems = safeItems.filter(item => {
                const slotInfo = getItemSlotInfo(item);
                const isEquipped = Boolean(item?.isEquipped || item?.equippedSlot);

                if (npcInventorySlotFilter && npcInventorySlotFilter.value) {
                    const normalizedSlotFilter = npcInventorySlotFilter.value.toLowerCase();
                    const slotCandidates = [slotInfo.slotLabel, slotInfo.rawSlot, slotInfo.equippedSlot]
                        .map(value => (typeof value === 'string' ? value.trim().toLowerCase() : null))
                        .filter(Boolean);
                    if (!slotCandidates.includes(normalizedSlotFilter)) {
                        return false;
                    }
                }

                if (equippedOnlyActive && !isEquipped) {
                    return false;
                }

                if (applyEquippableFilter) {
                    if (equippableOnlyActive && !slotInfo.canModifyEquipment) {
                        return false;
                    }
                    if (nonEquippableOnlyActive && slotInfo.canModifyEquipment) {
                        return false;
                    }
                }

                if (!filterValueRaw) {
                    return true;
                }

                const haystack = [
                    item?.name,
                    item?.description,
                    item?.thingType,
                    item?.rarity,
                    item?.slot,
                    item?.metadata?.slot,
                    item?.metadata?.properties,
                    slotInfo.canModifyEquipment ? 'equippable' : 'non-equippable'
                ];
                return haystack.some(value => typeof value === 'string' && value.toLowerCase().includes(filterValueRaw));
            });

            npcInventoryGrid.innerHTML = '';
            const filtersApplied = Boolean(filterValueRaw)
                || equippedOnlyActive
                || (applyEquippableFilter && (equippableOnlyActive || nonEquippableOnlyActive));

            npcInventoryCount.textContent = filtersApplied
                ? `${filteredItems.length} of ${safeItems.length} ${safeItems.length === 1 ? 'item' : 'items'}`
                : `${safeItems.length} ${safeItems.length === 1 ? 'item' : 'items'}`;

            if (!filteredItems.length) {
                npcInventoryGrid.style.display = 'none';
                npcInventoryEmpty.textContent = safeItems.length === 0
                    ? npcInventoryEmptyDefaultText
                    : 'No items match your filters.';
                npcInventoryEmpty.style.display = 'block';
            } else {
                npcInventoryGrid.style.display = 'flex';
                npcInventoryEmpty.textContent = npcInventoryEmptyDefaultText;
                npcInventoryEmpty.style.display = 'none';
            }

            filteredItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'location-entity-card inventory-card';

                const equipped = Boolean(item?.isEquipped || item?.equippedSlot);
                if (equipped) {
                    card.classList.add('is-equipped');
                }

                const slotInfo = getItemSlotInfo(item);

                const icon = document.createElement('div');
                icon.className = 'inventory-icon';
                renderEntityImage({
                    element: icon,
                    entityType: 'thing',
                    entityId: item.id,
                    imageId: item.imageId || null,
                    altText: item.name || 'Inventory item',
                    placeholderIcon: item.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ',
                    placeholderClass: 'location-entity-placeholder',
                    badges: getThingPropertyBadges(item)
                });

                const name = document.createElement('div');
                name.className = 'inventory-name';
                name.textContent = item.name || 'Unknown Item';
                applyRarityClass(name, item.rarity);

                const equippedSlot = slotInfo.equippedSlot;
                const slotTypeValueRaw = slotInfo.slotTypeValueRaw;
                const rawSlot = slotInfo.rawSlot;
                const slotLabel = slotInfo.slotLabel;
                const canModifyEquipment = slotInfo.canModifyEquipment;

                const slotBadge = document.createElement('div');
                slotBadge.className = 'inventory-slot-tag';
                if (slotLabel) {
                    slotBadge.textContent = slotLabel;
                }

                let equipToggle = null;
                if (canModifyEquipment) {
                    equipToggle = document.createElement('button');
                    equipToggle.type = 'button';
                    equipToggle.className = 'inventory-equip-toggle';
                    equipToggle.textContent = equipped ? 'Unequip' : 'Equip';

                    equipToggle.addEventListener('click', (event) => {
                        event.stopPropagation();
                        event.preventDefault();
                        if (!currentNpcInventoryNpcId) {
                            return;
                        }
                        equipToggle.disabled = true;
                        setNpcItemEquipped(currentNpcInventoryNpcId, item, !equipped, {
                            slotName: equippedSlot || null,
                            slotType: slotTypeValueRaw || null
                        })
                            .finally(() => {
                                equipToggle.disabled = false;
                            });
                    });
                }

                card.appendChild(icon);
                card.appendChild(name);
                if (slotLabel) {
                    card.appendChild(slotBadge);
                }
                if (equipToggle) {
                    card.appendChild(equipToggle);
                }

                registerThingContextMenu(card, item, { context: 'npc-inventory', npcId: currentNpcInventoryNpcId });

                bindThingTooltip(card, item);

                npcInventoryGrid.appendChild(card);
            });

            try {
                document.dispatchEvent(new Event('inventory:updated'));
            } catch (_) {}
        }

        async function showNpcDispositionModal(npc) {
            if (!npc || !npcDispositionModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            currentNpcDispositionId = npc.id || null;
            currentNpcDispositionData = null;
            updateNpcDispositionSummary(null);
            setNpcDispositionStatus('', null);
            if (npcDispositionLoading) {
                npcDispositionLoading.removeAttribute('hidden');
            }
            if (npcDispositionList) {
                npcDispositionList.innerHTML = '';
                npcDispositionList.setAttribute('aria-busy', 'true');
            }
            if (npcDispositionEmpty) {
                npcDispositionEmpty.setAttribute('hidden', '');
            }
            if (npcDispositionSaveBtn) {
                npcDispositionSaveBtn.disabled = true;
            }

            npcModalBackdrop.removeAttribute('hidden');
            npcDispositionModal.removeAttribute('hidden');
            npcDispositionModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcDispositionModalTitle) {
                const titleName = npc.name || 'NPC';
                npcDispositionModalTitle.textContent = `${formatPossessiveName(titleName, 'NPC')} Dispositions`;
            }
            scrollModalToTop(npcDispositionModal);

            try {
                const response = await fetch(`/api/npcs/${encodeURIComponent(npc.id)}/dispositions`, {
                    cache: 'no-store'
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const payload = {
                    npc: data.npc || { id: npc.id, name: npc.name || 'NPC' },
                    player: data.player || null,
                    range: {
                        min: Number.isFinite(data.range?.min) ? data.range.min : null,
                        max: Number.isFinite(data.range?.max) ? data.range.max : null,
                        typicalStep: Number.isFinite(data.range?.typicalStep) ? data.range.typicalStep : null,
                        typicalBigStep: Number.isFinite(data.range?.typicalBigStep) ? data.range.typicalBigStep : null
                    },
                    dispositions: Array.isArray(data.dispositions)
                        ? data.dispositions.map(entry => ({
                            ...entry,
                            value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                            originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                        }))
                        : []
                };

                currentNpcDispositionData = payload;
                if (npcDispositionModalTitle) {
                    const resolvedName = payload.npc?.name || npc.name || 'NPC';
                    npcDispositionModalTitle.textContent = `${formatPossessiveName(resolvedName, 'NPC')} Dispositions`;
                }
                updateNpcDispositionSummary(payload);
                renderNpcDispositionEntries(payload);
                setNpcDispositionStatus('', null);
                updateCachedNpcDispositions(npc.id, payload);
            } catch (error) {
                console.warn('Failed to load NPC dispositions:', error);
                currentNpcDispositionData = null;
                updateNpcDispositionSummary({
                    npc: { name: npc.name || 'NPC' },
                    player: null,
                    range: {}
                });
                if (npcDispositionModalTitle) {
                    const resolvedName = npc.name || 'NPC';
                    npcDispositionModalTitle.textContent = `${formatPossessiveName(resolvedName, 'NPC')} Dispositions`;
                }
                if (npcDispositionList) {
                    npcDispositionList.innerHTML = '';
                }
                if (npcDispositionEmpty) {
                    npcDispositionEmpty.removeAttribute('hidden');
                }
                setNpcDispositionStatus(`Failed to load dispositions: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (npcDispositionList) {
                    npcDispositionList.removeAttribute('aria-busy');
                }
                if (npcDispositionLoading) {
                    npcDispositionLoading.setAttribute('hidden', '');
                }
                setNpcDispositionDirty();
            }
        }

        async function submitNpcDispositions(event) {
            if (event) {
                event.preventDefault();
            }

            if (!currentNpcDispositionData || !currentNpcDispositionId) {
                setNpcDispositionStatus('No disposition changes to save.', null);
                setNpcDispositionDirty();
                return;
            }

            const updates = currentNpcDispositionData.dispositions
                .filter(entry => entry.value !== entry.originalValue)
                .map(entry => ({ key: entry.key, value: entry.value }));

            if (!updates.length) {
                setNpcDispositionStatus('No changes to save.', null);
                setNpcDispositionDirty();
                return;
            }

            setNpcDispositionStatus('Saving disposition changes‚Ä¶', null);
            if (npcDispositionSaveBtn) {
                npcDispositionSaveBtn.disabled = true;
            }

            try {
                const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcDispositionId)}/dispositions`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ dispositions: updates })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const payload = {
                    npc: data.npc || currentNpcDispositionData.npc,
                    player: data.player || currentNpcDispositionData.player,
                    range: {
                        min: Number.isFinite(data.range?.min) ? data.range.min : currentNpcDispositionData.range?.min ?? null,
                        max: Number.isFinite(data.range?.max) ? data.range.max : currentNpcDispositionData.range?.max ?? null,
                        typicalStep: Number.isFinite(data.range?.typicalStep) ? data.range.typicalStep : currentNpcDispositionData.range?.typicalStep ?? null,
                        typicalBigStep: Number.isFinite(data.range?.typicalBigStep) ? data.range.typicalBigStep : currentNpcDispositionData.range?.typicalBigStep ?? null
                    },
                    dispositions: Array.isArray(data.dispositions)
                        ? data.dispositions.map(entry => ({
                            ...entry,
                            value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                            originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                        }))
                        : []
                };

                currentNpcDispositionData = payload;
                updateNpcDispositionSummary(payload);
                renderNpcDispositionEntries(payload);
                setNpcDispositionStatus(data.message || 'Dispositions updated successfully.', 'success');

                const updatedNpc = updateCachedNpcDispositions(currentNpcDispositionId, payload);
                if (updatedNpc && currentNpcViewId === currentNpcDispositionId) {
                    showNpcViewModal(updatedNpc);
                }

                closeNpcDispositionModal();
                document.body.classList.remove('modal-open');
            } catch (error) {
                console.warn('Failed to update NPC dispositions:', error);
                setNpcDispositionStatus(`Failed to update dispositions: ${error?.message || 'Unknown error'}`, 'error');
                if (npcDispositionSaveBtn) {
                    npcDispositionSaveBtn.disabled = false;
                }
            } finally {
                setNpcDispositionDirty();
            }
        }

        async function showNpcNeedsModal(target, options = {}) {
            if (!target || !npcNeedsModal || !npcModalBackdrop) {
                return;
            }

            const type = options.type || (target.isNPC ? 'npc' : 'player');
            const fallbackPlayerId = window.currentPlayerData && typeof window.currentPlayerData.id === 'string'
                ? window.currentPlayerData.id
                : null;
            const targetId = typeof target.id === 'string' && target.id
                ? target.id
                : (type === 'player' ? fallbackPlayerId : null);

            if (type === 'npc' && !targetId) {
                console.warn('Unable to open needs editor: NPC id missing');
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            currentNpcNeedsTargetId = targetId || null;
            currentNpcNeedsTargetType = type;
            currentNpcNeedsData = null;
            updateNpcNeedsSummary(null);
            setNpcNeedsStatus('', null);
            if (npcNeedsLoading) {
                npcNeedsLoading.removeAttribute('hidden');
            }
            if (npcNeedsList) {
                npcNeedsList.innerHTML = '';
                npcNeedsList.setAttribute('aria-busy', 'true');
            }
            if (npcNeedsEmpty) {
                npcNeedsEmpty.setAttribute('hidden', '');
            }
            if (npcNeedsSaveBtn) {
                npcNeedsSaveBtn.disabled = true;
            }

            npcModalBackdrop.removeAttribute('hidden');
            npcNeedsModal.removeAttribute('hidden');
            npcNeedsModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (npcNeedsModalTitle) {
                const fallbackLabel = type === 'player' ? 'Player' : 'Character';
                const displayName = target?.name || (type === 'player' && window.currentPlayerData?.name ? window.currentPlayerData.name : '') || fallbackLabel;
                npcNeedsModalTitle.textContent = `${formatPossessiveName(displayName, fallbackLabel)} Needs`;
            }
            scrollModalToTop(npcNeedsModal);

            const endpoint = type === 'player'
                ? '/api/player/needs'
                : `/api/npcs/${encodeURIComponent(targetId)}/needs`;

            try {
                const response = await fetch(endpoint, { cache: 'no-store' });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const normalizedNeeds = Array.isArray(data.needs)
                    ? data.needs.map(entry => ({
                        ...entry,
                        value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                        originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                    }))
                    : [];

                const payload = {
                    type,
                    targetId,
                    player: data.player || (type === 'player' ? { id: targetId, name: target.name || 'Player', isNPC: false } : null),
                    npc: data.npc || (type === 'npc' ? { id: targetId, name: target.name || 'NPC', isNPC: true } : null),
                    includePlayerOnly: data.includePlayerOnly !== undefined ? Boolean(data.includePlayerOnly) : type !== 'npc',
                    needs: normalizedNeeds
                };

                currentNpcNeedsData = payload;
                currentNpcNeedsTargetId = payload.npc?.id || payload.player?.id || targetId || null;
                if (npcNeedsModalTitle) {
                    const resolvedName = payload.npc?.name || payload.player?.name || target.name || (type === 'player' ? 'Player' : 'Character');
                    const fallbackLabel = type === 'player' ? 'Player' : 'Character';
                    npcNeedsModalTitle.textContent = `${formatPossessiveName(resolvedName, fallbackLabel)} Needs`;
                }
                updateNpcNeedsSummary(payload);
                renderNpcNeedsEntries(payload);
                setNpcNeedsStatus('', null);

                if (type === 'npc') {
                    updateCachedNpcNeeds(targetId, normalizedNeeds);
                } else {
                    if (window.currentPlayerData && (!targetId || window.currentPlayerData.id === targetId)) {
                        window.currentPlayerData = {
                            ...window.currentPlayerData,
                            needBars: normalizedNeeds.map(bar => ({ ...bar }))
                        };
                        updateChatPlayerPanel(window.currentPlayerData);
                        renderNeedBars(chatSidebarElements.needBars, window.currentPlayerData.needBars, {
                            includePlayerOnly: true,
                            variant: 'player'
                        });
                    }
                    if (window.currentNpcData instanceof Map && payload.player?.id) {
                        updateCachedNpcNeeds(payload.player.id, normalizedNeeds);
                    }
                }
            } catch (error) {
                console.warn('Failed to load needs:', error);
                currentNpcNeedsData = null;
                updateNpcNeedsSummary({
                    player: type === 'player' ? { name: target.name || 'Player' } : null,
                    npc: type === 'npc' ? { name: target.name || 'NPC' } : null
                });
                if (npcNeedsModalTitle) {
                    const fallbackLabel = type === 'player' ? 'Player' : 'Character';
                    const resolvedName = target.name || fallbackLabel;
                    npcNeedsModalTitle.textContent = `${formatPossessiveName(resolvedName, fallbackLabel)} Needs`;
                }
                if (npcNeedsList) {
                    npcNeedsList.innerHTML = '';
                }
                if (npcNeedsEmpty) {
                    npcNeedsEmpty.removeAttribute('hidden');
                }
                setNpcNeedsStatus(`Failed to load needs: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (npcNeedsList) {
                    npcNeedsList.removeAttribute('aria-busy');
                }
                if (npcNeedsLoading) {
                    npcNeedsLoading.setAttribute('hidden', '');
                }
                setNpcNeedsDirty();
            }
        }

        async function submitNpcNeeds(event) {
            if (event) {
                event.preventDefault();
            }

            if (!currentNpcNeedsData || !currentNpcNeedsTargetId) {
                setNpcNeedsStatus('No need changes to save.', null);
                setNpcNeedsDirty();
                return;
            }

            const updates = currentNpcNeedsData.needs
                .filter(entry => entry.value !== entry.originalValue)
                .map(entry => ({ id: entry.id, value: entry.value }));

            if (!updates.length) {
                setNpcNeedsStatus('No changes to save.', null);
                setNpcNeedsDirty();
                return;
            }

            setNpcNeedsStatus('Saving need changes‚Ä¶', null);
            if (npcNeedsSaveBtn) {
                npcNeedsSaveBtn.disabled = true;
            }

            const endpoint = currentNpcNeedsTargetType === 'player'
                ? '/api/player/needs'
                : `/api/npcs/${encodeURIComponent(currentNpcNeedsTargetId)}/needs`;

            try {
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ needs: updates })
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                const normalizedNeeds = Array.isArray(data.needs)
                    ? data.needs.map(entry => ({
                        ...entry,
                        value: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0,
                        originalValue: Number.isFinite(Number(entry.value)) ? Math.round(Number(entry.value)) : 0
                    }))
                    : [];

            const payload = {
                type: currentNpcNeedsTargetType,
                targetId: currentNpcNeedsTargetId,
                player: data.player || currentNpcNeedsData.player || null,
                npc: data.npc || currentNpcNeedsData.npc || null,
                    includePlayerOnly: data.includePlayerOnly !== undefined
                        ? Boolean(data.includePlayerOnly)
                        : currentNpcNeedsData.includePlayerOnly,
                    needs: normalizedNeeds
                };

                currentNpcNeedsData = payload;
                currentNpcNeedsTargetId = payload.npc?.id || payload.player?.id || currentNpcNeedsTargetId;
                updateNpcNeedsSummary(payload);
                renderNpcNeedsEntries(payload);
                setNpcNeedsStatus(data.message || 'Need bars updated successfully.', 'success');

                if (payload.type === 'npc') {
                    const npcId = payload.npc?.id || currentNpcNeedsTargetId;
                    const updatedNpc = updateCachedNpcNeeds(npcId, normalizedNeeds);
                    if (updatedNpc) {
                        if (currentNpcViewId === npcId) {
                            showNpcViewModal(updatedNpc);
                        }
                        window.refreshParty?.();
                        window.loadCurrentLocation?.();
                    }
                    closeNpcNeedsModal();
                    document.body.classList.remove('modal-open');
                } else {
                    const playerId = payload.player?.id || currentNpcNeedsTargetId;
                    if (window.currentPlayerData && window.currentPlayerData.id === playerId) {
                        window.currentPlayerData = {
                            ...window.currentPlayerData,
                            needBars: normalizedNeeds.map(bar => ({ ...bar }))
                        };
                        updateChatPlayerPanel(window.currentPlayerData);
                        renderNeedBars(chatSidebarElements.needBars, window.currentPlayerData.needBars, {
                            includePlayerOnly: true,
                            variant: 'player'
                        });
                    }
                    if (window.currentNpcData instanceof Map && playerId) {
                        updateCachedNpcNeeds(playerId, normalizedNeeds);
                    }
                    closeNpcNeedsModal();
                    document.body.classList.remove('modal-open');
                }
            } catch (error) {
                console.warn('Failed to update needs:', error);
                setNpcNeedsStatus(`Failed to update needs: ${error?.message || 'Unknown error'}`, 'error');
                if (npcNeedsSaveBtn) {
                    npcNeedsSaveBtn.disabled = false;
                }
            } finally {
                setNpcNeedsDirty();
            }
        }

        function showNpcInventoryModal(npc) {
            if (!npc || !npcInventoryModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            npcInventoryModal.setAttribute('aria-hidden', 'false');
            npcInventoryModal.removeAttribute('hidden');
            npcModalBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');
            if (npcInventoryModalTitle) {
                const titleName = npc.name || 'Character';
                npcInventoryModalTitle.textContent = `${formatPossessiveName(titleName, 'Character')} Inventory`;
            }
            scrollModalToTop(npcInventoryModal);

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());
            const npcId = npc.id || null;
            npcInventoryName.textContent = npc.name || 'Character';
            const items = Array.isArray(npc.inventory) ? npc.inventory : [];
            currentNpcInventory = items;
            currentNpcInventoryNpcId = npcId;
            if (npcInventoryFilterInput) {
                npcInventoryFilterInput.value = '';
            }
            if (npcInventorySlotFilter) {
                npcInventorySlotFilter.value = '';
            }
            if (npcInventoryShowAllRadio) {
                npcInventoryShowAllRadio.checked = true;
            }
            if (npcInventoryEquippedOnlyRadio) {
                npcInventoryEquippedOnlyRadio.checked = false;
            }
            if (npcInventoryEquippableOnlyRadio) {
                npcInventoryEquippableOnlyRadio.checked = false;
            }
            if (npcInventoryNonEquippableOnlyRadio) {
                npcInventoryNonEquippableOnlyRadio.checked = false;
            }
            renderNpcInventory(items);

            if (npcId) {
                (async () => {
                    try {
                        const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });
                        const data = await response.json().catch(() => ({}));
                        if (!response.ok || !data?.success || !data.npc) {
                            return;
                        }

                        npcDataCache.set(npcId, cloneActorRecord(data.npc) || { ...data.npc });
                        const freshItems = Array.isArray(data.npc.inventory) ? data.npc.inventory : [];
                        currentNpcInventory = freshItems;
                        currentNpcInventoryNpcId = npcId;
                        npcInventoryName.textContent = data.npc.name || npcInventoryName.textContent;
                        if (npcInventoryModalTitle) {
                            const titleName = data.npc.name || 'Character';
                            npcInventoryModalTitle.textContent = `${formatPossessiveName(titleName, 'Character')} Inventory`;
                        }
                        renderNpcInventory(freshItems);
                    } catch (error) {
                        console.warn('Failed to refresh NPC inventory before opening modal:', error);
                    }
                })();
            }
        }

        function openCraftingModalFromBadge(badgeKey, hostElement) {
            const mode = badgeKey === 'isProcessingStation' ? 'process' : 'craft';
            const thingId = hostElement?.dataset?.imageEntityId || null;
            let sourceThing = null;
            if (thingId && thingDataCache instanceof Map && thingDataCache.has(thingId)) {
                sourceThing = thingDataCache.get(thingId);
            }
            const targetType = mode === 'craft' ? 'item' : null;
            openCraftingModal({ mode, sourceThing, targetType });
        }

        function attemptSalvageFromBadge(hostElement) {
            if (!hostElement) {
                return;
            }
            const thingId = hostElement?.dataset?.imageEntityId || null;
            if (!thingId) {
                alert('Unable to salvage: missing item reference.');
                return;
            }
            let targetThing = null;
            if (thingDataCache instanceof Map && thingDataCache.has(thingId)) {
                targetThing = thingDataCache.get(thingId);
            }
            openSalvageIntentModal({ mode: 'salvage', thingId, thing: targetThing });
        }

        function attemptHarvestFromBadge(hostElement) {
            if (!hostElement) {
                return;
            }
            const thingId = hostElement?.dataset?.imageEntityId || null;
            if (!thingId) {
                alert('Unable to harvest: missing item reference.');
                return;
            }
            let targetThing = null;
            if (thingDataCache instanceof Map && thingDataCache.has(thingId)) {
                targetThing = thingDataCache.get(thingId);
            }
            openSalvageIntentModal({ mode: 'harvest', thingId, thing: targetThing });
        }

        function openSalvageIntentModal({ mode = 'salvage', thingId = null, thing = null } = {}) {
            if (!salvageIntentModal || !salvageIntentBackdrop || !thingId) {
                return;
            }
            const isHarvestMode = mode === 'harvest';
            salvageIntentContext = { mode: isHarvestMode ? 'harvest' : 'salvage', thingId, thing };
            const fallbackName = isHarvestMode ? 'this resource' : 'this item';
            const thingName = thing?.name?.trim() || fallbackName;

            if (salvageIntentTitle) {
                salvageIntentTitle.textContent = isHarvestMode ? 'Harvest Goal' : 'Salvage Goal';
            }
            if (salvageIntentMessage) {
                salvageIntentMessage.textContent = isHarvestMode
                    ? `Harvest from "${thingName}". Optionally describe what you hope to obtain.`
                    : `Salvage "${thingName}". Optionally describe what you hope to recover.`;
            }
            if (salvageIntentInput) {
                salvageIntentInput.value = '';
                salvageIntentInput.placeholder = isHarvestMode
                    ? 'Optionally describe what you hope to harvest.'
                    : 'Optionally describe what you hope to salvage.';
            }
            if (salvageIntentSubmitBtn) {
                salvageIntentSubmitBtn.textContent = isHarvestMode ? 'Start Harvest' : 'Start Salvage';
            }
            salvageIntentBackdrop.removeAttribute('hidden');
            salvageIntentModal.removeAttribute('hidden');
            salvageIntentModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            if (salvageIntentInput) {
                requestAnimationFrame(() => salvageIntentInput.focus());
            }
        }

        function closeSalvageIntentModal() {
            if (!salvageIntentModal || !salvageIntentBackdrop) {
                return;
            }
            salvageIntentModal.setAttribute('aria-hidden', 'true');
            salvageIntentModal.setAttribute('hidden', '');
            salvageIntentBackdrop.setAttribute('hidden', '');
            salvageIntentContext = { mode: 'salvage', thingId: null, thing: null };
            if (salvageIntentInput) {
                salvageIntentInput.value = '';
            }
            const anyOpenModal = document.querySelector('.modal[aria-hidden="false"]');
            if (!anyOpenModal) {
                document.body.classList.remove('modal-open');
            }
        }

        async function submitSalvageIntent() {
            const { mode, thingId, thing } = salvageIntentContext || {};
            if (!thingId) {
                closeSalvageIntentModal();
                return;
            }
            const notes = (salvageIntentInput?.value || '').trim();
            closeSalvageIntentModal();
            await submitSalvageRequest({ thingId, thing, mode, notes });
        }

        function openCraftingModal({ mode = 'craft', sourceThing = null, targetType = null } = {}) {
            if (!craftingModal || !craftingModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            if (npcInventoryModal && npcInventoryModal.getAttribute('aria-hidden') === 'false') {
                try {
                    closeNpcInventoryModal();
                } catch (_) {}
            }

            currentCraftingMode = mode === 'process' ? 'process' : 'craft';
            currentCraftingSlotCount = currentCraftingMode === 'process' ? 1 : 4;
            const normalizedTargetType = typeof targetType === 'string' ? targetType.trim().toLowerCase() : '';
            currentCraftingTargetType = (currentCraftingMode === 'craft' && normalizedTargetType === 'scenery')
                ? 'scenery'
                : 'item';
            craftingSlotAssignments = new Map();
            craftingInventoryLookup = new Map();
            craftingSourceThing = sourceThing || null;

            const playerData = typeof getLatestPlayerData === 'function'
                ? getLatestPlayerData()
                : (window.currentPlayerData || null);
            const inventoryItems = Array.isArray(playerData?.inventory) ? playerData.inventory : [];

            renderCraftingInventory(inventoryItems);
            renderCraftingSlots(currentCraftingSlotCount);
            updateCraftingActionState();

            const stationName = craftingSourceThing?.name
                || (currentCraftingMode === 'process' ? 'Processing Station' : 'Crafting Station');
            const craftTargetLabel = currentCraftingTargetType === 'scenery' ? 'scenery' : 'item';
            const craftTargetLabelTitle = currentCraftingTargetType === 'scenery' ? 'Scenery' : 'Item';
            if (craftingModalTitle) {
                craftingModalTitle.textContent = stationName;
            }
            if (craftingWorkspaceTitle) {
                craftingWorkspaceTitle.textContent = currentCraftingMode === 'process'
                    ? 'Processing Slot'
                    : 'Crafting Slots';
            }
            if (craftingModalHint) {
                craftingModalHint.textContent = currentCraftingMode === 'process'
                    ? 'Drag a single item into the slot to process it. Items remain in your inventory until you confirm.'
                    : `Drag up to four items into the slots to craft ${craftTargetLabel}. Items remain in your inventory until you confirm.`;
            }
            if (craftingActionButton) {
                craftingActionButton.textContent = currentCraftingMode === 'process'
                    ? 'Process Item'
                    : `Craft ${craftTargetLabelTitle}`;
            }
            if (craftingNotesInput) {
                craftingNotesInput.value = '';
                craftingNotesInput.placeholder = currentCraftingMode === 'process'
                    ? 'Optionally, describe what you are trying to create via processing.'
                    : `Optionally, describe what you are trying to craft (${craftTargetLabel}).`;
            }

            craftingModal.removeAttribute('hidden');
            craftingModal.setAttribute('aria-hidden', 'false');
            craftingModalBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');
            craftingIsOpen = true;
            scrollModalToTop(craftingModal);
        }

        function closeCraftingModal() {
            if (!craftingModal || !craftingModalBackdrop) {
                return;
            }
            craftingModal.setAttribute('hidden', '');
            craftingModal.setAttribute('aria-hidden', 'true');
            craftingModalBackdrop.setAttribute('hidden', '');
            craftingSlotAssignments = new Map();
            craftingInventoryLookup = new Map();
            craftingInventoryCardRefs.forEach(card => {
                card.classList.remove('is-used');
                card.removeAttribute('aria-disabled');
                card.draggable = true;
            });
            craftingInventoryCardRefs = new Map();
            craftingSourceThing = null;
            currentCraftingTargetType = 'item';
            if (craftingNotesInput) {
                craftingNotesInput.value = '';
            }
            craftingIsOpen = false;
            document.body.classList.remove('modal-open');
            updateCraftingActionState();
        }

        function renderCraftingInventory(items = null) {
            if (!craftingInventoryGrid || !craftingInventoryEmpty) {
                return;
            }

            if (Array.isArray(items)) {
                craftingInventoryAllItems = items;
            }

            craftingInventoryGrid.innerHTML = '';
            craftingInventoryLookup = new Map();
            craftingInventoryCardRefs = new Map();
            const safeItems = Array.isArray(craftingInventoryAllItems) ? craftingInventoryAllItems : [];

            const filterValue = (craftingInventoryFilterInput?.value || '').toLowerCase().trim();
            const filteredItems = filterValue
                ? safeItems.filter(item => {
                    const name = (item?.name || '').toLowerCase();
                    const desc = (item?.description || '').toLowerCase();
                    return name.includes(filterValue) || desc.includes(filterValue);
                })
                : safeItems;

            if (!safeItems.length) {
                craftingInventoryEmpty.removeAttribute('hidden');
                craftingInventoryGrid.setAttribute('hidden', '');
                return;
            }

            craftingInventoryEmpty.setAttribute('hidden', '');
            craftingInventoryGrid.removeAttribute('hidden');

            const itemsToRender = filteredItems.length ? filteredItems : [];

            if (!itemsToRender.length) {
                craftingInventoryGrid.innerHTML = '<div class="crafting-modal__empty">No items match your filter.</div>';
            }

            itemsToRender.forEach(item => {
                const clone = cloneThingRecord(item) || { ...item };
                if (clone.id) {
                    craftingInventoryLookup.set(clone.id, clone);
                }
                const card = document.createElement('div');
                card.className = 'location-entity-card inventory-card crafting-inventory-card';
                card.tabIndex = 0;
                if (clone.id) {
                    card.dataset.thingId = clone.id;
                    card.draggable = true;
                    craftingInventoryCardRefs.set(clone.id, card);
                }

                const icon = document.createElement('div');
                icon.className = 'inventory-icon';
                renderEntityImage({
                    element: icon,
                    entityType: 'thing',
                    entityId: clone.id || '',
                    imageId: clone.imageId || null,
                    altText: clone.name || 'Inventory item',
                    placeholderIcon: clone.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ',
                    placeholderClass: 'location-entity-placeholder',
                    badges: getThingPropertyBadges(clone)
                });

                const name = document.createElement('div');
                name.className = 'inventory-name';
                name.textContent = clone.name || 'Unknown Item';
                applyRarityClass(name, clone.rarity);

                const rawSlot = typeof clone.slot === 'string' ? clone.slot.trim() : '';
                const metadataSlot = typeof clone.metadata?.slot === 'string' ? clone.metadata.slot.trim() : '';
                const slotLabelRaw = rawSlot && rawSlot.toLowerCase() !== 'n/a'
                    ? rawSlot
                    : (metadataSlot && metadataSlot.toLowerCase() !== 'n/a' ? metadataSlot : '');
                card.appendChild(icon);
                card.appendChild(name);
                if (slotLabelRaw) {
                    const slotBadge = document.createElement('div');
                    slotBadge.className = 'inventory-slot-tag';
                    slotBadge.textContent = slotLabelRaw;
                    card.appendChild(slotBadge);
                }

                if (clone.id) {
                    const isAlreadyAssigned = isItemIdAssignedToAnySlot(clone.id);
                    if (isAlreadyAssigned) {
                        markCraftingInventoryItemUsed(clone.id, true);
                        card.draggable = false;
                    } else {
                        markCraftingInventoryItemUsed(clone.id, false);
                        card.draggable = true;
                    }
                    card.addEventListener('dragstart', handleCraftingInventoryDragStart);
                    card.addEventListener('dragend', handleCraftingInventoryDragEnd);
                    card.addEventListener('dblclick', () => {
                        if (!assignItemToFirstAvailableSlot(clone.id)) {
                            assignItemToCraftingSlot(0, clone.id);
                        }
                    });
                    card.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            if (!assignItemToFirstAvailableSlot(clone.id)) {
                                assignItemToCraftingSlot(0, clone.id);
                            }
                        }
                    });
                    card.addEventListener('click', () => {
                        if (!assignItemToFirstAvailableSlot(clone.id)) {
                            assignItemToCraftingSlot(0, clone.id);
                        }
                    });
                    const iconClickHandler = (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        if (!assignItemToFirstAvailableSlot(clone.id)) {
                            assignItemToCraftingSlot(0, clone.id);
                        }
                    };
                    icon.addEventListener('click', iconClickHandler);
                    icon.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter' || event.key === ' ') {
                            iconClickHandler(event);
                        }
                    });
                }

                bindThingTooltip(card, clone);
                craftingInventoryGrid.appendChild(card);
            });
        }

        function renderCraftingSlots(slotCount) {
            if (!craftingSlotsContainer) {
                return;
            }
            craftingSlotsContainer.innerHTML = '';
            for (let index = 0; index < slotCount; index += 1) {
                const slot = document.createElement('div');
                slot.className = 'crafting-slot';
                slot.dataset.slotIndex = String(index);
                slot.addEventListener('dragover', handleCraftingSlotDragOver);
                slot.addEventListener('dragenter', handleCraftingSlotDragEnter);
                slot.addEventListener('dragleave', handleCraftingSlotDragLeave);
                slot.addEventListener('drop', handleCraftingSlotDrop);
                slot.addEventListener('dblclick', () => clearCraftingSlot(index));
                updateCraftingSlotElement(slot);
                craftingSlotsContainer.appendChild(slot);
            }
        }

        function updateCraftingSlotElement(slotElement) {
            if (!slotElement) {
                return;
            }
            const slotIndex = Number(slotElement.dataset.slotIndex);
            const assignedItem = craftingSlotAssignments.get(slotIndex) || null;
            slotElement.innerHTML = '';
            slotElement.classList.remove('crafting-slot--filled');
            slotElement.classList.remove('crafting-slot--hover');

            if (!assignedItem) {
                const placeholder = document.createElement('div');
                placeholder.className = 'crafting-slot__placeholder';
                placeholder.textContent = 'Empty Slot';
                slotElement.appendChild(placeholder);
                return;
            }

            slotElement.classList.add('crafting-slot--filled');
            const preview = document.createElement('div');
            preview.className = 'crafting-slot__item';

            const imageWrapper = document.createElement('div');
            imageWrapper.className = 'crafting-slot__item-image';
            renderEntityImage({
                element: imageWrapper,
                entityType: 'thing',
                entityId: assignedItem.id || '',
                imageId: assignedItem.imageId || null,
                altText: assignedItem.name || 'Item',
                placeholderIcon: assignedItem.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ',
                placeholderClass: 'crafting-slot__item-image-placeholder',
                enableLightbox: false,
                badges: getThingPropertyBadges(assignedItem)
            });

            const label = document.createElement('span');
            label.className = 'crafting-slot__item-name';
            label.textContent = assignedItem.name || 'Item';
            preview.appendChild(imageWrapper);
            preview.appendChild(label);
            slotElement.appendChild(preview);
            bindThingTooltip(preview, assignedItem);

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'crafting-slot__remove';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                clearCraftingSlot(slotIndex);
            });
            slotElement.appendChild(removeBtn);
        }

        function assignItemToCraftingSlot(slotIndex, thingId) {
            if (!craftingInventoryLookup.has(thingId)) {
                return;
            }
            if (isItemIdAssignedToAnySlot(thingId)) {
                return;
            }
            const sourceThing = craftingInventoryLookup.get(thingId);
            const clone = cloneThingRecord(sourceThing) || { ...sourceThing };
            craftingSlotAssignments.set(slotIndex, clone);
            markCraftingInventoryItemUsed(thingId, true);
            const slotElement = craftingSlotsContainer?.querySelector(`[data-slot-index="${slotIndex}"]`);
            if (slotElement) {
                updateCraftingSlotElement(slotElement);
            }
            updateCraftingActionState();
        }

        function clearCraftingSlot(slotIndex) {
            if (!craftingSlotAssignments.has(slotIndex)) {
                return;
            }
            const removed = craftingSlotAssignments.get(slotIndex);
            craftingSlotAssignments.delete(slotIndex);
            if (removed?.id) {
                markCraftingInventoryItemUsed(removed.id, false);
            }
            const slotElement = craftingSlotsContainer?.querySelector(`[data-slot-index="${slotIndex}"]`);
            if (slotElement) {
                updateCraftingSlotElement(slotElement);
            }
            updateCraftingActionState();
        }

        function assignItemToFirstAvailableSlot(thingId) {
            for (let index = 0; index < currentCraftingSlotCount; index += 1) {
                if (!craftingSlotAssignments.has(index)) {
                    assignItemToCraftingSlot(index, thingId);
                    return true;
                }
            }
            return false;
        }

        function isItemIdAssignedToAnySlot(thingId) {
            if (!thingId) {
                return false;
            }
            for (const entry of craftingSlotAssignments.values()) {
                if (entry?.id === thingId) {
                    return true;
                }
            }
            return false;
        }

        function markCraftingInventoryItemUsed(thingId, isUsed) {
            const card = craftingInventoryCardRefs.get(thingId);
            if (!card) {
                return;
            }
            if (isUsed) {
                card.classList.add('is-used');
                card.setAttribute('aria-disabled', 'true');
                card.draggable = false;
            } else {
                card.classList.remove('is-used');
                card.removeAttribute('aria-disabled');
                card.draggable = true;
            }
        }

        function updateCraftingActionState() {
            if (!craftingActionButton) {
                return;
            }
            const filledSlots = Array.from(craftingSlotAssignments.values()).filter(Boolean).length;
            craftingActionButton.disabled = filledSlots === 0;
        }

        function handleCraftingInventoryDragStart(event) {
            const target = event.currentTarget;
            const thingId = target?.dataset?.thingId;
            if (!thingId) {
                event.preventDefault();
                return;
            }
            target.classList.add('is-dragging');
            event.dataTransfer.setData('text/x-thing-id', thingId);
            event.dataTransfer.effectAllowed = 'copy';
        }

        function handleCraftingInventoryDragEnd(event) {
            event.currentTarget?.classList.remove('is-dragging');
        }

        function handleCraftingSlotDragOver(event) {
            event.preventDefault();
            if (event.dataTransfer) {
                event.dataTransfer.dropEffect = 'copy';
            }
        }

        function handleCraftingSlotDragEnter(event) {
            event.preventDefault();
            event.currentTarget?.classList.add('crafting-slot--hover');
        }

        function handleCraftingSlotDragLeave(event) {
            event.currentTarget?.classList.remove('crafting-slot--hover');
        }

        function handleCraftingSlotDrop(event) {
            event.preventDefault();
            const slotElement = event.currentTarget;
            slotElement?.classList.remove('crafting-slot--hover');
            const slotIndex = Number(slotElement?.dataset?.slotIndex);
            if (!Number.isFinite(slotIndex)) {
                return;
            }
            const thingId = event.dataTransfer?.getData('text/x-thing-id')
                || event.dataTransfer?.getData('text/plain')
                || '';
            if (!thingId) {
                return;
            }
            assignItemToCraftingSlot(slotIndex, thingId);
        }

        function buildCraftingPayload() {
            const slots = Array.from(craftingSlotAssignments.entries())
                .sort((a, b) => a[0] - b[0])
                .map(([slotIndex, item]) => ({
                    slotIndex,
                    thingId: item?.id || null,
                    name: item?.name || null
                }))
                .filter(entry => entry.thingId);

            return {
                mode: currentCraftingMode,
                notes: craftingNotesInput?.value?.trim() || '',
                craftTargetType: currentCraftingMode === 'craft' ? currentCraftingTargetType : null,
                stationThingId: craftingSourceThing?.id || null,
                stationName: craftingSourceThing ? craftingSourceThing.name : 'no workstation',
                slotCount: currentCraftingSlotCount,
                itemIds: slots.map(entry => entry.thingId),
                slots
            };
        }

        function buildCraftingRequestKey(payload) {
            if (!payload || !Array.isArray(payload.itemIds) || payload.itemIds.length === 0) {
                return '';
            }
            const mode = payload.mode || 'craft';
            const craftTargetType = payload.craftTargetType || '';
            const stationThingId = payload.stationThingId || '';
            const slotCount = Number.isFinite(payload.slotCount) ? payload.slotCount : 0;
            const notes = payload.notes || '';
            const itemIds = payload.itemIds.slice().sort();
            return JSON.stringify({ mode, craftTargetType, stationThingId, slotCount, notes, itemIds });
        }

        async function refreshCraftingRelatedViews() {
            const refreshTasks = [];
            const enqueueRefresh = (operation, label) => {
                if (typeof operation !== 'function') {
                    return;
                }
                try {
                    const value = operation();
                    if (value && typeof value.then === 'function') {
                        refreshTasks.push(value.catch(error => {
                            console.warn(`Crafting refresh (${label}) failed:`, error);
                        }));
                    }
                } catch (error) {
                    console.warn(`Crafting refresh (${label}) failed:`, error);
                }
            };

            enqueueRefresh(() => window.AIRPG_CHAT?.refreshChatHistory?.(), 'chat');
            enqueueRefresh(() => window.refreshInventory?.(), 'inventory');
            enqueueRefresh(() => window.refreshParty?.(), 'party');
            enqueueRefresh(() => window.loadCurrentLocation?.(), 'location');

            if (refreshTasks.length) {
                await Promise.allSettled(refreshTasks);
            }
        }

        async function submitCraftingRequest() {
            const payload = buildCraftingPayload();
            if (!payload.itemIds.length) {
                return;
            }

            const requestKey = buildCraftingRequestKey(payload);
            if (requestKey && craftingRequestsInFlight.has(requestKey)) {
                return;
            }
            if (requestKey) {
                craftingRequestsInFlight.add(requestKey);
            }
            closeCraftingModal();

            try {
                const response = await fetch('/api/craft', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json().catch(() => ({}));
                if (!response.ok || !result?.success) {
                    const errorMessage = result?.error || `Crafting failed (HTTP ${response.status})`;
                    throw new Error(errorMessage);
                }
                await refreshCraftingRelatedViews();
            } catch (error) {
                console.warn('Crafting request failed:', error);
                alert(`Crafting failed: ${error?.message || 'Unknown error'}`);
            } finally {
                if (requestKey) {
                    craftingRequestsInFlight.delete(requestKey);
                }
            }
        }

        function buildSalvageRequestKey({ thingId, mode }) {
            if (!thingId || typeof thingId !== 'string') {
                return '';
            }
            const normalizedMode = mode === 'harvest' ? 'harvest' : 'salvage';
            return `${normalizedMode}:${thingId}`;
        }

        async function submitSalvageRequest({ thingId, thing = null, mode = 'salvage', notes = '' } = {}) {
            const normalizedMode = mode === 'harvest' ? 'harvest' : 'salvage';
            const isHarvestMode = normalizedMode === 'harvest';
            if (!thingId) {
                alert(`Unable to ${isHarvestMode ? 'harvest' : 'salvage'} without a valid item.`);
                return;
            }
            const requestKey = buildSalvageRequestKey({ thingId, mode: normalizedMode });
            if (requestKey && salvageRequestsInFlight.has(requestKey)) {
                return;
            }
            if (requestKey) {
                salvageRequestsInFlight.add(requestKey);
            }
            try {
                const actionLabel = isHarvestMode ? 'Harvest' : 'Salvage';
                const payloadMode = normalizedMode;
                const payload = {
                    mode: payloadMode,
                    actionType: payloadMode,
                    slotCount: 1,
                    notes: notes || '',
                    itemIds: [thingId],
                    slots: [{
                        slotIndex: 0,
                        thingId,
                        name: thing?.name || null
                    }],
                    stationThingId: null,
                    stationName: isHarvestMode ? 'Harvest Interface' : 'Salvage Interface'
                };
                if (isHarvestMode) {
                    payload.harvestItemId = thingId;
                    payload.harvestItemName = thing?.name || null;
                    payload.harvestItemDescription = thing?.description || null;
                    payload.harvestNotes = notes || '';
                } else {
                    payload.salvageItemId = thingId;
                    payload.salvageItemName = thing?.name || null;
                    payload.salvageItemDescription = thing?.description || null;
                    payload.salvageNotes = notes || '';
                }

                const response = await fetch('/api/craft', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json().catch(() => ({}));
                if (!response.ok || !result?.success) {
                    const errorMessage = result?.error || `${actionLabel} failed (HTTP ${response.status})`;
                    throw new Error(errorMessage);
                }
                await refreshCraftingRelatedViews();
            } catch (error) {
                console.warn('Salvage request failed:', error);
                alert(`${mode === 'harvest' ? 'Harvest' : 'Salvage'} failed: ${error?.message || 'Unknown error'}`);
            } finally {
                if (requestKey) {
                    salvageRequestsInFlight.delete(requestKey);
                }
            }
        }

        function formatTagValue(label, value) {
            if (value === undefined || value === null || value === '') {
                return '';
            }
            return `${label}: ${value}`;
        }

        function renderDefinitionList(container, emptyState, entries = []) {
            if (!container) {
                return;
            }
            container.innerHTML = '';
            if (!Array.isArray(entries) || entries.length === 0) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }
            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }
            entries.forEach(({ term, detail, modifierDetail }) => {
                const dt = document.createElement('dt');
                dt.textContent = term;
                const dd = document.createElement('dd');
                if (modifierDetail) {
                    dd.classList.add('npc-view-attribute-entry');
                    const baseSpan = document.createElement('span');
                    baseSpan.className = 'npc-view-attr-base';
                    baseSpan.textContent = detail;
                    dd.appendChild(baseSpan);
                    if (modifierDetail.text) {
                        const modSpan = document.createElement('span');
                        modSpan.textContent = modifierDetail.text;
                        modSpan.className = modifierDetail.className;
                        dd.appendChild(modSpan);
                    }
                } else {
                    dd.textContent = detail;
                }
                container.appendChild(dt);
                container.appendChild(dd);
            });
        }

        function renderEquipmentList(container, emptyState, entries = []) {
            if (!container) {
                return;
            }

            container.innerHTML = '';
            const safeEntries = Array.isArray(entries) ? entries.filter(Boolean) : [];

            if (!safeEntries.length) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }

            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }

            safeEntries.forEach(entry => {
                const row = document.createElement('div');
                row.className = 'npc-view-equipment-row';

                const slotContainer = document.createElement('div');
                slotContainer.className = 'npc-view-equipment-slot';
                const slotName = document.createElement('div');
                slotName.className = 'npc-view-equipment-slot-name';
                slotName.textContent = entry.slotLabel || 'Slot';
                slotContainer.appendChild(slotName);

                if (entry.slotTypeLabel && entry.slotTypeLabel !== entry.slotLabel) {
                    const slotType = document.createElement('div');
                    slotType.className = 'npc-view-equipment-slot-type';
                    slotType.textContent = entry.slotTypeLabel;
                    slotContainer.appendChild(slotType);
                }

                const itemContainer = document.createElement('div');
                itemContainer.className = 'npc-view-equipment-item';

                if (entry.item && typeof entry.item === 'object') {
                    const card = document.createElement('div');
                    card.className = 'npc-view-equipment-item-card';

                    const icon = document.createElement('div');
                    icon.className = 'npc-view-equipment-icon';
                    const placeholderIcon = entry.item.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ';
                    renderEntityImage({
                        element: icon,
                        entityType: 'thing',
                        entityId: entry.item.id || null,
                        imageId: entry.item.imageId || null,
                        altText: entry.item.name || 'Equipped item',
                        placeholderIcon,
                        placeholderClass: 'npc-view-equipment-icon-placeholder',
                        badges: getThingPropertyBadges(entry.item)
                    });

                    const textWrapper = document.createElement('div');
                    textWrapper.className = 'npc-view-equipment-text';
                    const name = document.createElement('div');
                    name.className = 'npc-view-equipment-name';
                    name.textContent = entry.item.name || 'Unknown Item';
                    applyRarityClass(name, entry.item.rarity);
                    textWrapper.appendChild(name);

                    card.appendChild(icon);
                    card.appendChild(textWrapper);

                    if (entry.item && entry.item.id) {
                        registerThingContextMenu(card, entry.item, { context: 'npc-equipment', npcId: currentNpcViewId });
                    }

                    bindThingTooltip(card, entry.item);
                    itemContainer.appendChild(card);
                } else {
                    const empty = document.createElement('span');
                    empty.className = 'npc-view-equipment-empty';
                    empty.textContent = 'Empty';
                    itemContainer.appendChild(empty);
                }

                row.appendChild(slotContainer);
                row.appendChild(itemContainer);
                container.appendChild(row);
            });
        }

        function renderList(container, emptyState, items = [], options = {}) {
            if (!container) {
                return;
            }
            container.innerHTML = '';
            const safeItems = Array.isArray(items) ? items.filter(Boolean) : [];
            if (safeItems.length === 0) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }
            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }

            const { allowHTML = false } = options;
            safeItems.forEach(item => {
                const li = document.createElement('li');
                if (allowHTML) {
                    li.innerHTML = item;
                } else {
                    li.textContent = item;
                }
                container.appendChild(li);
            });
        }

        async function showNpcViewModal(npc) {
            if (!npc || !npcViewModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            let latestNpc = npc && npc.id ? (npcDataCache.get(npc.id) || npc) : npc;
            if ((!latestNpc?.attributeInfo || typeof latestNpc.attributeInfo !== 'object') && latestNpc?.id) {
                try {
                    const response = await fetch(`/api/npcs/${encodeURIComponent(latestNpc.id)}`, { cache: 'no-store' });
                    const result = await response.json();
                    if (result?.success && result.npc) {
                        latestNpc = result.npc;
                        if (npcDataCache && latestNpc.id) {
                            npcDataCache.set(latestNpc.id, cloneActorRecord(latestNpc) || { ...latestNpc });
                        }
                    }
                } catch (error) {
                    console.warn('Failed to fetch detailed NPC status for view:', error?.message || error);
                }
            }
            currentNpcViewId = latestNpc?.id || npc?.id || null;

            npcModalBackdrop.removeAttribute('hidden');
            npcViewModal.removeAttribute('hidden');
            npcViewModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            scrollModalToTop(npcViewModal);

            const name = latestNpc?.name || 'Unknown Character';
            const description = latestNpc?.description || latestNpc?.shortDescription || 'No description available.';
            const resolveTagValue = (...values) => {
                for (const value of values) {
                    if (value === undefined || value === null) {
                        continue;
                    }
                    if (typeof value === 'string') {
                        const trimmed = value.trim();
                        if (trimmed) {
                            return trimmed;
                        }
                    } else if (value !== '') {
                        return value;
                    }
                }
                return null;
            };
            const classLabel = resolveTagValue(latestNpc?.class, latestNpc?.className, latestNpc?.classLabel) || 'Unknown';
            const raceLabel = resolveTagValue(latestNpc?.race, latestNpc?.species, latestNpc?.raceName) || 'Unknown';
            const levelValue = Number.isFinite(Number(latestNpc?.level)) ? Number(latestNpc.level) : null;
            const healthValue = Number.isFinite(Number(latestNpc?.health)) ? Number(latestNpc.health) : null;
            const maxHealthValue = Number.isFinite(Number(latestNpc?.maxHealth)) ? Number(latestNpc.maxHealth) : null;
            const parseNonNegativeInt = (value) => {
                const parsed = Number.parseInt(value, 10);
                return Number.isFinite(parsed) && parsed >= 0 ? parsed : null;
            };

            if (npcViewModalTitle) {
                npcViewModalTitle.textContent = latestNpc?.name ? `${latestNpc.name} ¬∑ Overview` : 'Character Overview';
            }

            if (npcViewName) {
                npcViewName.textContent = name;
            }
            if (npcViewDescription) {
                npcViewDescription.textContent = description;
            }

            const updateTag = (element, label, value) => {
                if (!element) {
                    return;
                }
                if (value === undefined || value === null || value === '') {
                    element.textContent = '';
                    element.setAttribute('hidden', '');
                    return;
                }
                element.textContent = formatTagValue(label, value);
                element.removeAttribute('hidden');
            };

            updateTag(npcViewClass, 'Class', classLabel);
            updateTag(npcViewRace, 'Race', raceLabel);
            updateTag(npcViewLevel, 'Level', levelValue);

            if (npcViewHealth) {
                if (healthValue === null && maxHealthValue === null) {
                    npcViewHealth.textContent = '';
                    npcViewHealth.setAttribute('hidden', '');
                } else {
                    if (healthValue !== null && maxHealthValue !== null) {
                        npcViewHealth.textContent = `${healthValue}/${maxHealthValue}`;
                    } else if (healthValue !== null) {
                        npcViewHealth.textContent = `${healthValue}`;
                    } else {
                        npcViewHealth.textContent = `${maxHealthValue}`;
                    }
                    npcViewHealth.removeAttribute('hidden');
                }
            }

            if (npcViewCurrency) {
                const currencyValue = parseNonNegativeInt(latestNpc?.currency);
                if (currencyValue === null) {
                    npcViewCurrency.textContent = '';
                    npcViewCurrency.setAttribute('hidden', '');
                } else {
                    const currencyLabel = resolveCurrencyLabel();
                    npcViewCurrency.textContent = `Currency: ${currencyValue} ${currencyLabel}`;
                    npcViewCurrency.removeAttribute('hidden');
                }
            }

            if (npcViewExperience) {
                const experienceValue = parseNonNegativeInt(latestNpc?.experience);
                if (experienceValue === null) {
                    npcViewExperience.textContent = '';
                    npcViewExperience.setAttribute('hidden', '');
                } else {
                    npcViewExperience.textContent = `Experience: ${experienceValue}`;
                    npcViewExperience.removeAttribute('hidden');
                }
            }

            const dispositions = Array.isArray(latestNpc?.dispositionsTowardsPlayer)
                ? latestNpc.dispositionsTowardsPlayer.filter(entry => entry && entry.type)
                : [];
            if (npcViewDispositions && npcViewDispositionsList) {
                if (!dispositions.length) {
                    npcViewDispositions.setAttribute('hidden', '');
                    npcViewDispositions.removeAttribute('open');
                    npcViewDispositionsList.innerHTML = '';
                } else {
                    npcViewDispositions.removeAttribute('hidden');
                    npcViewDispositions.open = false;
                    npcViewDispositionsList.innerHTML = '';
                    dispositions.forEach(entry => {
                        const chip = document.createElement('span');
                        chip.className = 'npc-view-disposition-chip';
                        const numericValue = Number(entry.value);
                        const formattedValue = Number.isFinite(numericValue)
                            ? ` (${numericValue > 0 ? '+' : ''}${numericValue})`
                            : '';
                        chip.textContent = `${entry.type}: ${entry.intensityName || 'neutral'}${formattedValue}`;
                        npcViewDispositionsList.appendChild(chip);
                    });
                }
            }

            if (npcViewImage) {
                renderEntityImage({
                    element: npcViewImage,
                    entityType: latestNpc?.isNPC ? 'npc' : 'player',
                    entityId: latestNpc?.id || null,
                    imageId: latestNpc?.imageId || null,
                    altText: `${name} portrait`,
                    placeholderIcon: 'üé≠',
                    placeholderClass: 'npc-view-image-placeholder'
                });
            }

            const attributeEntries = [];
            if (latestNpc?.attributeInfo && typeof latestNpc.attributeInfo === 'object') {
                for (const [key, info] of Object.entries(latestNpc.attributeInfo)) {
                    const label = info?.label || formatAttributeName(key);
                    const baseValue = Number.isFinite(Number(info?.value)) ? Number(info.value) : info?.value;
                    const modValue = Number.isFinite(Number(info?.modifiedValue)) ? Number(info.modifiedValue) : baseValue;

                    const baseText = (baseValue !== undefined && baseValue !== null) ? `${baseValue}` : '‚Äî';
                    let modifierDetail = null;

                    const delta = (Number.isFinite(modValue) && Number.isFinite(baseValue))
                        ? modValue - baseValue
                        : 0;
                    const className = delta > 0
                        ? 'npc-view-attr-mod higher'
                        : (delta < 0 ? 'npc-view-attr-mod lower' : 'npc-view-attr-mod same');

                    const modText = `(${modValue !== undefined && modValue !== null ? modValue : baseValue ?? '‚Äî'})`;
                    modifierDetail = { text: modText, className };

                    attributeEntries.push({ term: label, detail: baseText, modifierDetail });
                }
            } else if (latestNpc?.attributes && typeof latestNpc.attributes === 'object') {
                for (const [key, value] of Object.entries(latestNpc.attributes)) {
                    const label = formatAttributeName(key);
                    const detail = Number.isFinite(Number(value)) ? Number(value) : (value ?? '‚Äî');
                    attributeEntries.push({ term: label, detail });
                }
            }
            attributeEntries.sort((a, b) => a.term.localeCompare(b.term));
            renderDefinitionList(npcViewAttributes, npcViewAttributesEmpty, attributeEntries);

            const inventoryItems = Array.isArray(latestNpc?.inventory) ? latestNpc.inventory : [];
            const inventoryMap = new Map();
            inventoryItems.forEach(item => {
                if (item && item.id) {
                    inventoryMap.set(item.id, item);
                }
            });

            const equipmentEntries = [];
            if (latestNpc?.gear && typeof latestNpc.gear === 'object') {
                for (const [slotName, slotData] of Object.entries(latestNpc.gear)) {
                    if (!slotName && !slotData?.slotType) {
                        continue;
                    }

                    const slotTypeLabel = slotData?.slotType ? formatSlotTypeLabel(slotData.slotType) : '';
                    const resolvedSlotName = typeof slotName === 'string' && slotName.trim()
                        ? slotName.trim()
                        : '';
                    const slotLabel = resolvedSlotName || (slotTypeLabel ? `${slotTypeLabel} Slot` : 'Slot');

                    let resolvedItem = null;
                    if (slotData && slotData.itemId) {
                        resolvedItem = inventoryMap.get(slotData.itemId) || null;
                    }
                    if (!resolvedItem && slotData && typeof slotData.item === 'object') {
                        resolvedItem = slotData.item;
                    }
                    if (!resolvedItem && slotData && (slotData.itemName || slotData.itemId)) {
                        resolvedItem = {
                            id: slotData.itemId || null,
                            name: slotData.itemName || slotData.itemId || 'Unknown Item',
                            rarity: slotData.itemRarity || null,
                            thingType: slotData.itemType || null
                        };
                    }

                    equipmentEntries.push({
                        slotLabel,
                        slotTypeLabel,
                        item: resolvedItem
                    });
                }
            }
            equipmentEntries.sort((a, b) => a.slotLabel.localeCompare(b.slotLabel));
            renderEquipmentList(npcViewEquipment, npcViewEquipmentEmpty, equipmentEntries);

            const skillData = [];
            if (latestNpc?.skills) {
                if (Array.isArray(latestNpc.skills)) {
                    latestNpc.skills.forEach(entry => {
                        if (!entry) return;
                        if (typeof entry === 'string') {
                            skillData.push({ name: entry, rank: null });
                        } else if (entry.name) {
                            const rankValue = Number.isFinite(Number(entry.rank)) ? Number(entry.rank) : null;
                            skillData.push({ name: entry.name, rank: rankValue });
                        }
                    });
                } else if (latestNpc.skills && typeof latestNpc.skills === 'object') {
                    for (const [skillName, rank] of Object.entries(latestNpc.skills)) {
                        const rankValue = Number.isFinite(Number(rank)) ? Number(rank) : null;
                        skillData.push({ name: skillName, rank: rankValue });
                    }
                }
            }
            skillData.sort((a, b) => a.name.localeCompare(b.name));
            if (npcViewSkills) {
                npcViewSkills.innerHTML = '';
                if (!skillData.length) {
                    npcViewSkills.setAttribute('hidden', '');
                    if (npcViewSkillsEmpty) {
                        npcViewSkillsEmpty.removeAttribute('hidden');
                    }
                } else {
                    if (npcViewSkillsEmpty) {
                        npcViewSkillsEmpty.setAttribute('hidden', '');
                    }
                    const table = document.createElement('table');
                    table.className = 'npc-view-skills-table';
                    const tbody = document.createElement('tbody');
                    table.appendChild(tbody);

                    skillData.forEach((entry, index) => {
                        const row = document.createElement('tr');
                        if ((index % 2) === 1) {
                            row.classList.add('is-alt');
                        }

                        const nameCell = document.createElement('td');
                        nameCell.className = 'npc-view-skill-name';
                        nameCell.textContent = entry.name || 'Unknown Skill';

                        const rankCell = document.createElement('td');
                        rankCell.className = 'npc-view-skill-rank';
                        if (entry.rank !== null && entry.rank !== undefined) {
                            const numericRank = Number(entry.rank);
                            rankCell.textContent = Number.isFinite(numericRank)
                                ? `${numericRank > 0 ? '+' : ''}${numericRank}`
                                : `${entry.rank}`;
                        } else {
                            rankCell.textContent = '‚Äî';
                        }

                        row.appendChild(nameCell);
                        row.appendChild(rankCell);
                        tbody.appendChild(row);
                    });

                    npcViewSkills.appendChild(table);
                    npcViewSkills.removeAttribute('hidden');
                }
            }

            const abilityEntries = [];
            if (Array.isArray(latestNpc?.abilities)) {
                latestNpc.abilities.forEach(ability => {
                    if (!ability) return;
                    const label = ability.name || 'Ability';
                    const typeLabel = ability.type ? String(ability.type) : '';
                    const numericLevel = Number.isFinite(Number(ability.level)) ? Number(ability.level) : null;
                    const metaParts = [];
                    if (typeLabel) {
                        metaParts.push(typeLabel);
                    }
                    if (numericLevel !== null) {
                        metaParts.push(`Level ${numericLevel}`);
                    }
                    const metaSuffix = metaParts.length ? ` (${metaParts.join(' ‚Ä¢ ')})` : '';
                    const descriptionText = ability.description || ability.text || '';
                    const entry = `<strong>${escapeHtml(label)}${escapeHtml(metaSuffix)}</strong>${descriptionText ? `<span class="npc-view-list-description">${escapeHtml(descriptionText)}</span>` : ''}`;
                    abilityEntries.push(entry);
                });
            }
            renderList(npcViewAbilities, npcViewAbilitiesEmpty, abilityEntries, { allowHTML: true });

            const statusEntries = [];
            if (Array.isArray(latestNpc?.statusEffects)) {
                latestNpc.statusEffects.forEach(effect => {
                    if (!effect) return;
                    const descriptionText = typeof effect === 'string'
                        ? effect
                        : (effect.description || effect.text || effect.name || '');
                    if (!descriptionText) {
                        return;
                    }
                    let durationText = '';
                    if (effect.source === 'equipped') {
                        durationText = ' (Continuous)';
                    } else if (Number.isFinite(Number(effect.duration))) {
                        durationText = ` (Duration ${Number(effect.duration)})`;
                    }

                    const rows = [];
                    const formatValue = (val) => {
                        const num = Number(val);
                        if (!Number.isFinite(num)) return null;
                        return num > 0 ? `+${num}` : `${num}`;
                    };

                    const addRows = (label, list, keyName) => {
                        if (!Array.isArray(list) || !list.length) return;
                        list.forEach(entry => {
                            if (!entry) return;
                            const name = entry[keyName] || entry.name;
                            const value = formatValue(entry.modifier ?? entry.delta ?? entry.value);
                            if (!name || value === null) return;
                            const valueClass = Number(value) >= 0 ? 'positive' : 'negative';
                            rows.push(`<tr><td>${escapeHtml(label)}</td><td class="npc-view-status-name">${escapeHtml(String(name))}</td><td class="npc-view-status-mod ${valueClass}">${escapeHtml(value)}</td></tr>`);
                        });
                    };

                    addRows('Attribute', effect.attributes, 'attribute');
                    addRows('Skill', effect.skills, 'skill');
                    addRows('Regen/Drain', effect.needBars, 'name');

                    const tableHtml = rows.length
                        ? `<table class="npc-view-status-table"><tbody>${rows.join('')}</tbody></table>`
                        : '';

                    const nameText = effect.name || null;
                    const headerText = nameText ? `<strong>${escapeHtml(nameText)}</strong> ‚Äì ${escapeHtml(descriptionText)}${escapeHtml(durationText)}` : `${escapeHtml(descriptionText)}${escapeHtml(durationText)}`;
                    const content = `
                        <div class="npc-view-status-entry">
                            <div class="npc-view-status-header">${headerText}</div>
                            ${tableHtml}
                        </div>
                    `;
                    statusEntries.push(content);
                });
            }
            renderList(npcViewStatuses, npcViewStatusesEmpty, statusEntries, { allowHTML: true });
        }

            document.addEventListener('keydown', (event) => {
                if (event.key !== 'Escape') {
                    return;
                }

                if (addNpcModal && !addNpcModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeAddNpcModal({ focusTrigger: true });
                    return;
                }

                if (newExitModal && !newExitModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNewExitModal();
                    return;
                }

                if (npcNeedsModal && !npcNeedsModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcNeedsModal();
                    return;
                }

                if (npcMemoriesModal && !npcMemoriesModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcMemoriesModal();
                    return;
                }

                if (npcGoalsModal && !npcGoalsModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcGoalsModal();
                    return;
                }

                if (npcDispositionModal && !npcDispositionModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcDispositionModal();
                    return;
                }

                if (thingEditModal && !thingEditModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeThingEditModal();
                    return;
                }

                if (npcViewModal && !npcViewModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcViewModal();
                    return;
                }

                if (npcInventoryModal && !npcInventoryModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcInventoryModal();
                    return;
                }

                if (npcEditModal && !npcEditModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeNpcEditModal();
                    return;
                }

                if (summonNpcModal && !summonNpcModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeSummonNpcModal();
                    return;
                }

                if (summonThingModal && !summonThingModal.hasAttribute('hidden')) {
                    event.preventDefault();
                    closeSummonThingModal();
                    return;
                }
        });

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');

            const hashPrefix = 'tab-';

            const activateTab = (tabName) => {
                if (!tabName) return;
                const targetButton = Array.from(tabButtons).find(btn => btn.dataset.tab === tabName);
                const targetPanel = document.getElementById(`tab-${tabName}`);
                if (!targetButton || !targetPanel) return;

                tabButtons.forEach(btn => {
                    const isActive = btn === targetButton;
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                });

                tabPanels.forEach(panel => {
                    const isActive = panel === targetPanel;
                    panel.toggleAttribute('hidden', !isActive);
                    panel.classList.toggle('active', isActive);
                });

                if (mapLocationMenuOpen) {
                    closeMapLocationContextMenu();
                }

                if (tabName === 'map') {
                    const pendingRegionId = window.__AIRPG_NEXT_REGION_MAP_ID || null;
                    if (pendingRegionId) {
                        window.__AIRPG_NEXT_REGION_MAP_ID = null;
                        window.loadRegionMap?.(pendingRegionId);
                    } else {
                        window.loadRegionMap?.();
                    }
                } else if (tabName === 'world-map') {
                    window.loadWorldMap?.();
                } else if (tabName === 'party') {
                    window.refreshParty?.();
                } else if (tabName === 'factions') {
                    window.refreshFactions?.();
                }
            };
            window.activateTab = activateTab;

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.dataset.tab;
                    if (!tabName) {
                        return;
                    }
                    if (button.classList.contains('active')) {
                        if (tabName === 'world-map') {
                            window.loadWorldMap?.();
                        }
                        return;
                    }
                    activateTab(tabName);
                    const newHash = `#${hashPrefix}${tabName}`;
                    if (window.location.hash !== newHash) {
                        window.location.hash = newHash;
                    }
                });
            });

            const applyHashTab = () => {
                const rawHash = window.location.hash ? window.location.hash.replace('#', '') : '';
                if (!rawHash) {
                    return;
                }

                if (rawHash.startsWith(hashPrefix)) {
                    const tabName = rawHash.substring(hashPrefix.length);
                    activateTab(tabName);
                } else {
                    activateTab(rawHash);
                }
            };

            applyHashTab();
            window.addEventListener('hashchange', applyHashTab);

            if (!window.location.hash) {
                const defaultButton = document.querySelector('.tab-button.active');
                const defaultTab = defaultButton ? defaultButton.dataset.tab : 'adventure';
                activateTab(defaultTab);
                window.location.hash = `#${hashPrefix}${defaultTab}`;
            }
        }

        function initLocationDisplay() {
            // Function to update location display
        function resolveDestinationNameStrict(exit) {
            if (!exit) {
                throw new Error('resolveDestinationNameStrict requires an exit object.');
            }

            const direct = typeof exit.destinationName === 'string' ? exit.destinationName.trim() : '';
            if (direct) {
                return direct;
            }

            const cached = exit.destination && typeof locationCache[exit.destination] === 'string'
                ? locationCache[exit.destination].trim()
                : '';
            if (cached) {
                return cached;
            }

            console.log('Attempting to resolve destination name for exit:', exit);
            throw new Error(`Exit ${exit.id || exit.destination || '<unknown>'} is missing a destination name.`);
        }

        async function ensureLocationNameCached(destinationId) {
            if (!destinationId) {
                return null;
            }
            const cached = typeof locationCache[destinationId] === 'string'
                ? locationCache[destinationId].trim()
                : '';
            if (cached) {
                return { name: cached, regionName: null };
            }
            try {
                const response = await fetch(`/api/locations/${encodeURIComponent(destinationId)}?expandStubs=false`, { cache: 'no-store' });
                const data = await response.json().catch(() => ({}));
                if (response.ok && data?.location) {
                    const resolvedName = typeof data.location.name === 'string' && data.location.name.trim()
                        ? data.location.name.trim()
                        : (typeof data.location.shortDescription === 'string' && data.location.shortDescription.trim()
                            ? data.location.shortDescription.trim()
                            : '');

                    const resolvedRegionName = (() => {
                        if (typeof data.location.regionName === 'string' && data.location.regionName.trim()) {
                            return data.location.regionName.trim();
                        }
                        if (data.location.region && typeof data.location.region.name === 'string' && data.location.region.name.trim()) {
                            return data.location.region.name.trim();
                        }
                        if (data.location.stubMetadata && typeof data.location.stubMetadata.regionName === 'string' && data.location.stubMetadata.regionName.trim()) {
                            return data.location.stubMetadata.regionName.trim();
                        }
                        if (Array.isArray(data.location.regionPath) && data.location.regionPath.length) {
                            const lastRegion = data.location.regionPath[data.location.regionPath.length - 1];
                            if (lastRegion && typeof lastRegion.name === 'string' && lastRegion.name.trim()) {
                                return lastRegion.name.trim();
                            }
                        }
                        return null;
                    })();

                    if (resolvedName) {
                        locationCache[destinationId] = resolvedName;
                    }
                    if (resolvedName || resolvedRegionName) {
                        return { name: resolvedName || null, regionName: resolvedRegionName || null };
                    }
                }
            } catch (error) {
                console.warn(`Failed to fetch location ${destinationId}:`, error);
            }
            return null;
        }
        const MOVE_PLAUSIBILITY_POLICY = (window.CHECK_MOVE_PLAUSIBILITY || 'never').toLowerCase();

        function isUnexploredRegionExit(exit) {
            return Boolean(exit?.destinationRegion && !exit.destinationRegionExpanded);
        }

        function isUnexploredLocationExit(exit) {
            if (!exit) {
                return false;
            }
            if (isUnexploredRegionExit(exit)) {
                return true;
            }
            return Boolean(exit.destinationIsRegionEntryStub || exit.destinationIsStub);
        }

        function shouldUseEventMove(exit) {
            switch (MOVE_PLAUSIBILITY_POLICY) {
                case 'always':
                    return true;
                case 'never':
                    return false;
                case 'unexplored_locations':
                    return isUnexploredLocationExit(exit);
                case 'unexplored_regions':
                    return isUnexploredRegionExit(exit);
                default:
                    return false;
            }
        }
            const locationOverlay = document.getElementById('locationOverlay');
            const locationOverlayText = document.getElementById('locationOverlayText');
            const locationNPCs = document.getElementById('locationNPCs');
            const locationScenery = document.getElementById('locationScenery');
            const locationItems = document.getElementById('locationItems');
            const npcDataCache = new Map();
            window.currentNpcData = npcDataCache;
            const npcMenuState = { openMenu: null, trigger: null, card: null };

            if (locationNPCs) {
                registerPartyDropTarget(locationNPCs, 'dismiss');
            }

            function closeNpcContextMenu() {
                if (npcMenuState.openMenu) {
                    npcMenuState.openMenu.classList.remove('is-open');
                }
                if (npcMenuState.trigger) {
                    npcMenuState.trigger.setAttribute('aria-expanded', 'false');
                }
                if (npcMenuState.card) {
                    npcMenuState.card.classList.remove('context-menu-open');
                }
                npcMenuState.openMenu = null;
                npcMenuState.trigger = null;
                npcMenuState.card = null;
                closeThingContextMenu();
            }

            function registerNpcContextMenu(card, npc) {
                if (!card || !npc || !npc.id) {
                    return;
                }

                const npcIdString = String(npc.id);
                if (card.dataset.npcMenuAttached === 'true' && card.dataset.npcId === npcIdString) {
                    return;
                }

                card.dataset.npcId = npcIdString;
                card.dataset.npcMenuAttached = 'true';

                const existingButton = card.querySelector('.npc-card-menu-button');
                const existingMenu = card.querySelector('.npc-card-menu');
                existingButton?.remove();
                existingMenu?.remove();

                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'npc-card-menu-button';
                button.setAttribute('aria-haspopup', 'true');
                button.setAttribute('aria-expanded', 'false');
                button.setAttribute('aria-label', `More actions for ${npc.name || 'NPC'}`);

                const icon = document.createElement('span');
                icon.setAttribute('aria-hidden', 'true');
                icon.textContent = '‚Ä¢‚Ä¢‚Ä¢';
                button.appendChild(icon);

                const menu = document.createElement('div');
                menu.className = 'npc-card-menu';

                const viewButton = document.createElement('button');
                viewButton.type = 'button';
                viewButton.className = 'npc-card-menu-item';
                viewButton.textContent = 'View';
                menu.appendChild(viewButton);

                let regenerateImageButton = null;
                const canRegeneratePortrait = npc && npc.imageId;
                if (canRegeneratePortrait) {
                    regenerateImageButton = document.createElement('button');
                    regenerateImageButton.type = 'button';
                    regenerateImageButton.className = 'npc-card-menu-item';
                    regenerateImageButton.textContent = 'Regenerate Image';
                    menu.appendChild(regenerateImageButton);
                }

                const editButton = document.createElement('button');
                editButton.type = 'button';
                editButton.className = 'npc-card-menu-item';
                editButton.textContent = 'Edit';
                menu.appendChild(editButton);

                const inventoryButton = document.createElement('button');
                inventoryButton.type = 'button';
                inventoryButton.className = 'npc-card-menu-item';
                inventoryButton.textContent = 'Inventory';
                menu.appendChild(inventoryButton);

                const needsButton = document.createElement('button');
                needsButton.type = 'button';
                needsButton.className = 'npc-card-menu-item';
                needsButton.textContent = 'Needs';
                menu.appendChild(needsButton);

                let teleportButton = null;
                let memoriesButton = null;
                let goalsButton = null;
                let recruitButton = null;
                let dismissButton = null;
                let dispositionButton = null;
                let killButton = null;
                let deleteButton = null;
                if (npc && npc.isPlayer) {
                    teleportButton = document.createElement('button');
                    teleportButton.type = 'button';
                    teleportButton.className = 'npc-card-menu-item';
                    teleportButton.textContent = 'Teleport';
                    menu.appendChild(teleportButton);
                } else if (npc && npc.isNPC) {
                    teleportButton = document.createElement('button');
                    teleportButton.type = 'button';
                    teleportButton.className = 'npc-card-menu-item';
                    teleportButton.textContent = 'Teleport';
                    menu.appendChild(teleportButton);

                    memoriesButton = document.createElement('button');
                    memoriesButton.type = 'button';
                    memoriesButton.className = 'npc-card-menu-item';
                    memoriesButton.textContent = 'Memories';
                    menu.appendChild(memoriesButton);

                    goalsButton = document.createElement('button');
                    goalsButton.type = 'button';
                    goalsButton.className = 'npc-card-menu-item';
                    goalsButton.textContent = 'Goals';
                    menu.appendChild(goalsButton);

                    const isInParty = Boolean(npc.isInPlayerParty);
                    if (isInParty) {
                        dismissButton = document.createElement('button');
                        dismissButton.type = 'button';
                        dismissButton.className = 'npc-card-menu-item';
                        dismissButton.textContent = 'Dismiss';
                        menu.appendChild(dismissButton);
                    } else {
                        recruitButton = document.createElement('button');
                        recruitButton.type = 'button';
                        recruitButton.className = 'npc-card-menu-item';
                        recruitButton.textContent = 'Force Recruit';
                        menu.appendChild(recruitButton);
                    }

                    dispositionButton = document.createElement('button');
                    dispositionButton.type = 'button';
                    dispositionButton.className = 'npc-card-menu-item';
                    dispositionButton.textContent = 'Dispositions';
                    menu.appendChild(dispositionButton);

                    killButton = document.createElement('button');
                    killButton.type = 'button';
                    killButton.className = 'npc-card-menu-item npc-card-menu-item--danger';
                    killButton.textContent = 'Kill';
                    menu.appendChild(killButton);

                    deleteButton = document.createElement('button');
                    deleteButton.type = 'button';
                    deleteButton.className = 'npc-card-menu-item npc-card-menu-item--danger';
                    deleteButton.textContent = 'Delete';
                    menu.appendChild(deleteButton);
                }

                button.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const wasOpen = npcMenuState.openMenu === menu;
                    closeNpcContextMenu();
                    if (!wasOpen) {
                        menu.classList.add('is-open');
                        button.setAttribute('aria-expanded', 'true');
                        npcMenuState.openMenu = menu;
                        npcMenuState.trigger = button;
                        npcMenuState.card = card;
                        card.classList.add('context-menu-open');
                    }
                });

                viewButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcViewModal(latestNpc);
                });

                editButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcEditModal(latestNpc);
                });

                if (regenerateImageButton) {
                    regenerateImageButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = { ...(npcDataCache.get(npc.id) || npc) };
                        const npcId = String(latestNpc?.id || '');
                        if (!npcId) {
                            console.warn('Unable to regenerate portrait: NPC identifier missing.');
                            return;
                        }

                        const entityType = latestNpc.isNPC ? 'npc' : 'player';
                        const previousImageId = latestNpc.imageId || null;
                        const placeholderAlt = latestNpc.name || 'Character portrait';

                        applyEntityImagePlaceholder(entityType, npcId);

                        const baseNpcRecord = {
                            ...latestNpc,
                            imageId: null,
                            pendingImageJobId: null
                        };
                        npcDataCache.set(npc.id, baseNpcRecord);
                        if (!latestNpc.isNPC) {
                            window.currentPlayerData = {
                                ...(window.currentPlayerData || {}),
                                imageId: null
                            };
                        }

                        const clientId = window.AIRPG_CLIENT_ID || null;
                        const requestBody = clientId ? { clientId } : {};

                        try {
                            const response = await fetch(`/api/npcs/${encodeURIComponent(npcId)}/portrait`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(requestBody)
                            });
                            const data = await response.json().catch(() => ({}));

                            if (!response.ok) {
                                throw new Error(data?.error || `HTTP ${response.status}`);
                            }

                            if (data?.skipped) {
                                npcDataCache.set(npc.id, { ...latestNpc });
                                if (!latestNpc.isNPC) {
                                    window.currentPlayerData = {
                                        ...(window.currentPlayerData || {}),
                                        imageId: previousImageId || null
                                    };
                                }
                                renderEntityImages(entityType, npcId, {
                                    imageId: previousImageId,
                                    force: false,
                                    altText: placeholderAlt
                                });
                                return;
                            }

                            if (!data?.success && !data?.existingJob) {
                                throw new Error(data?.error || 'Portrait request was not accepted');
                            }

                            const pendingJobId = data?.imageGeneration?.jobId || data?.jobId || null;
                            npcDataCache.set(npc.id, {
                                ...baseNpcRecord,
                                pendingImageJobId: pendingJobId
                            });

                            renderEntityImages(entityType, npcId, {
                                imageId: null,
                                force: true,
                                altText: placeholderAlt
                            });
                        } catch (error) {
                            console.warn('Failed to regenerate NPC portrait:', error);
                            npcDataCache.set(npc.id, { ...latestNpc });
                            if (!latestNpc.isNPC) {
                                window.currentPlayerData = {
                                    ...(window.currentPlayerData || {}),
                                    imageId: previousImageId || null
                                };
                            }
                            renderEntityImages(entityType, npcId, {
                                imageId: previousImageId,
                                force: false,
                                altText: placeholderAlt
                            });
                        }
                    });
                }

                inventoryButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcInventoryModal(latestNpc);
                });

                needsButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    const type = npc.isNPC ? 'npc' : 'player';
                    try {
                        await showNpcNeedsModal(latestNpc, { type });
                    } catch (error) {
                        console.warn('Failed to open needs editor:', error);
                    }
                });

                if (teleportButton) {
                    teleportButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        try {
                            const latestNpc = npcDataCache.get(npc.id) || npc;
                            await showTeleportLocationModal(null, {
                                npcId: latestNpc.id,
                                npc: latestNpc,
                                card,
                                locationId: window.lastRenderedLocation?.id || null
                            });
                        } catch (error) {
                            console.warn('Failed to open teleport modal:', error);
                            alert(`Unable to teleport character: ${error?.message || error}`);
                        }
                    });
                }

                if (memoriesButton) {
                    memoriesButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = npcDataCache.get(npc.id) || npc;
                        showNpcMemoriesModal(latestNpc);
                    });
                }

                if (goalsButton) {
                    goalsButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = npcDataCache.get(npc.id) || npc;
                        showNpcGoalsModal(latestNpc);
                    });
                }

                if (recruitButton) {
                    recruitButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        try {
                            await forceRecruitNpc(npc, { card });
                        } catch (error) {
                            console.warn('Failed to recruit NPC:', error);
                            alert(`Failed to recruit NPC: ${error?.message || 'Unknown error'}`);
                        }
                    });
                }

                if (dismissButton) {
                    dismissButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const npcDataCache = window.currentNpcData instanceof Map ? window.currentNpcData : null;
                        const latestNpc = npcDataCache?.get(npc.id) || npc;
                        try {
                            await dismissNpcFromParty(latestNpc, { card });
                        } catch (error) {
                            console.warn('Failed to dismiss NPC from party:', error);
                            alert(`Failed to dismiss NPC: ${error?.message || 'Unknown error'}`);
                        }
                    });
                }

                if (dispositionButton) {
                    dispositionButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();
                        const latestNpc = npcDataCache.get(npc.id) || npc;
                        await showNpcDispositionModal(latestNpc);
                    });
                }

                if (killButton) {
                    killButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();

                        const cachedNpc = npcDataCache.get(npc.id) || npc;
                        const npcName = cachedNpc?.name || 'this NPC';
                        const confirmation = window.confirm(`Kill ${npcName}? This will set their health to zero and mark them as dead.`);
                        if (!confirmation) {
                            return;
                        }

                        showLocationOverlay('Killing character...');
                        try {
                            const response = await fetch(`/api/npcs/${encodeURIComponent(npc.id)}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ health: 0, isDead: true })
                            });
                            const result = await response.json().catch(() => ({}));
                            if (!response.ok || !result?.success) {
                                throw new Error(result?.error || `HTTP ${response.status}`);
                            }

                            const updatedNpc = result?.npc || { ...(cachedNpc || {}), health: 0, isDead: true };
                            npcDataCache.set(npc.id, updatedNpc);
                            card?.classList.add('is-dead');

                            window.refreshParty?.();
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } catch (error) {
                            console.warn('Failed to kill NPC:', error);
                            alert(`Failed to kill NPC: ${error?.message || 'Unknown error'}`);
                        } finally {
                            hideLocationOverlay();
                        }
                    });
                }

                if (deleteButton) {
                    deleteButton.addEventListener('click', async (event) => {
                        event.stopPropagation();
                        closeNpcContextMenu();

                        const cachedNpc = npcDataCache.get(npc.id) || npc;
                        const npcName = cachedNpc?.name || 'this NPC';
                        const confirmation = window.confirm(`Delete ${npcName}? This cannot be undone.`);
                        if (!confirmation) {
                            return;
                        }

                        const fallbackLocationId = cachedNpc?.locationId || cachedNpc?.currentLocation || npc.currentLocation || lastRenderedLocation?.id || null;

                        showLocationOverlay('Removing character...');
                        try {
                            const response = await fetch(`/api/npcs/${encodeURIComponent(npc.id)}`, {
                                method: 'DELETE'
                            });
                            const result = await response.json().catch(() => ({}));
                            if (!response.ok || !result?.success) {
                                throw new Error(result?.error || `HTTP ${response.status}`);
                            }

                            npcDataCache.delete(npc.id);

                            const targetLocationId = result?.locationId || fallbackLocationId;
                            let refreshed = false;

                            if (targetLocationId) {
                                try {
                                    const refreshedResp = await fetch(`/api/locations/${encodeURIComponent(targetLocationId)}`);
                                    const refreshedData = await refreshedResp.json().catch(() => ({}));
                                    if (refreshedResp.ok && refreshedData?.success && refreshedData.location) {
                                        await window.updateLocationDisplay(refreshedData.location);
                                        refreshed = true;
                                    }
                                } catch (refreshError) {
                                    console.warn('Failed to refresh location after NPC deletion:', refreshError);
                                }
                            }

                            if (!refreshed && lastRenderedLocation) {
                                if (Array.isArray(lastRenderedLocation.npcs)) {
                                    lastRenderedLocation.npcs = lastRenderedLocation.npcs.filter(entry => entry.id !== npc.id);
                                }
                                if (Array.isArray(lastRenderedLocation.npcIds)) {
                                    lastRenderedLocation.npcIds = lastRenderedLocation.npcIds.filter(id => id !== npc.id);
                                }
                                await window.updateLocationDisplay(lastRenderedLocation);
                            } else if (!refreshed && card && card.parentElement) {
                                card.remove();
                            }

                            window.refreshParty?.();
                        } catch (error) {
                            console.warn('Failed to delete NPC:', error);
                            alert(`Failed to delete NPC: ${error?.message || 'Unknown error'}`);
                        } finally {
                            hideLocationOverlay();
                        }
                    });
                }

                menu.addEventListener('click', (event) => event.stopPropagation());
                card.addEventListener('click', () => {
                    if (npcMenuState.openMenu) {
                        closeNpcContextMenu();
                    }
                });

                card.appendChild(button);
                card.appendChild(menu);
            }

            window.registerNpcContextMenu = registerNpcContextMenu;

            document.addEventListener('click', () => {
                if (npcMenuState.openMenu) {
                    closeNpcContextMenu();
                }
            });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeNpcContextMenu();
                }
            });

            function showLocationOverlay(message = 'Loading location...') {
                try {
                    window.floatingTooltipController?.hide?.();
                } catch (_) {
                    // Tooltip controller may not be initialized yet.
                }
                if (locationOverlay) {
                    locationOverlay.classList.add('show');
                    locationOverlay.setAttribute('aria-busy', 'true');
                    if (locationOverlayText && message) {
                        locationOverlayText.textContent = message;
                    }
                }
            }

            function hideLocationOverlay() {
                if (locationOverlay) {
                    locationOverlay.classList.remove('show');
                    locationOverlay.setAttribute('aria-busy', 'false');
                }
            }

            if (typeof window !== 'undefined') {
                window.showLocationOverlay = showLocationOverlay;
                window.hideLocationOverlay = hideLocationOverlay;
            }

        function setLocationEditStatus(message = '', type = null) {
            if (!locationEditStatus) {
                return;
            }
            locationEditStatus.textContent = message || '';
            locationEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                locationEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                locationEditStatus.classList.add('is-success');
            }
        }

        const UNKNOWN_LEVEL_DISPLAY = '‚Äî';

        function updateLocationAbsoluteLevelDisplay(value) {
            if (!locationEditAbsoluteLevel) {
                return;
            }
            if (Number.isFinite(value)) {
                const normalized = Math.max(1, Math.round(value));
                locationEditAbsoluteLevel.textContent = String(normalized);
            } else {
                locationEditAbsoluteLevel.textContent = UNKNOWN_LEVEL_DISPLAY;
            }
        }

        function createLocationStatusEffectRow(effect = {}) {
            if (!locationStatusEffectsList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-status-row';

            const descriptionInput = document.createElement('textarea');
            descriptionInput.className = 'thing-edit-status-description';
            descriptionInput.rows = 2;
            descriptionInput.placeholder = 'Description';
            descriptionInput.value = effect.description || effect.text || effect.name || '';

            const durationInput = document.createElement('input');
            durationInput.type = 'text';
            durationInput.className = 'thing-edit-status-duration';
            durationInput.placeholder = 'Duration';
            if (effect.duration !== undefined && effect.duration !== null && effect.duration !== '') {
                durationInput.value = String(effect.duration);
            }

            const modifiersContainer = document.createElement('div');
            modifiersContainer.className = 'thing-modifier-list';
            const addModifierBtn = document.createElement('button');
            addModifierBtn.type = 'button';
            addModifierBtn.className = 'npc-edit-add-btn';
            addModifierBtn.textContent = 'Add Modifier';
            addModifierBtn.addEventListener('click', () => {
                modifiersContainer.appendChild(thingModifierTemplates.createRow(null));
            });

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(descriptionInput);
            row.appendChild(durationInput);
            row.appendChild(modifiersContainer);
            row.appendChild(addModifierBtn);
            row.appendChild(removeBtn);

            locationStatusEffectsList.appendChild(row);

            const existingModifiers = [
                ...(Array.isArray(effect.attributes) ? effect.attributes.map(entry => ({ attribute: entry.attribute || entry.name, modifier: entry.modifier })) : []),
                ...(Array.isArray(effect.skills) ? effect.skills.map(entry => ({ skill: entry.skill || entry.name, modifier: entry.modifier })) : [])
            ];
            thingModifierTemplates.renderList(modifiersContainer, existingModifiers);

            return row;
        }

        function renderLocationStatusEffects(effects = []) {
            if (!locationStatusEffectsList) {
                return;
            }
            locationStatusEffectsList.innerHTML = '';
            const entries = Array.isArray(effects) ? effects : [];
            if (!entries.length) {
                createLocationStatusEffectRow({});
                return;
            }
            entries.forEach(effect => createLocationStatusEffectRow(effect));
        }

        function collectLocationStatusEffects() {
            if (!locationStatusEffectsList) {
                return [];
            }
            const effects = [];
            locationStatusEffectsList.querySelectorAll('.thing-edit-status-row').forEach(row => {
                const description = row.querySelector('.thing-edit-status-description')?.value?.trim();
                if (!description) {
                    return;
                }
                const durationRaw = row.querySelector('.thing-edit-status-duration')?.value?.trim();
                const effect = { description };
                if (durationRaw) {
                    const numeric = Number.parseInt(durationRaw, 10);
                    effect.duration = Number.isFinite(numeric) ? numeric : durationRaw;
                }
                const modifierContainer = row.querySelector('.thing-modifier-list');
                const modifiers = thingModifierTemplates.collect(modifierContainer);
                if (modifiers.attributes.length) {
                    effect.attributes = modifiers.attributes;
                }
                if (modifiers.skills.length) {
                    effect.skills = modifiers.skills;
                }
                effects.push(effect);
            });
            return effects;
        }

        const locationEditNameLabel = locationEditNameInput?.closest('.location-edit-field')?.querySelector('label') || null;
        const locationEditDescriptionLabel = locationEditDescriptionInput?.closest('.location-edit-field')?.querySelector('label') || null;
        const locationEditDefaultTitle = locationEditModalTitle?.textContent || 'Edit Location';
        const locationEditDefaultNameLabel = locationEditNameLabel?.textContent || 'Location Name';
        const locationEditDefaultDescriptionLabel = locationEditDescriptionLabel?.textContent || 'Description';
        const locationEditLevelField = locationEditLevelInput?.closest('.location-edit-field') || null;
        const locationEditAbsoluteLevelField = locationEditAbsoluteLevel?.closest('.location-edit-field') || null;
        const locationEditStatusSection = locationStatusEffectsList?.closest('.location-edit-section') || null;

        function resolveStubDescription(location) {
            if (!location) {
                return '';
            }
            const stubMetadata = location.stubMetadata || {};
            return location.description
                || stubMetadata.shortDescription
                || stubMetadata.targetRegionDescription
                || stubMetadata.blueprintDescription
                || '';
        }

        function resolveStubRelativeLevel(location) {
            if (!location) {
                return null;
            }
            const stubMetadata = location.stubMetadata || {};
            if (Number.isFinite(stubMetadata.targetRegionRelativeLevel)) {
                return Number(stubMetadata.targetRegionRelativeLevel);
            }
            if (Number.isFinite(stubMetadata.relativeLevel)) {
                return Number(stubMetadata.relativeLevel);
            }
            return null;
        }

        function getStubEditContext(location) {
            if (!location || !location.isStub || !location.id) {
                return null;
            }
            const stubMetadata = location.stubMetadata || {};
            return {
                id: location.id,
                isRegionEntryStub: Boolean(stubMetadata.isRegionEntryStub),
                targetRegionId: stubMetadata.targetRegionId || stubMetadata.regionId || null
            };
        }

        function toggleLocationEditSection(element, show) {
            if (!element) {
                return;
            }
            if (show) {
                element.removeAttribute('hidden');
            } else {
                element.setAttribute('hidden', '');
            }
        }

        function setLocationEditMode(mode = 'location', context = null) {
            const normalizedMode = mode === 'stub' ? 'stub' : 'location';
            locationEditMode = normalizedMode;
            stubEditContext = normalizedMode === 'stub' ? (context || null) : null;
            const isStubMode = normalizedMode === 'stub';
            const isRegionStub = Boolean(stubEditContext?.isRegionEntryStub);

            if (locationEditModalTitle) {
                locationEditModalTitle.textContent = isStubMode
                    ? (isRegionStub ? 'Edit Region Stub' : 'Edit Location Stub')
                    : locationEditDefaultTitle;
            }
            if (locationEditNameLabel) {
                locationEditNameLabel.textContent = isStubMode && isRegionStub
                    ? 'Region Name'
                    : locationEditDefaultNameLabel;
            }
            if (locationEditDescriptionLabel) {
                locationEditDescriptionLabel.textContent = isStubMode && isRegionStub
                    ? 'Region Description'
                    : locationEditDefaultDescriptionLabel;
            }

            toggleLocationEditSection(locationEditLevelField, !isStubMode);
            toggleLocationEditSection(locationEditAbsoluteLevelField, !isStubMode);
            toggleLocationEditSection(locationEditStatusSection, !isStubMode);
            toggleLocationEditSection(locationEditShortDescriptionGroup, !isStubMode);
            toggleLocationEditSection(locationEditRelativeLevelGroup, isStubMode);

            if (locationEditLevelInput) {
                locationEditLevelInput.disabled = isStubMode;
                locationEditLevelInput.required = !isStubMode;
                if (isStubMode) {
                    locationEditLevelInput.value = '';
                }
            }
            if (locationEditRelativeLevelInput) {
                locationEditRelativeLevelInput.disabled = !isStubMode;
                if (!isStubMode) {
                    locationEditRelativeLevelInput.value = '';
                }
            }
            if (locationEditShortDescriptionInput) {
                locationEditShortDescriptionInput.disabled = isStubMode;
                if (isStubMode) {
                    locationEditShortDescriptionInput.value = '';
                }
            }
        }

        function openLocationEditModalForTarget(targetLocation) {
            if (!locationEditModal || !targetLocation) {
                alert('No location is currently available to edit.');
                clearLocationMenuContext();
                return;
            }

            const stubContext = getStubEditContext(targetLocation);
            setLocationEditMode(stubContext ? 'stub' : 'location', stubContext);

            const name = targetLocation.name || '';
            const description = stubContext ? resolveStubDescription(targetLocation) : (targetLocation.description || '');
            const numericLevel = Number.isFinite(targetLocation.baseLevel)
                ? targetLocation.baseLevel
                : null;
            const statusEffects = Array.isArray(targetLocation.statusEffects) ? targetLocation.statusEffects : [];

            if (locationEditNameInput) {
                locationEditNameInput.value = name;
            }
            if (locationEditDescriptionInput) {
                locationEditDescriptionInput.value = description;
            }
            if (locationEditShortDescriptionInput) {
                locationEditShortDescriptionInput.value = stubContext ? '' : (targetLocation.shortDescription || '');
            }
            if (stubContext && locationEditRelativeLevelInput) {
                const relativeLevelValue = resolveStubRelativeLevel(targetLocation);
                locationEditRelativeLevelInput.value = Number.isFinite(relativeLevelValue)
                    ? Math.round(relativeLevelValue)
                    : '';
            }
            if (!stubContext && locationEditLevelInput) {
                locationEditLevelInput.value = numericLevel ?? '';
            }
            if (locationEditFactionSelect) {
                populateFactionSelect(locationEditFactionSelect, {
                    selectedId: targetLocation.controllingFactionId || ''
                });
            }
            if (stubContext) {
                renderLocationStatusEffects([]);
                updateLocationAbsoluteLevelDisplay(null);
            } else {
                renderLocationStatusEffects(statusEffects);
                updateLocationAbsoluteLevelDisplay(numericLevel);
            }

            setLocationEditStatus('', null);
            locationEditModal.removeAttribute('hidden');
            locationEditModal.setAttribute('aria-hidden', 'false');
            locationEditModal.classList.add('is-open');
            setTimeout(() => {
                locationEditNameInput?.focus();
            }, 50);
        }

        function openLocationEditModal() {
            const targetLocation = getLocationMenuContext();
            if (!targetLocation) {
                alert('No location is currently available to edit.');
                clearLocationMenuContext();
                return;
            }
            openLocationEditModalForTarget(targetLocation);
        }

        async function openStubEditModal(stubId) {
            const stubIdValue = typeof stubId === 'string' ? stubId.trim() : '';
            if (!stubIdValue) {
                alert('No stub is currently available to edit.');
                return;
            }
            if (!locationEditModal) {
                alert('Location editor is unavailable.');
                return;
            }

            try {
                const response = await fetch(`/api/locations/${encodeURIComponent(stubIdValue)}?expandStubs=false&_=${Date.now()}`, { cache: 'no-store' });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.location) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }
                if (!data.location.isStub) {
                    throw new Error('Selected location is not a stub.');
                }
                openLocationEditModalForTarget(data.location);
            } catch (error) {
                console.warn('Failed to load stub for editing:', error);
                alert(`Failed to load stub: ${error?.message || 'Unknown error'}`);
            }
        }

        window.openStubEditModal = openStubEditModal;

        function closeLocationEditModal() {
            if (!locationEditModal) {
                return;
            }
            locationEditModal.setAttribute('hidden', '');
            locationEditModal.setAttribute('aria-hidden', 'true');
            locationEditModal.classList.remove('is-open');
            setLocationEditStatus('', null);
            updateLocationAbsoluteLevelDisplay(null);
            setLocationEditMode('location', null);
            clearLocationMenuContext();
        }

        async function submitLocationEditForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!locationEditForm) {
                return;
            }
            if (locationEditMode === 'stub') {
                const stubId = stubEditContext?.id || getLocationMenuContext()?.id || null;
                if (!stubId) {
                    setLocationEditStatus('No stub is currently available to edit.', 'error');
                    return;
                }

                const nameValue = locationEditNameInput?.value ?? '';
                if (!nameValue.trim()) {
                    setLocationEditStatus('Stub name cannot be empty.', 'error');
                    locationEditNameInput?.focus();
                    return;
                }

                const descriptionValue = locationEditDescriptionInput?.value ?? '';
                if (!descriptionValue.trim()) {
                    setLocationEditStatus('Stub description cannot be empty.', 'error');
                    locationEditDescriptionInput?.focus();
                    return;
                }

                let relativeLevelValue = null;
                if (locationEditRelativeLevelInput) {
                    const rawRelativeLevel = locationEditRelativeLevelInput.value;
                    const trimmedRelativeLevel = typeof rawRelativeLevel === 'string' ? rawRelativeLevel.trim() : '';
                    if (trimmedRelativeLevel) {
                        const parsed = Number(trimmedRelativeLevel);
                        if (!Number.isFinite(parsed)) {
                            setLocationEditStatus('Relative level must be a number.', 'error');
                            locationEditRelativeLevelInput.focus();
                            return;
                        }
                        relativeLevelValue = parsed;
                    }
                }

                let controllingFactionId = null;
                if (locationEditFactionSelect) {
                    try {
                        controllingFactionId = await resolveSelectedFactionId(locationEditFactionSelect, {
                            label: 'controlling faction'
                        });
                    } catch (error) {
                        setLocationEditStatus(error?.message || 'Failed to validate controlling faction.', 'error');
                        locationEditFactionSelect?.focus();
                        return;
                    }
                }

                const payload = {
                    name: nameValue.trim(),
                    description: descriptionValue.trim()
                };
                if (relativeLevelValue !== null) {
                    payload.relativeLevel = relativeLevelValue;
                }
                if (locationEditFactionSelect) {
                    payload.controllingFactionId = controllingFactionId;
                }

                setLocationEditStatus('Saving stub...', null);
                if (locationEditSaveBtn) {
                    locationEditSaveBtn.disabled = true;
                }

                let overlayShown = false;
                try {
                    showLocationOverlay('Updating stub...');
                    overlayShown = true;
                } catch (_) {
                    // Ignore overlay errors
                }

                try {
                    const response = await fetch(`/api/stubs/${encodeURIComponent(stubId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json().catch(() => ({}));
                    if (!response.ok || !data?.success) {
                        throw new Error(data?.error || `HTTP ${response.status}`);
                    }

                    const updatedName = typeof data?.stub?.name === 'string' ? data.stub.name.trim() : '';
                    if (updatedName && typeof locationCache === 'object') {
                        locationCache[stubId] = updatedName;
                    }

                    const mapTab = document.querySelector('[data-tab="map"]');
                    if (mapTab?.classList.contains('active')) {
                        const mapContainer = document.getElementById('mapContainer');
                        const activeRegionId = mapContainer?.dataset?.regionId || null;
                        try {
                            await window.loadRegionMap?.(activeRegionId || null);
                        } catch (mapError) {
                            console.warn('Failed to refresh map after stub update:', mapError);
                        }
                    }

                    closeLocationEditModal();
                } catch (error) {
                    console.warn('Failed to update stub:', error);
                    setLocationEditStatus(`Failed to update stub: ${error?.message || 'Unknown error'}`, 'error');
                } finally {
                    if (locationEditSaveBtn) {
                        locationEditSaveBtn.disabled = false;
                    }
                    if (overlayShown) {
                        hideLocationOverlay();
                    }
                }
                return;
            }
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                setLocationEditStatus('No active location to edit.', 'error');
                return;
            }

            const payload = {};
            const nameValue = locationEditNameInput?.value ?? '';
            payload.name = nameValue.trim() || null;

            const descriptionValue = locationEditDescriptionInput?.value ?? '';
            payload.description = descriptionValue.trim();
            const shortDescriptionValue = locationEditShortDescriptionInput?.value ?? '';
            payload.shortDescription = shortDescriptionValue.trim();

            const levelValue = Number(locationEditLevelInput?.value ?? NaN);
            if (!Number.isFinite(levelValue) || levelValue < 1) {
                setLocationEditStatus('Level must be a positive number.', 'error');
                locationEditLevelInput?.focus();
                return;
            }
            payload.level = Math.max(1, Math.round(levelValue));

            const statusEffectsValue = collectLocationStatusEffects();
            payload.statusEffects = statusEffectsValue;

            let controllingFactionId = null;
            if (locationEditFactionSelect) {
                try {
                    controllingFactionId = await resolveSelectedFactionId(locationEditFactionSelect, {
                        label: 'controlling faction'
                    });
                } catch (error) {
                    setLocationEditStatus(error?.message || 'Failed to validate controlling faction.', 'error');
                    locationEditFactionSelect?.focus();
                    return;
                }
                payload.controllingFactionId = controllingFactionId;
            }

            setLocationEditStatus('Saving changes...', null);
            if (locationEditSaveBtn) {
                locationEditSaveBtn.disabled = true;
            }
            showLocationOverlay('Updating location...');

            try {
                const response = await fetch(`/api/locations/${encodeURIComponent(targetLocation.id)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setLocationEditStatus('Location updated.', 'success');
                closeLocationEditModal();

                const updatedLocation = data.location;
                if (updatedLocation) {
                    if (isCurrentLocationContext(targetLocation)) {
                        lastRenderedLocation = JSON.parse(JSON.stringify(updatedLocation));
                        await window.updateLocationDisplay(updatedLocation);
                    } else {
                        setLocationMenuContext(updatedLocation);
                    }
                    const mapTab = document.querySelector('[data-tab="map"]');
                    if (mapTab?.classList.contains('active')) {
                        const mapContainer = document.getElementById('mapContainer');
                        const activeRegionId = mapContainer?.dataset?.regionId || null;
                        if (!activeRegionId || (updatedLocation.regionId && updatedLocation.regionId === activeRegionId)) {
                            try {
                                await window.loadRegionMap?.(activeRegionId || updatedLocation.regionId || null);
                            } catch (mapError) {
                                console.warn('Failed to refresh map after location edit:', mapError);
                            }
                        }
                    }
                } else if (typeof window.loadCurrentLocation === 'function') {
                    await window.loadCurrentLocation();
                }
            } catch (error) {
                console.warn('Failed to update location:', error);
                setLocationEditStatus(`Failed to update location: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (locationEditSaveBtn) {
                    locationEditSaveBtn.disabled = false;
                }
                hideLocationOverlay();
            }
        }

        const summonNpcOptionIndex = new Map();
        const summonThingOptionIndex = new Map();

        function resetSummonSelect(selectElement, placeholderLabel) {
            if (!selectElement) {
                return;
            }
            selectElement.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = placeholderLabel;
            option.disabled = true;
            option.selected = true;
            option.hidden = true;
            selectElement.appendChild(option);
            selectElement.value = '';
        }

        function setSummonNpcStatus(message = '', type = null) {
            if (!summonNpcStatus) {
                return;
            }
            summonNpcStatus.textContent = message || '';
            summonNpcStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                summonNpcStatus.classList.add('is-error');
            } else if (type === 'success') {
                summonNpcStatus.classList.add('is-success');
            }
        }

        function setSummonThingStatus(message = '', type = null) {
            if (!summonThingStatus) {
                return;
            }
            summonThingStatus.textContent = message || '';
            summonThingStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                summonThingStatus.classList.add('is-error');
            } else if (type === 'success') {
                summonThingStatus.classList.add('is-success');
            }
        }

        async function loadSummonActorDirectory() {
            const response = await fetch('/api/players', { cache: 'no-store' });
            const data = await response.json().catch(() => ({}));
            if (!response.ok || !data?.success || !Array.isArray(data.players)) {
                throw new Error(data?.error || `HTTP ${response.status}`);
            }

            const directory = {
                list: [],
                map: new Map()
            };

            data.players.forEach(entry => {
                if (!entry || !entry.id) {
                    return;
                }
                directory.list.push(entry);
                directory.map.set(entry.id, entry);
            });

            return directory;
        }

        async function gatherSummonResources() {
            const [actorDirectory, locationOptions] = await Promise.all([
                loadSummonActorDirectory(),
                loadTeleportLocationOptions()
            ]);

            const locationLabelMap = new Map();
            if (Array.isArray(locationOptions)) {
                locationOptions.forEach(option => {
                    if (option && option.id) {
                        locationLabelMap.set(option.id, option.label || option.id);
                    }
                });
            }

            return { actorDirectory, locationLabelMap };
        }

        async function gatherSummonNpcOptions() {
            const currentLocationId = getLocationMenuContext()?.id || null;
            if (!currentLocationId) {
                throw new Error('No active location loaded.');
            }

            const { actorDirectory, locationLabelMap } = await gatherSummonResources();
            const options = [];

            for (const npc of actorDirectory.list) {
                if (!npc || !npc.id || !npc.isNPC) {
                    continue;
                }
                const name = typeof npc.name === 'string' ? npc.name.trim() : '';
                if (!name) {
                    continue;
                }
                if (npc.isDead) {
                    continue;
                }
                const locationIdRaw = typeof npc.locationId === 'string' ? npc.locationId.trim() : '';
                if (locationIdRaw && locationIdRaw === currentLocationId) {
                    continue;
                }
                const locationName = locationIdRaw
                    ? (locationLabelMap.get(locationIdRaw) || `Location ${locationIdRaw}`)
                    : 'Unknown location';
                options.push({
                    id: npc.id,
                    name,
                    locationId: locationIdRaw || null,
                    locationName,
                    raw: npc
                });
            }

            options.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
            return options;
        }

        async function gatherSummonThingOptions() {
            const currentLocationId = getLocationMenuContext()?.id || null;
            if (!currentLocationId) {
                throw new Error('No active location loaded.');
            }

            const { actorDirectory, locationLabelMap } = await gatherSummonResources();
            const response = await fetch('/api/things', { cache: 'no-store' });
            const data = await response.json().catch(() => ({}));
            if (!response.ok || !data?.success || !Array.isArray(data.things)) {
                throw new Error(data?.error || `HTTP ${response.status}`);
            }

            const options = [];
            const seenIds = new Set();

            data.things.forEach(thing => {
                if (!thing || !thing.id || seenIds.has(thing.id)) {
                    return;
                }
                const name = typeof thing.name === 'string' ? thing.name.trim() : '';
                if (!name) {
                    return;
                }
                const type = typeof thing.thingType === 'string' ? thing.thingType.trim().toLowerCase() : '';
                if (type !== 'item' && type !== 'scenery') {
                    return;
                }

                const metadata = thing.metadata && typeof thing.metadata === 'object' ? thing.metadata : {};
                const locationIdRaw = typeof metadata.locationId === 'string' ? metadata.locationId.trim() : '';
                if (locationIdRaw && locationIdRaw === currentLocationId) {
                    return;
                }

                const ownerIdRaw = typeof metadata.ownerId === 'string' ? metadata.ownerId.trim()
                    : (typeof metadata.ownerID === 'string' ? metadata.ownerID.trim() : '');
                const ownerNameMeta = typeof metadata.ownerName === 'string' ? metadata.ownerName.trim()
                    : (typeof metadata.owner === 'string' ? metadata.owner.trim() : '');
                let ownerName = ownerNameMeta || null;
                if (ownerIdRaw && actorDirectory.map.has(ownerIdRaw)) {
                    ownerName = actorDirectory.map.get(ownerIdRaw).name || ownerName || ownerIdRaw;
                } else if (!ownerName && ownerIdRaw) {
                    ownerName = ownerIdRaw;
                }

                let originLabel = 'Unknown location';
                if (locationIdRaw) {
                    originLabel = locationLabelMap.get(locationIdRaw) || `Location ${locationIdRaw}`;
                } else if (ownerName) {
                    originLabel = `${ownerName}'s inventory`;
                }

                const typeLabel = type === 'scenery' ? 'Scenery' : 'Item';
                options.push({
                    id: thing.id,
                    name,
                    type: typeLabel,
                    locationId: locationIdRaw || null,
                    ownerId: ownerIdRaw || null,
                    ownerName: ownerName || null,
                    originLabel,
                    raw: thing
                });
                seenIds.add(thing.id);
            });

            options.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
            return options;
        }

        async function applySummonLocationUpdate(payload) {
            if (!payload || !payload.id) {
                return false;
            }
            if (!window.lastRenderedLocation || window.lastRenderedLocation.id !== payload.id) {
                return false;
            }
            try {
                await window.updateLocationDisplay?.(payload);
                window.lastRenderedLocation = JSON.parse(JSON.stringify(payload));
                return true;
            } catch (error) {
                console.warn('Failed to apply location update:', error);
                return false;
            }
        }

        async function openSummonNpcModal() {
            if (!summonNpcModal) {
                alert('Summon NPC dialog is unavailable.');
                return;
            }
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                alert('No location is currently loaded.');
                return;
            }

            summonNpcOptionIndex.clear();
            resetSummonSelect(summonNpcSelect, 'Select an NPC');
            if (summonNpcSelect) {
                summonNpcSelect.disabled = true;
            }
            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = true;
            }
            setSummonNpcStatus('Loading NPCs...', null);

            summonNpcModal.removeAttribute('hidden');
            summonNpcModal.setAttribute('aria-hidden', 'false');
            summonNpcModal.classList.add('is-open');
            requestAnimationFrame(() => {
                summonNpcSelect?.focus();
            });

            try {
                const options = await gatherSummonNpcOptions();

                if (!options.length) {
                    setSummonNpcStatus('No NPCs are available to summon.', 'error');
                    return;
                }

                const fragment = document.createDocumentFragment();
                options.forEach(option => {
                    summonNpcOptionIndex.set(option.id, option);
                    const opt = document.createElement('option');
                    opt.value = option.id;
                    opt.textContent = `${option.name} ‚Äî ${option.locationName}`;
                    opt.dataset.locationId = option.locationId || '';
                    opt.dataset.locationName = option.locationName || '';
                    fragment.appendChild(opt);
                });

                if (summonNpcSelect) {
                    summonNpcSelect.appendChild(fragment);
                    summonNpcSelect.disabled = false;
                    summonNpcSelect.value = '';
                }

                setSummonNpcStatus('', null);
            } catch (error) {
                console.warn('Failed to load summon NPC options:', error);
                setSummonNpcStatus(`Failed to load NPCs: ${error?.message || error}`, 'error');
            }
        }

        function closeSummonNpcModal() {
            if (!summonNpcModal) {
                return;
            }
            summonNpcModal.setAttribute('hidden', '');
            summonNpcModal.setAttribute('aria-hidden', 'true');
            summonNpcModal.classList.remove('is-open');
            setSummonNpcStatus('', null);
            summonNpcOptionIndex.clear();
            resetSummonSelect(summonNpcSelect, 'Select an NPC');
            if (summonNpcSelect) {
                summonNpcSelect.disabled = true;
            }
            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = true;
            }
            clearLocationMenuContext();
        }

        async function openSummonThingModal() {
            if (!summonThingModal) {
                alert('Summon item dialog is unavailable.');
                return;
            }
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                alert('No location is currently loaded.');
                return;
            }

            summonThingOptionIndex.clear();
            resetSummonSelect(summonThingSelect, 'Select an item');
            if (summonThingSelect) {
                summonThingSelect.disabled = true;
            }
            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = true;
            }
            setSummonThingStatus('Loading items...', null);

            summonThingModal.removeAttribute('hidden');
            summonThingModal.setAttribute('aria-hidden', 'false');
            summonThingModal.classList.add('is-open');
            requestAnimationFrame(() => {
                summonThingSelect?.focus();
            });

            try {
                const options = await gatherSummonThingOptions();

                if (!options.length) {
                    setSummonThingStatus('No items or scenery are available to summon.', 'error');
                    return;
                }

                const fragment = document.createDocumentFragment();
                options.forEach(option => {
                    summonThingOptionIndex.set(option.id, option);
                    const opt = document.createElement('option');
                    opt.value = option.id;
                    opt.textContent = `${option.name} ‚Äî ${option.type} ¬∑ ${option.originLabel}`;
                    opt.dataset.origin = option.originLabel || '';
                    fragment.appendChild(opt);
                });

                if (summonThingSelect) {
                    summonThingSelect.appendChild(fragment);
                    summonThingSelect.disabled = false;
                    summonThingSelect.value = '';
                }

                setSummonThingStatus('', null);
            } catch (error) {
                console.warn('Failed to load summon item options:', error);
                setSummonThingStatus(`Failed to load items: ${error?.message || error}`, 'error');
            }
        }

        function closeSummonThingModal() {
            if (!summonThingModal) {
                return;
            }
            summonThingModal.setAttribute('hidden', '');
            summonThingModal.setAttribute('aria-hidden', 'true');
            summonThingModal.classList.remove('is-open');
            setSummonThingStatus('', null);
            summonThingOptionIndex.clear();
            resetSummonSelect(summonThingSelect, 'Select an item');
            if (summonThingSelect) {
                summonThingSelect.disabled = true;
            }
            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = true;
            }
            clearLocationMenuContext();
        }

        function handleSummonNpcSelectionChange() {
            if (!summonNpcSelect) {
                return;
            }
            const npcId = summonNpcSelect.value;
            if (!npcId || !summonNpcOptionIndex.has(npcId)) {
                if (summonNpcConfirmBtn) {
                    summonNpcConfirmBtn.disabled = true;
                }
                return;
            }
            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = false;
            }
            setSummonNpcStatus('', null);
        }

        function handleSummonThingSelectionChange() {
            if (!summonThingSelect) {
                return;
            }
            const thingId = summonThingSelect.value;
            if (!thingId || !summonThingOptionIndex.has(thingId)) {
                if (summonThingConfirmBtn) {
                    summonThingConfirmBtn.disabled = true;
                }
                return;
            }
            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = false;
            }
            setSummonThingStatus('', null);
        }

        async function submitSummonNpcForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!summonNpcSelect) {
                return;
            }
            const npcId = summonNpcSelect.value;
            if (!npcId || !summonNpcOptionIndex.has(npcId)) {
                setSummonNpcStatus('Select an NPC to summon.', 'error');
                return;
            }
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                setSummonNpcStatus('No location is currently loaded.', 'error');
                return;
            }

            if (summonNpcConfirmBtn) {
                summonNpcConfirmBtn.disabled = true;
            }
            setSummonNpcStatus('Summoning NPC...', null);

            let overlayVisible = false;
            try {
                showLocationOverlay('Summoning NPC...');
                overlayVisible = true;
            } catch (_) {
                // Ignore overlay errors
            }

            try {
                const optionEntry = summonNpcOptionIndex.get(npcId);
                const npcRecord = optionEntry?.raw
                    ? (cloneActorRecord(optionEntry.raw) || { ...optionEntry.raw })
                    : { id: npcId };

                await teleportNpcToLocation(npcRecord, targetLocation.id, {
                    originLocationId: optionEntry?.locationId || null
                });

                closeSummonNpcModal();
            } catch (error) {
                console.warn('Failed to summon NPC:', error);
                setSummonNpcStatus(`Failed to summon NPC: ${error?.message || error}`, 'error');
            } finally {
                if (overlayVisible) {
                    hideLocationOverlay();
                }
                if (summonNpcConfirmBtn && summonNpcModal?.classList.contains('is-open')) {
                    summonNpcConfirmBtn.disabled = false;
                }
            }
        }

        async function submitSummonThingForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!summonThingSelect) {
                return;
            }
            const thingId = summonThingSelect.value;
            const entry = thingId ? summonThingOptionIndex.get(thingId) : null;
            if (!entry) {
                setSummonThingStatus('Select an item or scenery to summon.', 'error');
                return;
            }
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                setSummonThingStatus('No location is currently loaded.', 'error');
                return;
            }

            if (summonThingConfirmBtn) {
                summonThingConfirmBtn.disabled = true;
            }
            setSummonThingStatus('Summoning item...', null);

            let overlayVisible = false;
            try {
                showLocationOverlay('Summoning item...');
                overlayVisible = true;
            } catch (_) {
                // Ignore overlay errors
            }

            try {
                const teleportResult = await teleportThingToLocation(entry.raw, targetLocation.id, {
                    context: 'general',
                    originLocationId: entry.locationId || null
                });

                let locationUpdated = false;
                if (teleportResult?.previousLocation) {
                    locationUpdated = await applySummonLocationUpdate(teleportResult.previousLocation) || locationUpdated;
                }
                if (teleportResult?.destination) {
                    locationUpdated = await applySummonLocationUpdate(teleportResult.destination) || locationUpdated;
                }

                if (!locationUpdated && typeof window.loadCurrentLocation === 'function') {
                    try {
                        await window.loadCurrentLocation();
                    } catch (refreshError) {
                        console.warn('Failed to refresh location after item summon:', refreshError);
                    }
                }

                closeSummonThingModal();
            } catch (error) {
                console.warn('Failed to summon item:', error);
                console.debug(error);
                setSummonThingStatus(`Failed to summon item: ${error?.message || error}`, 'error');
            } finally {
                if (overlayVisible) {
                    hideLocationOverlay();
                }
                if (summonThingConfirmBtn && summonThingModal?.classList.contains('is-open')) {
                    summonThingConfirmBtn.disabled = false;
                }
            }
        }

        function setRegionEditStatus(message = '', type = null) {
            if (!regionEditStatus) {
                return;
            }
            regionEditStatus.textContent = message || '';
            regionEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                regionEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                regionEditStatus.classList.add('is-success');
            }
        }

        function populateRegionParentOptions(options = [], selectedId = null) {
            if (!regionEditParentSelect) {
                return;
            }
            regionEditParentSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'None';
            regionEditParentSelect.appendChild(defaultOption);

            (options || []).forEach(option => {
                if (!option || !option.id) {
                    return;
                }
               const opt = document.createElement('option');
                opt.value = option.id;
                opt.textContent = option.name || option.id;
                if (option.id === selectedId) {
                    opt.selected = true;
                }
                regionEditParentSelect.appendChild(opt);
            });
        }

        async function openRegionEditModal() {
            const targetLocation = getLocationMenuContext();
            if (!regionEditModal || !targetLocation) {
                alert('No location is currently available for region editing.');
                clearLocationMenuContext();
                return;
            }
            const regionId = targetLocation.regionId
                || targetLocation.stubMetadata?.regionId
                || null;

            if (!regionId) {
                alert('No region is associated with the current location.');
                return;
            }

            editingRegionId = regionId;
            if (regionEditForm) {
                regionEditForm.reset();
            }
            populateRegionParentOptions([], null);
            if (regionEditSaveBtn) {
                regionEditSaveBtn.disabled = true;
            }
            setRegionEditStatus('Loading region‚Ä¶', null);
            if (regionEditAverageLevelInput) {
                regionEditAverageLevelInput.value = '';
            }

            regionEditModal.removeAttribute('hidden');
            regionEditModal.setAttribute('aria-hidden', 'false');
            regionEditModal.classList.add('is-open');

            try {
                const response = await fetch(`/api/regions/${encodeURIComponent(regionId)}`);
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success || !data.region) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                if (regionEditNameInput) {
                    regionEditNameInput.value = data.region.name || '';
                }
                if (regionEditDescriptionInput) {
                    regionEditDescriptionInput.value = data.region.description || '';
                }
                if (regionEditShortDescriptionInput) {
                    regionEditShortDescriptionInput.value = data.region.shortDescription || '';
                }
                if (regionEditAverageLevelInput) {
                    const averaged = Number.isFinite(data.region.averageLevel)
                        ? Math.max(1, Math.round(data.region.averageLevel))
                        : '';
                    regionEditAverageLevelInput.value = averaged;
                }
                populateRegionParentOptions(data.parentOptions || [], data.region.parentRegionId || null);
                if (regionEditFactionSelect) {
                    populateFactionSelect(regionEditFactionSelect, {
                        selectedId: data.region.controllingFactionId || ''
                    });
                }
                setRegionEditStatus('', null);
                if (regionEditSaveBtn) {
                    regionEditSaveBtn.disabled = false;
                }
                setTimeout(() => {
                    regionEditNameInput?.focus();
                }, 50);
            } catch (error) {
                console.warn('Failed to load region for editing:', error);
                setRegionEditStatus(`Failed to load region: ${error?.message || 'Unknown error'}`, 'error');
                if (regionEditSaveBtn) {
                    regionEditSaveBtn.disabled = true;
                }
                if (regionEditAverageLevelInput) {
                    regionEditAverageLevelInput.value = '';
                }
            }
        }

        function closeRegionEditModal() {
            if (!regionEditModal) {
                return;
            }
            regionEditModal.setAttribute('hidden', '');
            regionEditModal.setAttribute('aria-hidden', 'true');
            regionEditModal.classList.remove('is-open');
            setRegionEditStatus('', null);
            if (regionEditForm) {
                regionEditForm.reset();
            }
            if (regionEditSaveBtn) {
                regionEditSaveBtn.disabled = false;
            }
            editingRegionId = null;
            if (regionEditAverageLevelInput) {
                regionEditAverageLevelInput.value = '';
            }
            clearLocationMenuContext();
        }

        async function submitRegionEditForm(event) {
            if (event) {
                event.preventDefault();
            }
            if (!regionEditForm) {
                return;
            }
            if (!editingRegionId) {
                setRegionEditStatus('No region is currently selected for editing.', 'error');
                return;
            }

            const nameValue = regionEditNameInput?.value ?? '';
            if (!nameValue.trim()) {
                setRegionEditStatus('Region name cannot be empty.', 'error');
                regionEditNameInput?.focus();
                return;
            }

            const descriptionValue = regionEditDescriptionInput?.value ?? '';

            const averageLevelRaw = regionEditAverageLevelInput?.value ?? '';
            if (!averageLevelRaw.toString().trim()) {
                setRegionEditStatus('Region average level is required.', 'error');
                regionEditAverageLevelInput?.focus();
                return;
            }
            const averageLevelValue = Number(averageLevelRaw);
            if (!Number.isFinite(averageLevelValue) || averageLevelValue < 1) {
                setRegionEditStatus('Average level must be a positive number.', 'error');
                regionEditAverageLevelInput?.focus();
                return;
            }
            const normalizedAverageLevel = Math.max(1, Math.round(averageLevelValue));
            if (regionEditAverageLevelInput) {
                regionEditAverageLevelInput.value = normalizedAverageLevel;
            }

            const parentValueRaw = regionEditParentSelect?.value ?? '';
            const payload = {
                name: nameValue.trim(),
                description: descriptionValue.trim(),
                shortDescription: (regionEditShortDescriptionInput?.value ?? '').trim(),
                parentRegionId: parentValueRaw && parentValueRaw.trim() ? parentValueRaw.trim() : null,
                averageLevel: normalizedAverageLevel
            };

            if (regionEditFactionSelect) {
                try {
                    const controllingFactionId = await resolveSelectedFactionId(regionEditFactionSelect, {
                        label: 'controlling faction'
                    });
                    payload.controllingFactionId = controllingFactionId;
                } catch (error) {
                    setRegionEditStatus(error?.message || 'Failed to validate controlling faction.', 'error');
                    regionEditFactionSelect?.focus();
                    return;
                }
            }

            setRegionEditStatus('Saving changes‚Ä¶', null);
            if (regionEditSaveBtn) {
                regionEditSaveBtn.disabled = true;
            }

            try {
                const response = await fetch(`/api/regions/${encodeURIComponent(editingRegionId)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data?.success || !data.region) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                setRegionEditStatus('Region updated successfully.', 'success');
                newExitOptionsCache = null;
                newExitRegionsById = new Map();
                ensureNewExitOptionsLoaded(true).catch(error => {
                    console.warn('Failed to refresh exit options after region edit:', error);
                });

                const mapTab = document.querySelector('[data-tab="map"]');
                if (mapTab && mapTab.classList.contains('active')) {
                    const mapContainer = document.getElementById('mapContainer');
                    const activeRegionId = mapContainer?.dataset?.regionId || null;
                    if (!activeRegionId || activeRegionId === editingRegionId) {
                        try {
                            await window.loadRegionMap?.(activeRegionId || editingRegionId || null);
                        } catch (mapError) {
                            console.warn('Failed to refresh map after region edit:', mapError);
                        }
                    }
                }

                closeRegionEditModal();
            } catch (error) {
                console.warn('Failed to update region:', error);
                setRegionEditStatus(`Failed to update region: ${error?.message || 'Unknown error'}`, 'error');
            } finally {
                if (regionEditSaveBtn) {
                    regionEditSaveBtn.disabled = false;
                }
            }
        }

        async function regenerateLocationImage() {
            const targetLocation = getLocationMenuContext();
            if (!targetLocation || !targetLocation.id) {
                alert('No location is currently loaded.');
                clearLocationMenuContext();
                return;
            }
            if (locationImageRegenerateButton && locationImageRegenerateButton.disabled && isCurrentLocationContext(targetLocation)) {
                alert('Image generation is disabled.');
                clearLocationMenuContext();
                return;
            }

            const locationId = String(targetLocation.id);
            const placeholderAlt = targetLocation.name || 'Location image';
            const affectsCurrentLocation = isCurrentLocationContext(targetLocation);

            if (affectsCurrentLocation) {
                applyEntityImagePlaceholder('location', locationId);
                lastRenderedLocation.imageId = null;
                lastRenderedLocation.pendingImageJobId = null;
            }

            const payload = {
                entityType: 'location',
                entityId: locationId,
                force: true
            };

            const clientId = window.AIRPG_CLIENT_ID || null;
            if (clientId) {
                payload.clientId = clientId;
            }

            try {
                const response = await fetch('/api/images/request', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(data?.error || `HTTP ${response.status}`);
                }

                if (data?.skipped) {
                    if (affectsCurrentLocation) {
                        renderEntityImages('location', locationId, {
                            imageId: lastRenderedLocation.imageId || null,
                            force: false,
                            altText: placeholderAlt
                        });
                    }
                    alert('Image regeneration was skipped.');
                    return;
                }

                if (data?.imageId) {
                    if (affectsCurrentLocation) {
                        lastRenderedLocation.imageId = data.imageId;
                    } else if (locationMenuContextOverride?.id === targetLocation.id) {
                        locationMenuContextOverride.imageId = data.imageId;
                    }
                }
                if (data?.jobId) {
                    if (affectsCurrentLocation) {
                        lastRenderedLocation.pendingImageJobId = data.jobId;
                    } else if (locationMenuContextOverride?.id === targetLocation.id) {
                        locationMenuContextOverride.pendingImageJobId = data.jobId;
                    }
                }

                if (affectsCurrentLocation) {
                    renderEntityImages('location', locationId, {
                        imageId: null,
                        force: true,
                        altText: placeholderAlt
                    });
                }
            } catch (error) {
                console.warn('Failed to regenerate location image:', error);
                alert(`Failed to regenerate image: ${error?.message || 'Unknown error'}`);
                if (affectsCurrentLocation) {
                    renderEntityImages('location', locationId, {
                        imageId: lastRenderedLocation.imageId || null,
                        force: false,
                        altText: placeholderAlt
                    });
                }
            } finally {
                clearLocationMenuContext();
            }
        }

        if (locationImageMenuButton) {
            locationImageMenuButton.addEventListener('click', (event) => {
                event.stopPropagation();
                clearLocationMenuContext();
                toggleLocationImageMenu();
            });
        }

        if (locationImageEditButton) {
            locationImageEditButton.addEventListener('click', (event) => {
                event.stopPropagation();
                closeLocationImageMenu({ preserveContext: true });
                openLocationEditModal();
            });
        }

        if (locationRegionEditButton) {
            locationRegionEditButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu({ preserveContext: true });
                await openRegionEditModal();
            });
        }

        if (locationSummonNpcButton) {
            locationSummonNpcButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu({ preserveContext: true });
                await openSummonNpcModal();
            });
        }

        if (locationSummonThingButton) {
            locationSummonThingButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu({ preserveContext: true });
                await openSummonThingModal();
            });
        }

        if (locationImageRegenerateButton) {
            locationImageRegenerateButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeLocationImageMenu({ preserveContext: true });
                await regenerateLocationImage();
            });
        }

        if (mapLocationMenuEditButton) {
            mapLocationMenuEditButton.addEventListener('click', (event) => {
                event.stopPropagation();
                closeMapLocationContextMenu({ preserveContext: true });
                openLocationEditModal();
            });
        }

        if (mapLocationMenuRegionButton) {
            mapLocationMenuRegionButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeMapLocationContextMenu({ preserveContext: true });
                await openRegionEditModal();
            });
        }

        if (mapLocationMenuSummonNpcButton) {
            mapLocationMenuSummonNpcButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeMapLocationContextMenu({ preserveContext: true });
                await openSummonNpcModal();
            });
        }

        if (mapLocationMenuSummonThingButton) {
            mapLocationMenuSummonThingButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeMapLocationContextMenu({ preserveContext: true });
                await openSummonThingModal();
            });
        }

        if (mapLocationMenuRegenerateImageButton) {
            mapLocationMenuRegenerateImageButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeMapLocationContextMenu({ preserveContext: true });
                await regenerateLocationImage();
            });
        }

        if (worldMapReloadButton) {
            const defaultLabel = (worldMapReloadButton.textContent || 'Reload').trim() || 'Reload';
            worldMapReloadButton.addEventListener('click', async () => {
                if (worldMapReloadButton.disabled) {
                    return;
                }
                worldMapReloadButton.disabled = true;
                worldMapReloadButton.textContent = 'Loading...';
                try {
                    await window.loadWorldMap?.();
                } finally {
                    worldMapReloadButton.disabled = false;
                    worldMapReloadButton.textContent = defaultLabel;
                }
            });
        }

        document.addEventListener('click', (event) => {
            if (locationImageMenuOpen) {
                if (!locationImageWrapper || !locationImageWrapper.contains(event.target)) {
                    closeLocationImageMenu();
                }
            }
            if (mapLocationMenuOpen) {
                if (!mapLocationContextMenu || !mapLocationContextMenu.contains(event.target)) {
                    closeMapLocationContextMenu();
                }
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                if (locationImageMenuOpen) {
                    closeLocationImageMenu();
                }
                if (mapLocationMenuOpen) {
                    closeMapLocationContextMenu();
                }
            }
        });

        window.addEventListener('resize', () => {
            if (mapLocationMenuOpen) {
                closeMapLocationContextMenu();
            }
        });

        if (locationEditCancelBtn) {
            locationEditCancelBtn.addEventListener('click', () => closeLocationEditModal());
        }
        if (locationEditCloseBtn) {
            locationEditCloseBtn.addEventListener('click', () => closeLocationEditModal());
        }
        if (locationEditForm) {
            locationEditForm.addEventListener('submit', submitLocationEditForm);
        }
        if (locationStatusEffectAddBtn) {
            locationStatusEffectAddBtn.addEventListener('click', () => {
                const row = createLocationStatusEffectRow({});
                row?.querySelector('.thing-edit-status-description')?.focus();
            });
        }

        if (summonNpcCancelBtn) {
            summonNpcCancelBtn.addEventListener('click', () => closeSummonNpcModal());
        }
        if (summonNpcCloseBtn) {
            summonNpcCloseBtn.addEventListener('click', () => closeSummonNpcModal());
        }
        if (summonNpcForm) {
            summonNpcForm.addEventListener('submit', submitSummonNpcForm);
        }
        if (summonNpcSelect) {
            summonNpcSelect.addEventListener('change', handleSummonNpcSelectionChange);
        }

        if (summonThingCancelBtn) {
            summonThingCancelBtn.addEventListener('click', () => closeSummonThingModal());
        }
        if (summonThingCloseBtn) {
            summonThingCloseBtn.addEventListener('click', () => closeSummonThingModal());
        }
        if (summonThingForm) {
            summonThingForm.addEventListener('submit', submitSummonThingForm);
        }
        if (summonThingSelect) {
            summonThingSelect.addEventListener('change', handleSummonThingSelectionChange);
        }

        if (locationEditLevelInput) {
            locationEditLevelInput.addEventListener('input', () => {
                const raw = locationEditLevelInput.value;
                const hasValue = typeof raw === 'string' && raw.trim() !== '';
                const parsed = hasValue ? Number(raw) : null;
                const normalized = Number.isFinite(parsed) ? parsed : null;
                updateLocationAbsoluteLevelDisplay(normalized);
            });
        }

        if (regionEditCancelBtn) {
            regionEditCancelBtn.addEventListener('click', () => closeRegionEditModal());
        }
        if (regionEditCloseBtn) {
            regionEditCloseBtn.addEventListener('click', () => closeRegionEditModal());
        }
        if (regionEditForm) {
            regionEditForm.addEventListener('submit', submitRegionEditForm);
        }

        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeLocationEditModal();
                closeRegionEditModal();
            }
        });

        let draggedLocationThing = null;

        const resetThingDragState = () => {
            draggedLocationThing = null;
            document.querySelectorAll('.inventory-drop-target.is-drop-hover').forEach(el => {
                el.classList.remove('is-drop-hover');
            });
        };

        async function handleGiveThingToOwner({ ownerId, ownerType }) {
            if (!draggedLocationThing || !draggedLocationThing.id || !ownerId) {
                return;
            }
            try {
                const thingRecord = thingDataCache.get(draggedLocationThing.id) || draggedLocationThing.thing || { id: draggedLocationThing.id };
                const result = await moveThingToInventory(thingRecord, {
                    ownerId,
                    ownerType,
                    locationId: draggedLocationThing.locationId || null
                });
                if (draggedLocationThing) {
                    const el = draggedLocationThing.element;
                    if (el && el.parentElement) {
                        el.parentElement.removeChild(el);
                    }
                }
                document.dispatchEvent(new Event('inventory:updated'));
            } catch (error) {
                console.warn('Failed to move item into inventory:', error);
                window.alert(error?.message || 'Failed to move item into inventory.');
            } finally {
                resetThingDragState();
            }
        }

        function registerInventoryDropTarget(element, { ownerId, ownerType }) {
            if (!element || !ownerId) {
                return;
            }
            element.classList.add('inventory-drop-target');

            element.addEventListener('dragover', (event) => {
                if (!draggedLocationThing) return;
                event.preventDefault();
                element.classList.add('is-drop-hover');
            });

            element.addEventListener('dragenter', (event) => {
                if (!draggedLocationThing) return;
                event.preventDefault();
                element.classList.add('is-drop-hover');
            });

            element.addEventListener('dragleave', () => {
                element.classList.remove('is-drop-hover');
            });

            element.addEventListener('drop', async (event) => {
                event.preventDefault();
                element.classList.remove('is-drop-hover');
                await handleGiveThingToOwner({ ownerId, ownerType });
            });
        }

        window.registerInventoryDropTarget = registerInventoryDropTarget;

        window.updateLocationDisplay = async function(location) {
                const locationName = document.getElementById('locationName');
                const locationTooltip = document.getElementById('locationTooltip');
                const locationHint = document.getElementById('locationHint');
                const locationLevel = document.getElementById('locationLevel');
                const locationImage = document.getElementById('locationImage');
        const locationExitsList = document.getElementById('locationExitsList');
                const tooltipController = window.floatingTooltipController;

                if (tooltipController && typeof tooltipController.hide === 'function') {
                    tooltipController.hide();
                }

                closeNpcContextMenu();
                npcDataCache.clear();

                const maybeLoadThingDetails = async (loc) => {
                    if (!loc) {
                        return [];
                    }
                    let resolvedThings = Array.isArray(loc.things) ? [...loc.things] : [];
                    if (resolvedThings.length === 0 && Array.isArray(loc.thingIds) && loc.thingIds.length > 0) {
                        const fetched = await Promise.all(loc.thingIds.map(fetchThingDetails));
                        resolvedThings = fetched.filter(Boolean);
                        if (resolvedThings.length > 0) {
                            loc.things = resolvedThings;
                        }
                    }
                    return resolvedThings;
                };

                if (location) {
                    const locationDescriptionHtml = location.description || 'No description available.';
                    const locationDescriptionText = locationDescriptionHtml
                        .replace(/<[^>]+>/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim() || 'No description available.';

                    locationName.textContent = location.name || 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = locationDescriptionHtml;
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        const awaitingImage = !location.imageId;
                        if (awaitingImage) {
                            locationHint.textContent = locationImageGenerationEnabled
                                ? 'Generating location image...'
                                : 'Location image generation is disabled.';
                        } else {
                            locationHint.textContent = location.description
                                ? 'Hover over the location image for a description.'
                                : 'No description available for this location yet.';
                        }
                    }
                    locationLevel.textContent = `Level: ${location.baseLevel || '?'}`;
                    locationCache[location.id] = location.name || location.description || location.id;
                    
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        const placeholderMarkup = locationImageGenerationEnabled
                            ? '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>'
                            : '<div class="location-placeholder"></div>';

                        const finalizeTooltip = () => {
                            if (existingTooltip && !existingTooltip.isConnected) {
                                locationImage.appendChild(existingTooltip);
                            }
                        };

                        const renderPromise = renderEntityImage({
                            element: locationImage,
                            entityType: 'location',
                            entityId: location.id,
                            imageId: location.imageId || null,
                            altText: location.name || 'Location image',
                            placeholderIcon: 'üèûÔ∏è',
                            placeholderClass: 'location-placeholder',
                            placeholderMarkup,
                            enableLightbox: true
                        });

                        finalizeTooltip();

                        if (renderPromise && typeof renderPromise.then === 'function') {
                            renderPromise.then(result => {
                                finalizeTooltip();
                                if (result?.imageId && locationHint) {
                                    locationHint.textContent = location.description ? 'Hover over the location image for a description.' : 'No description available for this location yet.';
                                }
                                const imageUrl = result?.imageUrl || (result?.imageId ? `/generated-images/${result.imageId}.png` : null);
                                updateAdventureBackground(imageUrl);
                            }).catch(() => {
                                finalizeTooltip();
                                if (locationHint) {
                                    locationHint.textContent = 'Image unavailable.';
                                }
                                updateAdventureBackground(null);
                            });
                        } else {
                            const fallbackUrl = location.imageId ? `/generated-images/${location.imageId}.png` : null;
                            updateAdventureBackground(fallbackUrl);
                        }

                        if (locationDescriptionText) {
                            locationImage.setAttribute('aria-label', locationDescriptionText);
                        } else {
                            locationImage.removeAttribute('aria-label');
                        }

                        if (tooltipController && typeof tooltipController.show === 'function') {
                            locationImage.onmouseenter = (event) => {
                                tooltipController.show(locationDescriptionHtml, event, { allowHTML: true });
                            };
                            locationImage.onmousemove = (event) => {
                                tooltipController.move(event);
                            };
                            locationImage.onmouseleave = () => {
                                tooltipController.hide();
                            };
                        } else {
                            locationImage.onmouseenter = null;
                            locationImage.onmousemove = null;
                            locationImage.onmouseleave = null;
                        }
                    }

                    if (newExitButton) {
                        newExitButton.disabled = false;
                    }
                    if (addNpcButton) {
                        addNpcButton.disabled = false;
                    }
                    if (addThingButton) {
                        addThingButton.disabled = false;
                    }
                    if (craftSceneryButton) {
                        craftSceneryButton.disabled = false;
                    }
                    if (craftItemButton) {
                        craftItemButton.disabled = false;
                    }
                    if (craftSceneryButton) {
                        craftSceneryButton.disabled = false;
                    }
                    if (locationExitsList) {
                        const rawExitEntries = Object.entries(location.exits || {});
                        if (rawExitEntries.length === 0) {
                            locationExitsList.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                        } else {
                            const currentRegionId = location.regionId
                                || location.stubMetadata?.regionId
                                || null;

                            const localExitEntries = [];
                            const regionExitEntries = [];

                            rawExitEntries.forEach(([key, exit]) => {
                                if (!exit || !exit.destination) {
                                    return;
                                }

                                console.log(exit);

                                const destinationRegionId = exit.destinationRegion || null;
                                const regionMatchesCurrent = Boolean(destinationRegionId && currentRegionId && destinationRegionId === currentRegionId);

                                const isRegionExit = Boolean(destinationRegionId && !regionMatchesCurrent);
                                const targetList = isRegionExit ? regionExitEntries : localExitEntries;
                                targetList.push({ key, exit, destinationRegionId, isRegionExit });
                            });

                            const orderedExitEntries = [...localExitEntries, ...regionExitEntries];

                            if (!orderedExitEntries.length) {
                                locationExitsList.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                            } else {
                                locationExitsList.innerHTML = '';
                                orderedExitEntries.forEach(({ key, exit, destinationRegionId, isRegionExit }) => {
                                    const exitId = typeof exit.id === 'string' && exit.id.trim() ? exit.id.trim() : null;
                                    const container = document.createElement('div');
                                    container.className = 'exit-item';
                                    container.dataset.direction = key;
                                    if (exitId) {
                                        container.dataset.exitId = exitId;
                                    }

                                    const travelButton = document.createElement('button');
                                    travelButton.type = 'button';
                                    travelButton.className = 'exit-button';
                                    const destinationName = resolveDestinationNameStrict(exit);
                                    const isVehicle = Boolean(exit.isVehicle);
                                    const vehiclePrefix = isVehicle
                                        ? `${exit.vehicleType ? `${exit.vehicleType}` : 'Vehicle'} to `
                                        : '';

                                    if (isRegionExit || exit.destinationIsRegionEntryStub) {
                                        travelButton.classList.add('region-exit');
                                        const regionName = (typeof exit.destinationRegionName === 'string' && exit.destinationRegionName.trim())
                                            ? exit.destinationRegionName.trim()
                                            : destinationName;
                                        const locationName = destinationName;
                                        if (exit.destinationRegionExpanded) {
                                            travelButton.textContent = `${vehiclePrefix}${regionName}: ${locationName}`;
                                            travelButton.classList.add('region-exit-expanded');
                                        } else {
                                            travelButton.textContent = `${vehiclePrefix}Unexplored Region: ${regionName}`;
                                            travelButton.classList.add('region-exit-unexplored');
                                        }
                                        if (destinationRegionId) {
                                            travelButton.dataset.regionId = destinationRegionId;
                                        }
                                    } else {
                                        travelButton.textContent = destinationName;
                                    }

                                    travelButton.dataset.destinationId = exit.destination;
                                    const destinationIsStub = Boolean(exit.destinationIsStub);
                                    const isExplored = !destinationIsStub && (!isRegionExit || Boolean(exit.destinationRegionExpanded));
                                    travelButton.classList.add(isExplored ? 'exit-button--explored' : 'exit-button--unexplored');
                                    travelButton.addEventListener('click', () => moveToLocation({
                                        exit,
                                        direction: key,
                                        originLocationId: location.id
                                    }));
                                    container.appendChild(travelButton);

                                    if (exitId) {
                                        const friendlyName = destinationName;

                                        const editButton = document.createElement('button');
                                        editButton.type = 'button';
                                        editButton.className = 'exit-edit-button';
                                        editButton.textContent = '‚úèÔ∏è';
                                        editButton.setAttribute('aria-label', `Edit exit: ${friendlyName}`);
                                        editButton.title = `Edit exit: ${friendlyName}`;

                                        editButton.addEventListener('click', (event) => {
                                            event.preventDefault();
                                            event.stopPropagation();
                                            openNewExitModal({
                                                mode: 'edit',
                                                exit: { ...exit },
                                                exitId,
                                                direction: key,
                                                locationId: location.id
                                            });
                                        });

                                        container.appendChild(editButton);

                                        const deleteButton = document.createElement('button');
                                        deleteButton.type = 'button';
                                        deleteButton.className = 'exit-delete-button';
                                        deleteButton.textContent = 'üóëÔ∏è';

                                        deleteButton.setAttribute('aria-label', `Delete exit: ${friendlyName}`);
                                        deleteButton.title = `Delete exit: ${friendlyName}`;

                                        deleteButton.addEventListener('click', async (event) => {
                                            event.preventDefault();
                                            event.stopPropagation();

                                            const confirmed = window.confirm(`Delete exit "${friendlyName}"? This cannot be undone.`);
                                            if (!confirmed) {
                                                return;
                                            }

                                            deleteButton.disabled = true;
                                            try {
                                                const response = await fetch(`/api/locations/${encodeURIComponent(location.id)}/exits/${encodeURIComponent(exitId)}`, {
                                                    method: 'DELETE',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({ clientId: window.AIRPG_CLIENT_ID || null })
                                                });
                                                const data = await response.json().catch(() => null);
                                                if (!response.ok || !data?.success) {
                                                    throw new Error(data?.error || `HTTP ${response.status}`);
                                                }
                                                if (data.location && typeof window.updateLocationDisplay === 'function') {
                                                    await window.updateLocationDisplay(data.location);
                                                }
                                            } catch (error) {
                                                console.warn('Failed to delete exit:', error);
                                                alert(`Failed to delete exit: ${error.message || error}`);
                                            } finally {
                                                deleteButton.disabled = false;
                                            }
                                        });

                                        container.appendChild(deleteButton);
                                    }

                                    locationExitsList.appendChild(container);
                                });
                            }
                        }
                    }

                    if (locationNPCs) {
                        const npcs = Array.isArray(location.npcs) ? location.npcs : [];
                        if (npcs.length === 0) {
                            locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                        } else {
                            locationNPCs.innerHTML = '';
                            npcs.forEach(npc => {
                                const previous = npc?.id ? npcDataCache.get(npc.id) : null;

                                const card = document.createElement('div');
                                card.className = 'location-entity-card is-npc';

                                const portrait = document.createElement('div');
                                portrait.className = 'location-entity-icon';

                                const portraitImage = document.createElement('div');
                                portraitImage.className = 'location-entity-image';
                                portrait.appendChild(portraitImage);

                                const { bar: npcHealthBar, fill: npcHealthFill } = createHealthBar('npc-health-bar');
                                npcHealthFill.classList.add('npc-health-bar-fill');
                                portrait.appendChild(npcHealthBar);

                                const npcNeedBars = document.createElement('div');
                                npcNeedBars.className = 'npc-need-bars need-bars';
                                portrait.appendChild(npcNeedBars);

                                renderEntityImage({
                                    element: portraitImage,
                                    entityType: npc.isNPC ? 'npc' : 'player',
                                    entityId: npc.id,
                                    imageId: npc.imageId || null,
                                    altText: npc.name || 'NPC portrait',
                                    placeholderIcon: 'üé≠',
                                    placeholderClass: 'location-entity-placeholder'
                                });

                                if (npcHealthBar) {
                                    if (npc?.name) {
                                        npcHealthBar.setAttribute('aria-label', `${npc.name} health`);
                                    } else {
                                        npcHealthBar.removeAttribute('aria-label');
                                    }
                                }

                                updateHealthBar(npcHealthBar, npcHealthFill, npc?.health, npc?.maxHealth);

                                renderNeedBars(
                                    npcNeedBars,
                                    Array.isArray(npc?.needBars) ? npc.needBars : [],
                                    {
                                        includePlayerOnly: false,
                                        variant: 'npc',
                                        compact: true
                                    }
                                );

                                applyNpcDeathStyling(card, portrait, npc);

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = npc.name || 'Unknown NPC';
                                if (npc.isHostileToPlayer) {
                                    nameEl.classList.add('is-hostile');
                                }

                                card.appendChild(portrait);
                                card.appendChild(nameEl);
                                const npcDescriptionText = (npc.description || 'No description provided.')
                                    .replace(/<[^>]+>/g, ' ')
                                    .replace(/\s+/g, ' ')
                                    .trim() || 'No description provided.';
                                if (npcDescriptionText) {
                                    card.setAttribute('aria-label', npcDescriptionText);
                                }
                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        tooltipController.show(npcDescriptionText, event);
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }

                                registerNpcPartyDragSource(card, npc, 'location');

                                locationNPCs.appendChild(card);

                                if (npc && npc.id) {
                                    const partyIds = Array.isArray(window.currentPlayerData?.partyMembers)
                                        ? window.currentPlayerData.partyMembers
                                        : null;
                                    if (partyIds) {
                                        npc.isInPlayerParty = partyIds.includes(npc.id);
                                    }
                                    if (typeof registerNpcContextMenu === 'function') {
                                        registerNpcContextMenu(card, npc);
                                    }
                                    triggerHealthChangeEffect(portrait, previous, npc);
                                    npcDataCache.set(npc.id, cloneActorRecord(npc) || { ...npc });
                                    if (typeof window.registerInventoryDropTarget === 'function') {
                                        window.registerInventoryDropTarget(card, { ownerId: npc.id, ownerType: 'npc' });
                                    }
                                }
                            });
                        }
                    }

                    if (locationScenery || locationItems) {
                        const things = await maybeLoadThingDetails(location);
                        const sceneryThings = things.filter(thing => thing.thingType === 'scenery');
                        const itemThings = things.filter(thing => thing.thingType !== 'scenery');

                        const renderThingCollection = (container, collection, emptyMessage) => {
                            if (!container) {
                                return;
                            }
                            if (!collection.length) {
                                container.innerHTML = `<div class="location-thing-empty">${emptyMessage}</div>`;
                                return;
                            }

                            container.innerHTML = '';
                            collection.forEach(thing => {
                                const card = document.createElement('div');
                                card.className = `location-entity-card ${thing.thingType === 'scenery' ? 'is-scenery' : 'is-item'}`;

                                const icon = document.createElement('div');
                                icon.className = 'location-entity-icon';
                                const placeholderIcon = thing.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ';
                                renderEntityImage({
                                    element: icon,
                                    entityType: 'thing',
                                    entityId: thing.id,
                                    imageId: thing.imageId || null,
                                    altText: thing.name || 'Location item',
                                    placeholderIcon,
                                    placeholderClass: 'location-entity-placeholder',
                                    badges: getThingPropertyBadges(thing)
                                });

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = thing.name || 'Unknown Object';
                                applyRarityClass(nameEl, thing.rarity);

                                card.appendChild(icon);
                                card.appendChild(nameEl);

                                registerThingContextMenu(card, thing, { context: 'location', locationId: location.id });

                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        const tooltipContent = formatThingTooltip(thing);
                                        tooltipController.show(tooltipContent, event, { allowHTML: true });
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }

                                if (thing.thingType !== 'scenery' && thing.id) {
                                    card.draggable = true;
                                    card.dataset.thingId = thing.id;
                                    card.addEventListener('dragstart', () => {
                                        draggedLocationThing = {
                                            id: thing.id,
                                            locationId: location.id || null,
                                            element: card,
                                            thing
                                        };
                                        card.classList.add('is-dragging');
                                    });
                                    card.addEventListener('dragend', () => {
                                        card.classList.remove('is-dragging');
                                        // Do not reset draggedLocationThing here; drop handler will handle cleanup
                                    });
                                }

                                container.appendChild(card);
                            });
                        };

                        renderThingCollection(locationScenery, sceneryThings, 'No notable scenery present.');
                        renderThingCollection(locationItems, itemThings, 'No notable items present.');
                    }

                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}

                    hideLocationOverlay();
                    const locationSnapshot = location ? JSON.parse(JSON.stringify(location)) : null;
                    lastRenderedLocation = locationSnapshot;
                    try {
                        window.AIRPG_LAST_LOCATION_ID = locationSnapshot?.id || null;
                        window.AIRPG_LAST_LOCATION = locationSnapshot
                            ? JSON.parse(JSON.stringify(locationSnapshot))
                            : null;
                    } catch (_) {
                        // Ignore failures to persist location snapshot globally
                    }
                } else {
                    locationName.textContent = 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = 'Your current location will appear here when you start exploring.';
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        locationHint.textContent = 'Hover over the location image for a description.';
                    }
                    locationLevel.textContent = 'Level: ?';
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        locationImage.innerHTML = locationImageGenerationEnabled
                            ? '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>'
                            : '<div class="location-placeholder"></div>';
                        if (existingTooltip) {
                            locationImage.appendChild(existingTooltip);
                        }
                        locationImage.removeAttribute('aria-label');
                        locationImage.onmouseenter = null;
                        locationImage.onmousemove = null;
                        locationImage.onmouseleave = null;
                    }
                    if (locationNPCs) {
                        locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                    }
                    if (locationScenery) {
                        locationScenery.innerHTML = '<div class="location-thing-empty">No notable scenery present.</div>';
                    }
                    if (locationItems) {
                        locationItems.innerHTML = '<div class="location-thing-empty">No notable items present.</div>';
                    }
                    if (locationExitsList) {
                        locationExitsList.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                    }
                    if (newExitButton) {
                        newExitButton.disabled = true;
                    }
                    if (addNpcButton) {
                        addNpcButton.disabled = true;
                    }
                    if (addThingButton) {
                        addThingButton.disabled = true;
                    }
                    if (craftSceneryButton) {
                        craftSceneryButton.disabled = true;
                    }
                    if (craftItemButton) {
                        craftItemButton.disabled = true;
                    }
                    if (craftSceneryButton) {
                        craftSceneryButton.disabled = true;
                    }
                    npcDataCache.clear();
                    closeNpcContextMenu();
                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}
                    hideLocationOverlay();
                    lastRenderedLocation = null;
                    try {
                        window.AIRPG_LAST_LOCATION_ID = null;
                        window.AIRPG_LAST_LOCATION = null;
                    } catch (_) {
                        // Ignore failures to clear location snapshot
                    }
                    updateAdventureBackground(null);
                }
            };

            document.addEventListener('floatingTooltip:ready', () => {
                if (lastRenderedLocation) {
                    window.updateLocationDisplay(lastRenderedLocation);
                }
            });

            async function moveToLocation(moveRequest) {
                const exit = moveRequest?.exit;
                if (!exit || !exit.destination) {
                    return;
                }

                const originLocationId = (moveRequest && typeof moveRequest.originLocationId === 'string')
                    ? moveRequest.originLocationId
                    : null;
                const directionKey = (moveRequest && typeof moveRequest.direction === 'string' && moveRequest.direction.trim())
                    ? moveRequest.direction.trim()
                    : null;

                const destinationName = resolveDestinationNameStrict(exit);
                const regionName = exit.destinationRegion
                    ? (typeof exit.destinationRegionName === 'string' ? exit.destinationRegionName.trim() || null : null)
                    : null;
                const playerName = (window.currentPlayerData?.name || '').toString().trim();
                if (!playerName) {
                    throw new Error('Player name is missing when preparing travel narration for exit traversal.');
                }

                let message = `${playerName} moved to ${destinationName}.`;

                let overlayShown = false;
                const showMoveOverlay = () => {
                    if (!overlayShown) {
                        overlayShown = true;
                        showLocationOverlay(`Moving to ${destinationName}...`);
                    }
                };

        const useEventMove = shouldUseEventMove(exit);

        if (useEventMove) {
            showMoveOverlay();
            if (!window.AIRPG_CHAT || typeof window.AIRPG_CHAT.dispatchAutomatedMessage !== 'function') {
                        console.error('AIRPG chat client not available; cannot dispatch move command.');
                        hideLocationOverlay();
                        alert('Unable to queue move command via chat.');
                        return;
                    }

                    const travelMetadata = {
                        mode: 'event',
                        eventDriven: true,
                        exit: {
                            exitId: (typeof exit.id === 'string' && exit.id.trim()) ? exit.id.trim() : null,
                            originLocationId: originLocationId || null,
                            direction: directionKey,
                            destinationId: exit.destination || null,
                            destinationRegionId: exit.destinationRegion || null,
                            destinationIsStub: Boolean(exit.destinationIsStub),
                            destinationIsRegionEntryStub: Boolean(exit.destinationIsRegionEntryStub),
                            isVehicle: Boolean(exit.isVehicle),
                            vehicleType: typeof exit.vehicleType === 'string' ? exit.vehicleType.trim() : null,
                            destinationName,
                            regionName
                        }
                    };
                    try {
                        showMoveOverlay();
                        await window.AIRPG_CHAT.dispatchAutomatedMessage(message, {
                            travel: true,
                            travelMetadata
                        });
                    } catch (error) {
                        console.error('Failed to dispatch move via chat:', error);
                        hideLocationOverlay();
                        alert('Failed to queue move command via chat.');
                    }
            return;
        } 

        if (window.AIRPG_CHAT && typeof window.AIRPG_CHAT.dispatchAutomatedMessage === 'function') {
            try {
                showMoveOverlay();
                await window.AIRPG_CHAT.dispatchAutomatedMessage(`# ${message}`, { travel: true });
            } catch (error) {
                console.error('Failed to dispatch move via chat:', error);
                hideLocationOverlay();
                alert('Failed to queue move command via chat.');
                return;
            }
        }

        await performDirectMove(exit.destination, destinationName);
    }

            async function performDirectMove(destinationId, destinationName) {
                if (!destinationId) {
                    return;
                }

                const resolvedDestinationName = (destinationName && destinationName.toString().trim()) || null;
                if (!resolvedDestinationName) {
                    throw new Error('Destination name is required for direct move.');
                }

                showLocationOverlay(`Moving to ${resolvedDestinationName}...`);
                try {
                    const response = await fetch('/api/player/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ destinationId })
                    });

                    const result = await response.json();
                    if (result.success && result.location) {
                        if (typeof result.location.name === 'string' && result.location.name.trim()) {
                            locationCache[result.location.id] = result.location.name.trim();
                        }
                        if (Array.isArray(result.location.exits)) {
                            result.location.exits.forEach(exit => {
                                if (exit.destination && typeof exit.destinationName === 'string' && exit.destinationName.trim()) {
                                    locationCache[exit.destination] = exit.destinationName.trim();
                                }
                            });
                        } else if (result.location.exits) {
                            Object.values(result.location.exits).forEach(exit => {
                                if (exit?.destination && typeof exit.destinationName === 'string' && exit.destinationName.trim()) {
                                    locationCache[exit.destination] = exit.destinationName.trim();
                                }
                            });
                        }
                        await window.updateLocationDisplay(result.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    } else if (result.error) {
                        hideLocationOverlay();
                        alert(`Move failed: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Move failed:', error);
                    hideLocationOverlay();
                    alert(`Move failed: ${error.message}`);
                }
            }

            function collectExitEntries(location) {
                if (!location || !location.exits) {
                    return [];
                }
                const exits = location.exits;
                if (Array.isArray(exits)) {
                    return exits
                        .map((exit, index) => [String(index), exit])
                        .filter(([, exit]) => Boolean(exit));
                }
                if (exits instanceof Map) {
                    return Array.from(exits.entries()).filter(([, exit]) => Boolean(exit));
                }
                if (typeof exits === 'object') {
                    return Object.entries(exits).filter(([, exit]) => Boolean(exit));
                }
                return [];
            }

            function findExitForDestination(location, destinationId) {
                if (!location || !destinationId) {
                    return null;
                }
                const entries = collectExitEntries(location);
                for (const [direction, exit] of entries) {
                    if (exit?.destination === destinationId) {
                        return { direction, exit };
                    }
                }
                return null;
            }

            async function travelToAdjacentLocationFromMap(destinationId, { focusAdventureTab = true } = {}) {
                if (!destinationId) {
                    return false;
                }
                if (lastRenderedLocation?.id === destinationId) {
                    if (focusAdventureTab && typeof window.activateTab === 'function') {
                        window.activateTab('adventure');
                    }
                    return false;
                }

                let destinationName = null;
                let destinationRegionName = null;

                if (lastRenderedLocation && lastRenderedLocation.id) {
                    const match = findExitForDestination(lastRenderedLocation, destinationId);
                    if (match) {
                        try {
                            destinationName = resolveDestinationNameStrict(match.exit);
                        } catch (_) {
                            destinationName = null;
                        }
                        if (match.exit?.destinationRegionName) {
                            destinationRegionName = match.exit.destinationRegionName.trim() || null;
                        }
                    }
                }
                if (!destinationName) {
                    const details = await ensureLocationNameCached(destinationId);
                    destinationName = details?.name || `Location ${destinationId}`;
                    destinationRegionName = destinationRegionName || details?.regionName || null;
                }
                if (!destinationRegionName) {
                    destinationRegionName = 'Unknown Region';
                }

                const playerRecord = (window.currentPlayerData && window.currentPlayerData.id)
                    ? window.currentPlayerData
                    : null;
                if (!playerRecord || !playerRecord.id) {
                    alert('Player information is unavailable; cannot travel.');
                    return false;
                }

                const playerName = (playerRecord.name || '').toString().trim();
                if (!playerName) {
                    alert('Player name is missing; cannot travel.');
                    return false;
                }

                const message = `${playerName} traveled to ${destinationName} in ${destinationRegionName}.`;
                let overlayVisible = false;
                const showMoveOverlay = () => {
                    if (!overlayVisible) {
                        overlayVisible = true;
                        showLocationOverlay(`Moving to ${destinationName}...`);
                    }
                };

                try {
                    showMoveOverlay();

                    if (window.AIRPG_CHAT && typeof window.AIRPG_CHAT.dispatchAutomatedMessage === 'function') {
                        try {
                            await window.AIRPG_CHAT.dispatchAutomatedMessage(`# ${message}`, { travel: true });
                        } catch (chatError) {
                            console.warn('Failed to log travel message:', chatError);
                        }
                    }

                    await teleportNpcToLocation(playerRecord, destinationId, {
                        originLocationId: lastRenderedLocation?.id || null
                    });

                    if (focusAdventureTab && typeof window.activateTab === 'function') {
                        window.activateTab('adventure');
                    }

                    const mapTab = document.querySelector('[data-tab="map"]');
                    if (mapTab && mapTab.classList.contains('active')) {
                        const mapContainer = document.getElementById('mapContainer');
                        const activeRegionId = mapContainer?.dataset?.regionId || null;
                        try {
                            await window.loadRegionMap?.(activeRegionId || null);
                        } catch (mapError) {
                            console.warn('Failed to refresh map after teleport:', mapError);
                        }
                    }

                    return true;
                } catch (error) {
                    console.warn('Failed to travel via map:', error);
                    alert(`Failed to travel: ${error?.message || error}`);
                    return false;
                } finally {
                    if (overlayVisible) {
                        hideLocationOverlay();
                    }
                }
            }

            window.travelToAdjacentLocationFromMap = travelToAdjacentLocationFromMap;

            // Load current player location on page load
            showLocationOverlay('Loading current location...');
            loadCurrentLocation().finally(() => hideLocationOverlay());
        }

        function initFloatingTooltipController() {
            const floatingTooltip = document.getElementById('inventoryTooltip');

            if (!floatingTooltip) {
                window.floatingTooltipController = null;
                return;
            }

            const hideTooltip = () => {
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            };

            const positionTooltip = (event) => {
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            };

            const controller = {
                show(content, event, options = {}) {
                    if (!content || !event) {
                        return;
                    }
                    const { allowHTML = false } = options;
                    if (allowHTML) {
                        floatingTooltip.innerHTML = content;
                    } else {
                        floatingTooltip.textContent = content;
                    }
                    floatingTooltip.removeAttribute('hidden');
                    floatingTooltip.classList.add('visible');
                    positionTooltip(event);
                },
                move(event) {
                    if (floatingTooltip.hasAttribute('hidden')) {
                        return;
                    }
                    positionTooltip(event);
                },
                hide() {
                    hideTooltip();
                }
            };

            window.floatingTooltipController = controller;

            floatingTooltip.addEventListener('mouseleave', hideTooltip);
            window.addEventListener('scroll', hideTooltip, { passive: true });

            try {
                document.dispatchEvent(new CustomEvent('floatingTooltip:ready'));
            } catch (_) {
                // CustomEvent may not be available in older environments; ignore.
            }
        }

        function initQuestPanel() {
            const activeContainer = document.getElementById('questAccordion');
            const completedContainer = document.getElementById('questCompletedAccordion');
            const emptyActive = document.getElementById('questEmpty');
            const emptyCompleted = document.getElementById('questCompletedEmpty');
            const activeCountBadge = document.getElementById('questActiveCount');
            const completedCountBadge = document.getElementById('questCompletedCount');
            const questEditModal = document.getElementById('questEditModal');
            const questEditBackdrop = document.getElementById('questEditBackdrop');
            const questEditForm = document.getElementById('questEditForm');
            const questEditName = document.getElementById('questEditName');
            const questEditDescription = document.getElementById('questEditDescription');
            const questEditSecretNotes = document.getElementById('questEditSecretNotes');
            const questEditRewardCurrency = document.getElementById('questEditRewardCurrency');
            const questEditRewardXp = document.getElementById('questEditRewardXp');
            const questEditRewardItems = document.getElementById('questEditRewardItems');
            const questEditObjectives = document.getElementById('questEditObjectives');
            const questEditAddObjective = document.getElementById('questEditAddObjective');
            const questEditCancel = document.getElementById('questEditCancel');
            const questEditCloseBtn = document.getElementById('questEditCloseBtn');
            let questBeingEdited = null;

            const toElement = node => (node instanceof HTMLElement ? node : null);
            const activeRoot = toElement(activeContainer);
            const completedRoot = toElement(completedContainer);

            async function handleAbandonQuest(quest, trigger) {
                if (!quest || !quest.id) {
                    return;
                }

                const questName = quest.name || 'this quest';
                const confirmed = window.confirm(`Are you sure you want to abandon "${questName}"? This cannot be undone.`);
                if (!confirmed) {
                    return;
                }

                const button = trigger instanceof HTMLButtonElement ? trigger : null;
                const originalLabel = button ? button.textContent : null;
                if (button) {
                    button.disabled = true;
                    button.textContent = 'Abandoning...';
                }

                try {
                    const response = await fetch(`/api/player/quests/${encodeURIComponent(quest.id)}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    const result = await response.json().catch(() => ({}));
                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to abandon quest.');
                    }
                    await refreshQuestPanel();
                } catch (error) {
                    console.error('Failed to abandon quest:', error);
                    window.alert(`Failed to abandon quest: ${error.message || error}`);
                    if (button) {
                        button.disabled = false;
                        button.textContent = originalLabel || 'Abandon Quest';
                    }
                }
            }

            async function handleToggleQuestPause(quest, trigger) {
                if (!quest || !quest.id) {
                    return;
                }

                const isPaused = Boolean(quest.paused);
                const nextPaused = !isPaused;
                const button = trigger instanceof HTMLButtonElement ? trigger : null;
                const originalLabel = button ? button.textContent : null;
                if (button) {
                    button.disabled = true;
                    button.textContent = nextPaused ? 'Pausing...' : 'Resuming...';
                }

                try {
                    const response = await fetch('/api/quest/edit', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            questId: quest.id,
                            paused: nextPaused
                        })
                    });
                    const result = await response.json().catch(() => ({}));
                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to update quest.');
                    }
                    await refreshQuestPanel();
                } catch (error) {
                    console.error('Failed to toggle quest pause:', error);
                    window.alert(`Failed to update quest: ${error.message || error}`);
                    if (button) {
                        button.disabled = false;
                        button.textContent = originalLabel || (isPaused ? 'Resume' : 'Pause');
                    }
                }
            }

            const closeQuestEditModal = () => {
                questBeingEdited = null;
                if (questEditForm) {
                    questEditForm.reset();
                }
                if (questEditObjectives) {
                    questEditObjectives.innerHTML = '';
                }
                if (questEditModal) {
                    questEditModal.setAttribute('hidden', '');
                    questEditModal.setAttribute('aria-hidden', 'true');
                }
                if (questEditBackdrop) {
                    questEditBackdrop.setAttribute('hidden', '');
                }
            };

            const addObjectiveRow = (objective = {}) => {
                if (!questEditObjectives) return;
                const row = document.createElement('div');
                row.className = 'quest-edit-objective-row';
                if (objective.id) {
                    row.dataset.id = objective.id;
                }

                const descInput = document.createElement('input');
                descInput.type = 'text';
                descInput.placeholder = 'Objective description';
                descInput.value = objective.description || '';
                descInput.required = true;

                const flags = document.createElement('div');
                flags.className = 'quest-edit-flags';

                const optionalLabel = document.createElement('label');
                optionalLabel.className = 'quest-edit-flag';
                const optionalCheckbox = document.createElement('input');
                optionalCheckbox.type = 'checkbox';
                optionalCheckbox.checked = Boolean(objective.optional);
                optionalLabel.appendChild(optionalCheckbox);
                optionalLabel.appendChild(document.createTextNode('Optional'));

                const completedLabel = document.createElement('label');
                completedLabel.className = 'quest-edit-flag';
                const completedCheckbox = document.createElement('input');
                completedCheckbox.type = 'checkbox';
                completedCheckbox.checked = Boolean(objective.completed);
                completedLabel.appendChild(completedCheckbox);
                completedLabel.appendChild(document.createTextNode('Completed'));

                flags.appendChild(optionalLabel);
                flags.appendChild(completedLabel);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn btn-link btn-sm';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', () => {
                    row.remove();
                });

                row.appendChild(descInput);
                row.appendChild(flags);
                row.appendChild(removeBtn);
                questEditObjectives.appendChild(row);
            };

            const openQuestEditModal = (quest = {}) => {
                if (!questEditModal || !questEditForm) {
                    return;
                }
                questBeingEdited = quest;
                questEditModal.removeAttribute('hidden');
                questEditModal.setAttribute('aria-hidden', 'false');
                if (questEditBackdrop) {
                    questEditBackdrop.removeAttribute('hidden');
                }

                if (questEditName) questEditName.value = quest.name || '';
                if (questEditDescription) questEditDescription.value = quest.description || '';
                if (questEditSecretNotes) questEditSecretNotes.value = quest.secretNotes || '';
                if (questEditRewardCurrency) questEditRewardCurrency.value = Number(quest.rewardCurrency) || 0;
                if (questEditRewardXp) questEditRewardXp.value = Number(quest.rewardXp) || 0;
                if (questEditRewardItems) {
                    const items = Array.isArray(quest.rewardItems) ? quest.rewardItems : [];
                    questEditRewardItems.value = items.join(', ');
                }

                if (questEditObjectives) {
                    questEditObjectives.innerHTML = '';
                    if (Array.isArray(quest.objectives) && quest.objectives.length) {
                        quest.objectives.forEach(obj => addObjectiveRow(obj));
                    } else {
                        addObjectiveRow();
                    }
                }
            };

            const createQuestCard = (quest, { defaultOpen = false, compact = false, allowAbandon = false } = {}) => {
                const details = document.createElement('details');
                details.className = 'quest-card';
                if (defaultOpen) {
                    details.open = true;
                }
                const isPaused = Boolean(quest?.paused);
                if (isPaused) {
                    details.classList.add('quest-card--paused');
                }

                const summary = document.createElement('summary');

                const titleGroup = document.createElement('div');
                titleGroup.className = 'quest-title-group';

                const title = document.createElement('h3');
                title.className = 'quest-title';
                title.textContent = quest.name || 'Unnamed Quest';
                titleGroup.appendChild(title);

                const meta = document.createElement('div');
                meta.className = 'quest-meta';

                const objectives = Array.isArray(quest.objectives) ? quest.objectives.filter(Boolean) : [];
                const objectiveCount = objectives.length;
                const completedObjectives = objectives.filter(obj => obj.completed === true).length;
                if (objectiveCount > 0) {
                    const objectiveChip = document.createElement('span');
                    objectiveChip.className = 'quest-objective-chip';
                    const label = completedObjectives === objectiveCount
                        ? 'All objectives complete'
                        : `${completedObjectives}/${objectiveCount} complete`;
                    objectiveChip.textContent = label;
                    meta.appendChild(objectiveChip);
                }

                const rewardCurrency = Number.isFinite(quest.rewardCurrency) ? Math.max(0, quest.rewardCurrency) : 0;
                const rewardXp = Number.isFinite(quest.rewardXp) ? Math.max(0, quest.rewardXp) : 0;
                const rewardItems = Array.isArray(quest.rewardItems) ? quest.rewardItems.filter(Boolean) : [];
                const rewardParts = [];
                if (rewardCurrency > 0) rewardParts.push(`${rewardCurrency} gold`);
                if (rewardXp > 0) rewardParts.push(`${rewardXp} XP`);
                if (rewardItems.length) rewardParts.push(`${rewardItems.length} item${rewardItems.length === 1 ? '' : 's'}`);

                if (rewardParts.length) {
                    const rewardChip = document.createElement('span');
                    rewardChip.className = 'quest-reward-chip';
                    rewardChip.textContent = rewardParts.join(' ‚Ä¢ ');
                    meta.appendChild(rewardChip);
                }

                if (isPaused) {
                    const pausedChip = document.createElement('span');
                    pausedChip.className = 'quest-paused-chip';
                    pausedChip.textContent = 'Paused';
                    meta.appendChild(pausedChip);
                }

                if (meta.childElementCount) {
                    titleGroup.appendChild(meta);
                }

                summary.appendChild(titleGroup);

                const toggleIcon = document.createElement('span');
                toggleIcon.className = 'quest-toggle-icon';
                toggleIcon.innerHTML = '&rsaquo;';
                summary.appendChild(toggleIcon);

                const content = document.createElement('div');
                content.className = 'quest-content';

                if (quest.giver) {
                    const giver = document.createElement('div');
                    giver.className = 'quest-giver';
                    giver.textContent = `Quest giver: ${quest.giver}`;
                    content.appendChild(giver);
                }

                const summaryCopy = quest.summary || '';
                const descriptionCopy = quest.description && quest.description !== summaryCopy ? quest.description : summaryCopy;
                if (descriptionCopy) {
                    const description = document.createElement('p');
                    description.className = 'quest-description';
                    description.textContent = descriptionCopy;
                    content.appendChild(description);
                }

                if (objectives.length) {
                    const objectiveSection = document.createElement('div');
                    objectiveSection.className = 'quest-objectives';
                    const heading = document.createElement('h4');
                    heading.textContent = 'Objectives';
                    objectiveSection.appendChild(heading);

                    const list = document.createElement('ul');
                    list.className = 'quest-objective-list';
                    objectives.forEach(obj => {
                        const item = document.createElement('li');
                        const marker = document.createElement('span');
                        marker.className = obj.completed
                            ? 'quest-objective-marker quest-objective-marker--complete'
                            : 'quest-objective-marker quest-objective-marker--pending';
                        marker.textContent = obj.completed ? '‚úî' : '‚óã';
                        item.appendChild(marker);

                        const text = document.createElement('span');
                        const label = obj.description || 'Objective';
                        text.textContent = obj.optional ? `${label} (optional)` : label;
                        item.appendChild(text);
                        list.appendChild(item);
                    });
                    objectiveSection.appendChild(list);
                    content.appendChild(objectiveSection);
                }

                if (rewardParts.length || rewardItems.length) {
                    const rewardSection = document.createElement('div');
                    rewardSection.className = 'quest-rewards';
                    const heading = document.createElement('h4');
                    heading.textContent = 'Rewards';
                    rewardSection.appendChild(heading);

                    const list = document.createElement('ul');
                    list.className = 'quest-reward-list';
                    if (rewardCurrency > 0) {
                        const currencyItem = document.createElement('li');
                        currencyItem.textContent = `${rewardCurrency} gold`;
                        list.appendChild(currencyItem);
                    }
                    if (rewardXp > 0) {
                        const xpItem = document.createElement('li');
                        xpItem.textContent = `${rewardXp} experience`;
                        list.appendChild(xpItem);
                    }
                    rewardItems.forEach(label => {
                        const item = document.createElement('li');
                        item.textContent = label;
                        list.appendChild(item);
                    });

                    rewardSection.appendChild(list);
                    content.appendChild(rewardSection);
                }

                if (allowAbandon && quest?.id) {
                    const actions = document.createElement('div');
                    actions.className = 'quest-actions';

                    const abandonButton = document.createElement('button');
                    abandonButton.type = 'button';
                    abandonButton.className = 'quest-abandon-button';
                    abandonButton.textContent = 'Abandon Quest';
                    abandonButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        handleAbandonQuest(quest, event.currentTarget);
                    });

                    const editButton = document.createElement('button');
                    editButton.type = 'button';
                    editButton.className = 'quest-abandon-button quest-edit-button';
                    editButton.textContent = 'Edit';
                    editButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        openQuestEditModal(quest);
                    });

                    const pauseButton = document.createElement('button');
                    pauseButton.type = 'button';
                    pauseButton.className = 'quest-abandon-button quest-pause-button';
                    pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
                    pauseButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        handleToggleQuestPause(quest, event.currentTarget);
                    });

                    actions.appendChild(editButton);
                    actions.appendChild(pauseButton);
                    actions.appendChild(abandonButton);
                    content.appendChild(actions);
                }

                details.appendChild(summary);
                details.appendChild(content);

                if (compact) {
                    details.removeAttribute('open');
                }

                return details;
            };

            const renderQuestPanel = (activeQuests = [], completedQuests = []) => {
                const sortByRecency = (quests) => {
                    if (!Array.isArray(quests)) {
                        return [];
                    }

                    const toTime = (value) => {
                        if (!value) {
                            return 0;
                        }
                        const parsed = Date.parse(value);
                        return Number.isFinite(parsed) ? parsed : 0;
                    };

                    return quests
                        .map((quest, idx) => ({
                            quest,
                            idx,
                            updated: toTime(quest?.lastUpdated),
                            created: toTime(quest?.createdAt)
                        }))
                        .sort((a, b) => {
                            if (b.updated !== a.updated) {
                                return b.updated - a.updated;
                            }
                            if (b.created !== a.created) {
                                return b.created - a.created;
                            }
                            return b.idx - a.idx;
                        })
                        .map(entry => entry.quest);
                };

                const sortedActive = sortByRecency(activeQuests);
                const sortedCompleted = sortByRecency(completedQuests);

                if (activeRoot) {
                    activeRoot.innerHTML = '';
                    const activeCount = Array.isArray(sortedActive) ? sortedActive.length : 0;
                    if (activeCountBadge) {
                        activeCountBadge.textContent = String(activeCount);
                    }
                    if (emptyActive) {
                        emptyActive.toggleAttribute('hidden', activeCount > 0);
                    }
                    activeRoot.toggleAttribute('hidden', activeCount === 0);
                    sortedActive.forEach((quest, index) => {
                        const card = createQuestCard(quest || {}, { defaultOpen: index === 0, allowAbandon: true });
                        activeRoot.appendChild(card);
                    });
                }

                if (completedRoot) {
                    completedRoot.innerHTML = '';
                    const completedCount = Array.isArray(sortedCompleted) ? sortedCompleted.length : 0;
                    if (completedCountBadge) {
                        completedCountBadge.textContent = String(completedCount);
                    }
                    if (emptyCompleted) {
                        emptyCompleted.toggleAttribute('hidden', completedCount > 0);
                    }
                    completedRoot.toggleAttribute('hidden', completedCount === 0);
                    sortedCompleted.forEach(quest => {
                        const card = createQuestCard(quest || {}, { compact: true });
                        completedRoot.appendChild(card);
                    });
                }
            };

            async function refreshQuestPanel() {
                try {
                    const response = await fetch('/api/player', { cache: 'no-store' });
                    const data = await response.json();
                    if (data.success && data.player) {
                        renderQuestPanel(data.player.quests || [], data.player.completedQuests || []);
                    }
                } catch (error) {
                    console.warn('Failed to refresh quest log:', error);
                }
            }

            window.renderQuestPanel = renderQuestPanel;
            window.refreshQuestPanel = refreshQuestPanel;
            refreshQuestPanel();

            const gatherObjectives = () => {
                if (!questEditObjectives) {
                    return [];
                }
                const rows = Array.from(questEditObjectives.querySelectorAll('.quest-edit-objective-row'));
                return rows
                    .map(row => {
                        const descriptionInput = row.querySelector('input[type="text"]');
                        const checkboxes = Array.from(row.querySelectorAll('.quest-edit-flag input[type="checkbox"]'));
                        const optionalCheckbox = checkboxes[0] || null;
                        const completedCheckbox = checkboxes[1] || null;
                        const description = descriptionInput ? descriptionInput.value.trim() : '';
                        if (!description) {
                            return null;
                        }
                        return {
                            id: row.dataset.id || undefined,
                            description,
                            optional: optionalCheckbox ? optionalCheckbox.checked : false,
                            completed: completedCheckbox ? completedCheckbox.checked : false
                        };
                    })
                    .filter(Boolean);
            };

            if (questEditAddObjective) {
                questEditAddObjective.addEventListener('click', (event) => {
                    event.preventDefault();
                    addObjectiveRow();
                });
            }

            if (questEditCancel) {
                questEditCancel.addEventListener('click', (event) => {
                    event.preventDefault();
                    closeQuestEditModal();
                });
            }

            if (questEditCloseBtn) {
                questEditCloseBtn.addEventListener('click', (event) => {
                    event.preventDefault();
                    closeQuestEditModal();
                });
            }

            if (questEditBackdrop) {
                questEditBackdrop.addEventListener('click', closeQuestEditModal);
            }

            if (questEditForm) {
                questEditForm.addEventListener('submit', async (event) => {
                    event.preventDefault();
                    if (!questBeingEdited || !questBeingEdited.id) {
                        window.alert('No quest selected to edit.');
                        return;
                    }
                    const objectives = gatherObjectives();
                    const payload = {
                        questId: questBeingEdited.id,
                        name: questEditName ? questEditName.value.trim() : questBeingEdited.name,
                        description: questEditDescription ? questEditDescription.value : questBeingEdited.description,
                        secretNotes: questEditSecretNotes ? questEditSecretNotes.value : questBeingEdited.secretNotes,
                        rewardCurrency: questEditRewardCurrency ? Number(questEditRewardCurrency.value) : questBeingEdited.rewardCurrency,
                        rewardXp: questEditRewardXp ? Number(questEditRewardXp.value) : questBeingEdited.rewardXp,
                        rewardItems: questEditRewardItems ? questEditRewardItems.value : (questBeingEdited.rewardItems || []),
                        objectives
                    };

                    try {
                        const response = await fetch('/api/quest/edit', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const result = await response.json().catch(() => ({}));
                        if (!response.ok || !result?.success) {
                            throw new Error(result?.error || 'Failed to update quest.');
                        }
                        closeQuestEditModal();
                        await refreshQuestPanel();
                    } catch (error) {
                        console.error('Failed to edit quest:', error);
                        window.alert(`Failed to edit quest: ${error.message || error}`);
                    }
                });
            }
        }

        function initFactionPanel() {
            const listEl = document.getElementById('factionList');
            const emptyEl = document.getElementById('factionEmpty');
            const placeholderEl = document.getElementById('factionDetailPlaceholder');
            const formEl = document.getElementById('factionForm');
            const titleEl = document.getElementById('factionDetailTitle');
            const metaEl = document.getElementById('factionDetailMeta');
            const addButton = document.getElementById('factionAddButton');
            const deleteButton = document.getElementById('factionDeleteButton');
            const assetAddButton = document.getElementById('factionAssetAddButton');
            const tierAddButton = document.getElementById('factionTierAddButton');
            const nameInput = document.getElementById('factionName');
            const homeInput = document.getElementById('factionHomeRegion');
            const shortDescriptionInput = document.getElementById('factionShortDescription');
            const descriptionInput = document.getElementById('factionDescription');
            const tagsInput = document.getElementById('factionTags');
            const goalsInput = document.getElementById('factionGoals');
            const assetsList = document.getElementById('factionAssetsList');
            const relationsList = document.getElementById('factionRelationsList');
            const tiersList = document.getElementById('factionTiersList');
            const standingInput = document.getElementById('factionStandingValue');
            const standingTier = document.getElementById('factionStandingTier');

            if (!listEl || !formEl) {
                return;
            }

            const state = {
                factions: [],
                factionMap: new Map(),
                playerStandings: {},
                selectedId: null
            };

            const splitList = (value) => {
                if (typeof value !== 'string') {
                    return [];
                }
                return value
                    .split(/[\n,]+/)
                    .map(entry => entry.trim())
                    .filter(Boolean);
            };

            const joinList = (entries) => {
                if (!Array.isArray(entries)) {
                    return '';
                }
                return entries.join('\n');
            };

            const resolveStandingTierLabel = (value, tiers = []) => {
                if (!Number.isFinite(value)) {
                    return '‚Äî';
                }
                const sorted = Array.isArray(tiers)
                    ? tiers.slice().sort((a, b) => Number(a.threshold) - Number(b.threshold))
                    : [];
                let resolved = null;
                for (const tier of sorted) {
                    const threshold = Number(tier?.threshold);
                    if (!Number.isFinite(threshold)) {
                        continue;
                    }
                    if (value >= threshold) {
                        resolved = tier;
                    } else {
                        break;
                    }
                }
                return resolved?.label || '‚Äî';
            };

            const clearDetail = () => {
                if (placeholderEl) {
                    placeholderEl.removeAttribute('hidden');
                }
                formEl.setAttribute('hidden', '');
                formEl.reset();
                if (assetsList) assetsList.innerHTML = '';
                if (relationsList) relationsList.innerHTML = '';
                if (tiersList) tiersList.innerHTML = '';
                if (standingTier) standingTier.textContent = '‚Äî';
                state.selectedId = null;
            };

            const buildAssetRow = (asset = {}) => {
                const row = document.createElement('div');
                row.className = 'faction-asset-row';

                const nameField = document.createElement('input');
                nameField.type = 'text';
                nameField.placeholder = 'Asset name';
                nameField.value = asset.name || '';
                nameField.className = 'faction-asset-name';

                const typeField = document.createElement('input');
                typeField.type = 'text';
                typeField.placeholder = 'Type';
                typeField.value = asset.type || '';
                typeField.className = 'faction-asset-type';

                const descField = document.createElement('textarea');
                descField.rows = 2;
                descField.placeholder = 'Short description';
                descField.value = asset.description || '';
                descField.className = 'faction-asset-description';

                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.className = 'btn btn-link btn-sm';
                removeButton.textContent = 'Remove';
                removeButton.addEventListener('click', () => row.remove());

                row.appendChild(nameField);
                row.appendChild(typeField);
                row.appendChild(descField);
                row.appendChild(removeButton);
                return row;
            };

            const buildTierRow = (tier = {}) => {
                const row = document.createElement('div');
                row.className = 'faction-tier-row';

                const thresholdField = document.createElement('input');
                thresholdField.type = 'number';
                thresholdField.placeholder = 'Threshold';
                thresholdField.value = Number.isFinite(Number(tier.threshold)) ? tier.threshold : '';
                thresholdField.className = 'faction-tier-threshold';

                const labelField = document.createElement('input');
                labelField.type = 'text';
                labelField.placeholder = 'Label';
                labelField.value = tier.label || '';
                labelField.className = 'faction-tier-label';

                const perksField = document.createElement('textarea');
                perksField.rows = 2;
                perksField.placeholder = 'Perks (one per line)';
                perksField.value = joinList(tier.perks || []);
                perksField.className = 'faction-tier-perks';

                const penaltiesField = document.createElement('textarea');
                penaltiesField.rows = 2;
                penaltiesField.placeholder = 'Penalties (one per line)';
                penaltiesField.value = joinList(tier.penalties || []);
                penaltiesField.className = 'faction-tier-penalties';

                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.className = 'btn btn-link btn-sm';
                removeButton.textContent = 'Remove';
                removeButton.addEventListener('click', () => row.remove());

                row.appendChild(thresholdField);
                row.appendChild(labelField);
                row.appendChild(perksField);
                row.appendChild(penaltiesField);
                row.appendChild(removeButton);
                return row;
            };

            const buildRelationRow = (targetFaction, relation) => {
                const row = document.createElement('div');
                row.className = 'faction-relation-row';
                row.dataset.targetId = targetFaction.id;

                const nameField = document.createElement('div');
                nameField.className = 'faction-relation-name';
                nameField.textContent = targetFaction.name || targetFaction.id;

                const statusField = document.createElement('select');
                statusField.className = 'faction-relation-status';
                const options = [
                    { value: '', label: 'None' },
                    { value: 'allied', label: 'Allied' },
                    { value: 'neutral', label: 'Neutral' },
                    { value: 'hostile', label: 'Hostile' },
                    { value: 'rival', label: 'Rival' }
                ];
                options.forEach(option => {
                    const opt = document.createElement('option');
                    opt.value = option.value;
                    opt.textContent = option.label;
                    statusField.appendChild(opt);
                });
                statusField.value = relation?.status || '';

                const notesField = document.createElement('textarea');
                notesField.rows = 2;
                notesField.placeholder = 'Relationship notes';
                notesField.className = 'faction-relation-notes';
                notesField.value = relation?.notes || '';
                notesField.disabled = !statusField.value;

                statusField.addEventListener('change', () => {
                    const hasStatus = Boolean(statusField.value);
                    notesField.disabled = !hasStatus;
                    if (!hasStatus) {
                        notesField.value = '';
                    }
                });

                const clearButton = document.createElement('button');
                clearButton.type = 'button';
                clearButton.className = 'btn btn-link btn-sm';
                clearButton.textContent = 'Clear';
                clearButton.addEventListener('click', () => {
                    statusField.value = '';
                    notesField.value = '';
                    notesField.disabled = true;
                });

                row.appendChild(nameField);
                row.appendChild(statusField);
                row.appendChild(notesField);
                row.appendChild(clearButton);
                return row;
            };

            const renderList = () => {
                listEl.innerHTML = '';
                if (!Array.isArray(state.factions) || state.factions.length === 0) {
                    if (emptyEl) emptyEl.style.display = 'block';
                    return;
                }
                if (emptyEl) emptyEl.style.display = 'none';
                state.factions.forEach(faction => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'faction-list-item';
                    if (faction.id === state.selectedId) {
                        button.classList.add('active');
                    }
                    const name = document.createElement('div');
                    name.className = 'faction-list-name';
                    name.textContent = faction.name || 'Unnamed Faction';

                    const tags = document.createElement('div');
                    tags.className = 'faction-list-tags';
                    tags.textContent = Array.isArray(faction.tags) && faction.tags.length
                        ? faction.tags.join(' ¬∑ ')
                        : 'No tags';

                    button.appendChild(name);
                    button.appendChild(tags);
                    button.addEventListener('click', () => {
                        state.selectedId = faction.id;
                        renderList();
                        renderDetail();
                    });
                    listEl.appendChild(button);
                });
            };

            const renderDetail = () => {
                const faction = state.factionMap.get(state.selectedId);
                if (!faction) {
                    clearDetail();
                    return;
                }
                if (placeholderEl) {
                    placeholderEl.setAttribute('hidden', '');
                }
                formEl.removeAttribute('hidden');

                if (titleEl) {
                    titleEl.textContent = faction.name || 'Faction';
                }
                if (metaEl) {
                    metaEl.textContent = faction.id ? `ID: ${faction.id}` : '';
                }
                if (nameInput) nameInput.value = faction.name || '';
                if (homeInput) homeInput.value = faction.homeRegionName || '';
                if (shortDescriptionInput) shortDescriptionInput.value = faction.shortDescription || '';
                if (descriptionInput) descriptionInput.value = faction.description || '';
                if (tagsInput) tagsInput.value = joinList(faction.tags || []);
                if (goalsInput) goalsInput.value = joinList(faction.goals || []);

                if (assetsList) {
                    assetsList.innerHTML = '';
                    const assets = Array.isArray(faction.assets) ? faction.assets : [];
                    if (assets.length) {
                        assets.forEach(asset => assetsList.appendChild(buildAssetRow(asset)));
                    } else {
                        assetsList.appendChild(buildAssetRow());
                    }
                }

                if (relationsList) {
                    relationsList.innerHTML = '';
                    const relations = faction.relations && typeof faction.relations === 'object' ? faction.relations : {};
                    const others = state.factions.filter(entry => entry.id !== faction.id);
                    if (others.length === 0) {
                        const empty = document.createElement('div');
                        empty.className = 'faction-relation-empty';
                        empty.textContent = 'No other factions to relate to yet.';
                        relationsList.appendChild(empty);
                    } else {
                        others.forEach(other => {
                            const relation = relations[other.id] || null;
                            relationsList.appendChild(buildRelationRow(other, relation));
                        });
                    }
                }

                if (tiersList) {
                    tiersList.innerHTML = '';
                    const tiers = Array.isArray(faction.reputationTiers) ? faction.reputationTiers : [];
                    if (tiers.length) {
                        tiers.forEach(tier => tiersList.appendChild(buildTierRow(tier)));
                    } else {
                        tiersList.appendChild(buildTierRow());
                    }
                }

                const standingValue = state.playerStandings?.[faction.id];
                if (standingInput) {
                    standingInput.value = Number.isFinite(standingValue) ? standingValue : '';
                }
                if (standingTier) {
                    const numericStanding = Number.isFinite(standingValue) ? Number(standingValue) : NaN;
                    standingTier.textContent = resolveStandingTierLabel(numericStanding, faction.reputationTiers || []);
                }
            };

            const collectAssets = () => {
                if (!assetsList) {
                    return [];
                }
                const rows = Array.from(assetsList.querySelectorAll('.faction-asset-row'));
                return rows.map(row => {
                    const nameField = row.querySelector('.faction-asset-name');
                    const typeField = row.querySelector('.faction-asset-type');
                    const descField = row.querySelector('.faction-asset-description');
                    const name = nameField ? nameField.value.trim() : '';
                    const type = typeField ? typeField.value.trim() : '';
                    const description = descField ? descField.value.trim() : '';

                    if (!name && !type && !description) {
                        return null;
                    }
                    if (!name) {
                        throw new Error('All assets must include a name.');
                    }
                    const asset = { name };
                    if (type) asset.type = type;
                    if (description) asset.description = description;
                    return asset;
                }).filter(Boolean);
            };

            const collectRelations = () => {
                if (!relationsList) {
                    return {};
                }
                const rows = Array.from(relationsList.querySelectorAll('.faction-relation-row'));
                const relations = {};
                rows.forEach(row => {
                    const targetId = row.dataset.targetId || '';
                    const statusField = row.querySelector('.faction-relation-status');
                    const notesField = row.querySelector('.faction-relation-notes');
                    const status = statusField ? statusField.value.trim() : '';
                    const notes = notesField ? notesField.value.trim() : '';
                    if (!status) {
                        return;
                    }
                    if (!notes) {
                        throw new Error('All relations with a status require notes.');
                    }
                    relations[targetId] = { status, notes };
                });
                return relations;
            };

            const collectTiers = () => {
                if (!tiersList) {
                    return [];
                }
                const rows = Array.from(tiersList.querySelectorAll('.faction-tier-row'));
                return rows.map(row => {
                    const thresholdField = row.querySelector('.faction-tier-threshold');
                    const labelField = row.querySelector('.faction-tier-label');
                    const perksField = row.querySelector('.faction-tier-perks');
                    const penaltiesField = row.querySelector('.faction-tier-penalties');
                    const thresholdValue = thresholdField ? thresholdField.value.trim() : '';
                    const label = labelField ? labelField.value.trim() : '';
                    const perks = perksField ? splitList(perksField.value) : [];
                    const penalties = penaltiesField ? splitList(penaltiesField.value) : [];

                    if (!thresholdValue && !label && perks.length === 0 && penalties.length === 0) {
                        return null;
                    }
                    const numericThreshold = Number(thresholdValue);
                    if (!Number.isFinite(numericThreshold)) {
                        throw new Error('Reputation tiers require a numeric threshold.');
                    }
                    return {
                        threshold: numericThreshold,
                        label,
                        perks,
                        penalties
                    };
                }).filter(Boolean);
            };

            const gatherFactionPayload = () => {
                if (!nameInput || !nameInput.value.trim()) {
                    throw new Error('Faction name is required.');
                }
                const shortDescription = shortDescriptionInput ? shortDescriptionInput.value.trim() : '';
                const description = descriptionInput ? descriptionInput.value.trim() : '';
                return {
                    name: nameInput.value.trim(),
                    homeRegionName: homeInput ? homeInput.value.trim() : '',
                    shortDescription: shortDescription || null,
                    description: description || null,
                    tags: splitList(tagsInput ? tagsInput.value : ''),
                    goals: splitList(goalsInput ? goalsInput.value : ''),
                    assets: collectAssets(),
                    relations: collectRelations(),
                    reputationTiers: collectTiers()
                };
            };

            const refreshFactions = async () => {
                try {
                    const response = await fetch('/api/factions', { cache: 'no-store' });
                    const data = await response.json().catch(() => ({}));
                    if (!response.ok || !data?.success) {
                        throw new Error(data?.error || 'Failed to fetch factions.');
                    }
                    state.factions = Array.isArray(data.factions) ? data.factions : [];
                    state.factionMap = new Map(state.factions.map(faction => [faction.id, faction]));
                    state.playerStandings = data.playerStandings && typeof data.playerStandings === 'object'
                        ? data.playerStandings
                        : {};

                    if (state.selectedId && !state.factionMap.has(state.selectedId)) {
                        state.selectedId = null;
                    }
                    if (!state.selectedId && state.factions.length > 0) {
                        state.selectedId = state.factions[0].id;
                    }
                    renderList();
                    renderDetail();
                } catch (error) {
                    console.warn('Failed to refresh factions:', error);
                    if (emptyEl) {
                        emptyEl.style.display = 'block';
                        emptyEl.textContent = 'Failed to load factions.';
                    }
                    clearDetail();
                }
            };

            window.refreshFactions = refreshFactions;

            if (addButton) {
                addButton.addEventListener('click', async () => {
                    const name = window.prompt('Enter a name for the new faction:');
                    const trimmed = typeof name === 'string' ? name.trim() : '';
                    if (!trimmed) {
                        return;
                    }
                    try {
                        const response = await fetch('/api/factions', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: trimmed })
                        });
                        const data = await response.json().catch(() => ({}));
                        if (!response.ok || !data?.success) {
                            throw new Error(data?.error || 'Failed to create faction.');
                        }
                        state.selectedId = data.faction?.id || null;
                        await refreshFactions();
                    } catch (error) {
                        console.error('Failed to create faction:', error);
                        window.alert(`Failed to create faction: ${error.message || error}`);
                    }
                });
            }

            if (deleteButton) {
                deleteButton.addEventListener('click', async () => {
                    const faction = state.factionMap.get(state.selectedId);
                    if (!faction) {
                        return;
                    }
                    const confirmed = window.confirm(`Delete faction "${faction.name || faction.id}"? This cannot be undone.`);
                    if (!confirmed) {
                        return;
                    }
                    try {
                        const response = await fetch(`/api/factions/${encodeURIComponent(faction.id)}`, { method: 'DELETE' });
                        const data = await response.json().catch(() => ({}));
                        if (!response.ok || !data?.success) {
                            throw new Error(data?.error || 'Failed to delete faction.');
                        }
                        state.selectedId = null;
                        await refreshFactions();
                    } catch (error) {
                        console.error('Failed to delete faction:', error);
                        window.alert(`Failed to delete faction: ${error.message || error}`);
                    }
                });
            }

            if (assetAddButton) {
                assetAddButton.addEventListener('click', () => {
                    if (assetsList) {
                        assetsList.appendChild(buildAssetRow());
                    }
                });
            }

            if (tierAddButton) {
                tierAddButton.addEventListener('click', () => {
                    if (tiersList) {
                        tiersList.appendChild(buildTierRow());
                    }
                });
            }

            if (standingInput) {
                standingInput.addEventListener('input', () => {
                    const faction = state.factionMap.get(state.selectedId);
                    if (!standingTier || !faction) {
                        return;
                    }
                    const rawValue = standingInput.value.trim();
                    if (!rawValue) {
                        standingTier.textContent = '‚Äî';
                        return;
                    }
                    const numeric = Number(rawValue);
                    standingTier.textContent = resolveStandingTierLabel(numeric, faction.reputationTiers || []);
                });
            }

            formEl.addEventListener('submit', async (event) => {
                event.preventDefault();
                const factionId = state.selectedId;
                if (!factionId) {
                    window.alert('Select a faction to edit.');
                    return;
                }
                try {
                    const payload = gatherFactionPayload();
                    const response = await fetch(`/api/factions/${encodeURIComponent(factionId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json().catch(() => ({}));
                    if (!response.ok || !data?.success) {
                        throw new Error(data?.error || 'Failed to update faction.');
                    }

                    const standingRaw = standingInput ? standingInput.value.trim() : '';
                    const standingPayload = standingRaw === '' ? null : Number(standingRaw);
                    if (standingRaw === '' || Number.isFinite(standingPayload)) {
                        const standingResponse = await fetch(`/api/player/factions/${encodeURIComponent(factionId)}/standing`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ value: standingPayload })
                        });
                        const standingData = await standingResponse.json().catch(() => ({}));
                        if (!standingResponse.ok || !standingData?.success) {
                            throw new Error(standingData?.error || 'Failed to update faction standing.');
                        }
                    } else {
                        throw new Error('Standing value must be a number or blank.');
                    }

                    await refreshFactions();
                } catch (error) {
                    console.error('Failed to save faction:', error);
                    window.alert(`Failed to save faction: ${error.message || error}`);
                }
            });

            refreshFactions();
        }

        function initPlayerOverviewSync() {
            async function refreshPlayerOverview() {
                try {
                    const response = await fetch('/api/player');
                    const data = await response.json();
                    if (data.success && data.player) {
                        updateChatPlayerPanel(data.player);
                        if (Array.isArray(data.player.partyMembers)) {
                            renderChatPartyPanel(data.player.partyMembers);
                        }
                        if (typeof window.renderQuestPanel === 'function') {
                            window.renderQuestPanel(data.player.quests || [], data.player.completedQuests || []);
                        }
                    }
                } catch (error) {
                    console.warn('Failed to refresh player overview:', error);
                }
            }

            window.refreshInventory = refreshPlayerOverview;
            window.updateInventoryDisplay = refreshPlayerOverview;
            refreshPlayerOverview();
        }

        function initPartyDisplay() {
            const partyGrid = document.getElementById('partyMembers');
            const emptyState = document.getElementById('partyEmpty');
            const countLabel = document.getElementById('partyCount');
            const floatingTooltip = document.getElementById('partyTooltip');
            const partyPanel = document.querySelector('.party-panel');

            const statOrder = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'];
            const statLabels = {
                strength: 'STR',
                dexterity: 'DEX',
                constitution: 'CON',
                intelligence: 'INT',
                wisdom: 'WIS',
                charisma: 'CHA'
            };

            function hideTooltip() {
                if (!floatingTooltip) return;
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            }

            function positionTooltip(event) {
                if (!floatingTooltip) return;
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            }

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            if (partyGrid) {
                registerPartyDropTarget(partyGrid, 'recruit');
            }
            if (emptyState) {
                registerPartyDropTarget(emptyState, 'recruit');
            }

            function renderParty(members = []) {
                if (!partyGrid || !emptyState || !countLabel) {
                    return;
                }

                const safeMembers = Array.isArray(members)
                    ? members.filter(member => member && typeof member === 'object')
                    : [];
                partyGrid.innerHTML = '';
                hideTooltip();

                countLabel.textContent = `${safeMembers.length} ${safeMembers.length === 1 ? 'member' : 'members'}`;
                emptyState.style.display = safeMembers.length ? 'none' : 'block';
                partyGrid.style.display = safeMembers.length ? 'flex' : 'none';

                const previousSnapshots = new Map();
                if (npcDataCache instanceof Map) {
                    safeMembers.forEach(member => {
                        if (member?.id && npcDataCache.has(member.id)) {
                            previousSnapshots.set(member.id, npcDataCache.get(member.id));
                        }
                    });
                }

                renderChatPartyPanel(safeMembers);

                safeMembers.forEach(member => {
                    if (!member) {
                        return;
                    }

                    const previous = member?.id ? previousSnapshots.get(member.id) : null;

                    const card = document.createElement('div');
                    card.className = 'party-card';
                    if (member?.id) {
                        card.dataset.npcId = member.id;
                    }

                    const portrait = document.createElement('div');
                    portrait.className = 'party-portrait';

                    const portraitImage = document.createElement('div');
                    portraitImage.className = 'party-portrait-image';
                    portrait.appendChild(portraitImage);

                    const { bar: portraitHealthBar, fill: portraitHealthFill } = createHealthBar('npc-health-bar');
                    portraitHealthFill.classList.add('npc-health-bar-fill');
                    portrait.appendChild(portraitHealthBar);

                    const portraitNeedBars = document.createElement('div');
                    portraitNeedBars.className = 'npc-need-bars need-bars';
                    portrait.appendChild(portraitNeedBars);

                    renderEntityImage({
                        element: portraitImage,
                        entityType: member.isNPC ? 'npc' : 'player',
                        entityId: member.id,
                        imageId: member.imageId || null,
                        altText: member.name || 'Party member portrait',
                        placeholderIcon: 'üé≠',
                        placeholderClass: 'party-portrait-placeholder'
                    });

                    if (portraitHealthBar) {
                        if (member?.name) {
                            portraitHealthBar.setAttribute('aria-label', `${member.name} health`);
                        } else {
                            portraitHealthBar.removeAttribute('aria-label');
                        }
                    }

                    updateHealthBar(portraitHealthBar, portraitHealthFill, member?.health, member?.maxHealth);

                    renderNeedBars(
                        portraitNeedBars,
                        Array.isArray(member?.needBars) ? member.needBars : [],
                        {
                            includePlayerOnly: false,
                            variant: 'npc'
                        }
                    );

                    applyNpcDeathStyling(card, portrait, member);

                    const name = document.createElement('div');
                    name.className = 'party-name';
                    name.textContent = member.name || 'Unknown';

                    const role = document.createElement('div');
                    role.className = 'party-role';
                    const parts = [];
                    if (member.class) parts.push(member.class);
                    if (member.race) parts.push(member.race);
                    role.textContent = parts.join(' ¬∑ ') || 'Companion';

                    const meta = document.createElement('div');
                    meta.className = 'party-meta';
                    const levelText = typeof member.level === 'number' ? `Level ${member.level}` : 'Level ?';
                    meta.textContent = `${levelText}${member.isNPC ? ' ¬∑ NPC' : ''}`;

                    const stats = document.createElement('div');
                    stats.className = 'party-stats';
                    const attrs = member.attributes || {};
                    statOrder.forEach(key => {
                        const value = attrs[key] !== undefined ? attrs[key] : '‚Äî';
                        const stat = document.createElement('div');
                        stat.className = 'party-stat';
                        stat.innerHTML = `<span>${statLabels[key]}</span><strong>${value}</strong>`;
                        stats.appendChild(stat);
                    });

                    const description = member.description || member.shortDescription || 'No description provided.';

                    card.addEventListener('mouseenter', (event) => {
                        if (!floatingTooltip || !description) return;
                        floatingTooltip.textContent = description;
                        floatingTooltip.removeAttribute('hidden');
                        floatingTooltip.classList.add('visible');
                        positionTooltip(event);
                    });

                    card.addEventListener('mousemove', (event) => {
                        if (!floatingTooltip || floatingTooltip.hasAttribute('hidden')) return;
                        positionTooltip(event);
                    });

                    card.addEventListener('mouseleave', () => {
                        hideTooltip();
                    });

                    card.appendChild(portrait);
                    card.appendChild(name);
                    card.appendChild(role);
                    card.appendChild(meta);
                    card.appendChild(stats);

                    registerNpcPartyDragSource(card, member, 'party');

                    if (typeof window.registerInventoryDropTarget === 'function') {
                        window.registerInventoryDropTarget(card, { ownerId: member.id, ownerType: 'npc' });
                    }

                    partyGrid.appendChild(card);

                    if (member && member.id) {
                        if (typeof registerNpcContextMenu === 'function') {
                            registerNpcContextMenu(card, member);
                        }
                        triggerHealthChangeEffect(portrait, previous, member);
                        npcDataCache.set(member.id, cloneActorRecord(member) || { ...member });
                    }
                });
            }

            window.updatePartyDisplay = renderParty;

            async function refreshParty() {
                try {
                    const response = await fetch('/api/player/party');
                    const data = await response.json();
                    if (data.success && Array.isArray(data.members)) {
                        renderParty(data.members);
                    } else {
                        renderParty([]);
                    }
                } catch (error) {
                    console.warn('Failed to refresh party members:', error);
                    renderParty([]);
                }
            }

            window.refreshParty = refreshParty;
            refreshParty();

            if (partyPanel) {
                partyPanel.addEventListener('scroll', hideTooltip);
            }
            window.addEventListener('scroll', hideTooltip, { passive: true });
        }

        async function loadCurrentLocation() {
            console.log('Loading current player location...');
            try {
                const response = await fetch('/api/player', { cache: 'no-store' });
                const result = await response.json();
                
                if (result.success && result.player) {
                    updateChatPlayerPanel(result.player);
                    if (Array.isArray(result.player.partyMembers)) {
                        renderChatPartyPanel(result.player.partyMembers);
                    }
                    if (typeof window.renderQuestPanel === 'function') {
                        window.renderQuestPanel(result.player.quests || [], result.player.completedQuests || []);
                    }
                }

                const locationId = result.player?.locationId || result.player?.currentLocation || null;
                if (result.success && result.player && locationId) {
                    // Fetch location details
                    console.log("Fetching location details for ID:", locationId);
                    const cacheBuster = Date.now();
                    const locationResponse = await fetch(`/api/locations/${locationId}?_=${cacheBuster}`, {
                        cache: 'no-store'
                    });
                    const locationResult = await locationResponse.json();
                    
                    console.log("Current location data:", locationResult.location);

                    if (locationResult.success && locationResult.location) {
                        console.log("Updating location display");
                        await window.updateLocationDisplay(locationResult.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    }
                }
            } catch (error) {
                console.log('Could not load current location:', error);
                hideLocationOverlay();
            }
        }

        window.loadCurrentLocation = loadCurrentLocation;

        function initSaveLoadButtons() {
            const saveGameBtn = document.getElementById('saveGameBtn');
            const loadGameBtn = document.getElementById('loadGameBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            
            saveGameBtn.addEventListener('click', async function() {
                try {
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Saving...';
                    
                    const response = await fetch('/api/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> Saved!';
                        alert(`Game saved successfully!\n\nSave: ${result.saveName}`);
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Save Failed';
                        alert(`Save failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Save Failed';
                    alert(`Save failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üíæ</span> Save Game';
                    }, 2000);
                }
            });

            loadGameBtn.addEventListener('click', async function() {
                this.disabled = true;
                this.innerHTML = '<span>‚è≥</span> Loading...';
                loadGameTriggerButton = this;
                try {
                    openLoadGameModal({ initialSource: 'saves' });
                    await refreshLoadGameList('saves');
                } catch (error) {
                    setLoadGameStatus(`Failed to load ${getLoadGameSourceLabel({ source: 'saves', plural: true })}: ${error.message}`, 'error');
                } finally {
                    this.disabled = false;
                    this.innerHTML = '<span>üìÇ</span> Load Game';
                }
            });

            if (newGameBtn) {
            newGameBtn.addEventListener('click', async function() {
                try {
                    const confirmation = confirm('Start a new game? This will clear your current progress.\n\nYou can optionally enter a custom player name and description.');
                    if (!confirmation) return;
                    
                    // Get optional player details
                    const playerName = prompt('Enter your character name (or leave blank for "Adventurer"):') || 'Adventurer';
                    const playerDescription = prompt('Enter your character description (optional):') || 'A brave soul embarking on a new adventure.';
                    
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Creating...';
                    
                    const response = await fetch('/api/new-game', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            playerName: playerName,
                            playerDescription: playerDescription
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> New Game Started!';
                        alert(`New game created successfully!\n\nPlayer: ${result.player.name}\nStarting Location: ${result.startingLocation.name}\n\nYour adventure begins now!`);
                        window.location.reload();
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Failed';
                        alert(`New game creation failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Failed';
                    alert(`New game creation failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üÜï</span> New Game';
                    }, 2000);
                }
            });
            }
        }
    </script>
</body>
</html>
