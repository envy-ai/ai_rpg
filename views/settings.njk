<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title | default("Game Settings Manager") }}</title>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/settings.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚öôÔ∏è Game Settings Manager</h1>
            <p>Create and manage custom game world settings</p>
            {% include "_navigation.njk" %}
        </div>

        <div id="statusMessage" class="status-message"></div>

        <div class="settings-grid">
            <!-- Settings List Panel -->
            <div class="settings-list">
                <div style="display: flex; align-items: center; margin-bottom: 1rem;">
                    <h2>üìã Saved Settings</h2>
                    
                </div>
                
                <div id="settingsList">
                    <div class="empty-state">
                        <p>No settings created yet.<br>Create your first setting using the form ‚Üí</p>
                    </div>
                </div>
            </div>

            <!-- Settings Form Panel -->
            <div class="settings-form">
                <h2 id="formTitle">‚ú® Create New Setting</h2>
                
                <form id="settingForm">
                    <input type="hidden" id="settingId" name="id">

                    <div class="form-group">
                        <label for="name">Setting Name *</label>
                        <input type="text" id="name" name="name" required>
                        <div class="help-text">Unique name for this setting configuration</div>
                    </div>

                    <div class="form-group">
                        <label for="description">Description</label>
                        <textarea id="description" name="description" rows="20" placeholder="Describe this setting and what makes it unique..."></textarea>
                    </div>

                    <div class="form-group">
                        <label for="theme">World Theme *</label>
                        <input type="text" id="theme" name="theme" required placeholder="e.g., Fantasy, Sci-Fi, Modern, Horror, Cyberpunk...">
                        <div class="help-text">The overarching setting of the game world</div>
                    </div>

                    <div class="form-group">
                        <label for="genre">Game Genre *</label>
                        <input type="text" id="genre" name="genre" required placeholder="e.g., Adventure, Mystery, Combat, Exploration, Survival...">
                        <div class="help-text">Primary style of gameplay focus</div>
                    </div>

                    <div class="form-group">
                        <label for="startingLocationType">Starting Location Type</label>
                        <input type="text" id="startingLocationType" name="startingLocationType" placeholder="e.g., Tavern, Village, City, Wilderness, Ship...">
                        <div class="help-text">Where adventures typically begin</div>
                    </div>

                    <div class="form-group">
                        <label for="magicLevel">Magic Level</label>
                        <input type="text" id="magicLevel" name="magicLevel" placeholder="e.g., High Magic, Low Magic, Rare, Ubiquitous, None...">
                        <div class="help-text">How common magic is in the world</div>
                    </div>

                    <div class="form-group">
                        <label for="techLevel">Technology Level</label>
                        <input type="text" id="techLevel" name="techLevel" placeholder="e.g., Medieval, Renaissance, Industrial, Modern, Futuristic...">
                        <div class="help-text">Technological advancement of the world</div>
                    </div>

                    <div class="form-group">
                        <label for="tone">Narrative Tone</label>
                        <input type="text" id="tone" name="tone" placeholder="e.g., Heroic, Dark, Comedic, Gritty, Epic, Lighthearted...">
                        <div class="help-text">Overall emotional atmosphere</div>
                    </div>

                    <div class="form-group">
                        <label for="difficulty">Difficulty Level</label>
                        <input type="text" id="difficulty" name="difficulty" placeholder="e.g., Easy, Normal, Hard, Lethal, Forgiving...">
                        <div class="help-text">Challenge level and lethality</div>
                    </div>

                    <div class="form-group">
                        <label for="currencyName">Currency Name</label>
                        <input type="text" id="currencyName" name="currencyName" placeholder="e.g., Credit, Coin, Gil">
                        <div class="help-text">Singular name used when referencing a single unit of currency.</div>
                    </div>

                    <div class="form-group">
                        <label for="currencyNamePlural">Currency Name (Plural)</label>
                        <input type="text" id="currencyNamePlural" name="currencyNamePlural" placeholder="e.g., Credits, Coins, Gil">
                        <div class="help-text">Plural form of the currency for amounts above one.</div>
                    </div>

                    <div class="form-group">
                        <label for="playerStartingLevel">Player Starting Level</label>
                        <input type="number" id="playerStartingLevel" name="playerStartingLevel" min="1" value="1">
                        <div class="help-text">Level for new players</div>
                    </div>

                    <div class="form-divider">New Game Defaults</div>

                    <div class="form-group">
                        <label for="defaultPlayerName">Default Player Name</label>
                        <input type="text" id="defaultPlayerName" name="defaultPlayerName" placeholder="e.g., Adventurer">
                        <div class="help-text">Prefills the player name on the New Game screen.</div>
                    </div>

                    <div class="form-group full-width">
                        <label for="defaultPlayerDescription">Default Player Description</label>
                        <textarea id="defaultPlayerDescription" name="defaultPlayerDescription" rows="3" placeholder="Describe the default hero..."></textarea>
                        <div class="help-text">Prefills the player description on the New Game screen.</div>
                    </div>

                    <div class="form-group">
                        <label for="defaultStartingLocation">Default Starting Location</label>
                        <input type="text" id="defaultStartingLocation" name="defaultStartingLocation" placeholder="e.g., Village of Dawnstar">
                        <div class="help-text">Prefills the starting location field on the New Game screen.</div>
                    </div>

                    <div class="form-group">
                        <label for="defaultStartingCurrency">Default Starting Currency</label>
                        <input type="number" id="defaultStartingCurrency" name="defaultStartingCurrency" min="0" value="0">
                        <div class="help-text">Prefills the Starting Currency field on the New Game screen.</div>
                    </div>

                    <div class="form-group">
                        <label for="defaultNumSkills">Default Number of Skills</label>
                        <input type="number" id="defaultNumSkills" name="defaultNumSkills" min="0" max="100" value="20">
                        <div class="help-text">Prefills the number of skills to generate (0-100).</div>
                    </div>

                    <div class="form-group full-width">
                        <label for="defaultExistingSkills">Default Existing Skills (one per line)</label>
                        <textarea id="defaultExistingSkills" name="defaultExistingSkills" rows="4" placeholder="Enter skill names..."></textarea>
                        <div class="help-text">These skills will be added before new ones are generated.</div>
                    </div>

                    <div class="form-divider">Character Options</div>

                    <div class="form-group full-width">
                        <label for="availableClasses">Available Classes (one per line)</label>
                        <textarea id="availableClasses" name="availableClasses" rows="4" placeholder="Warrior\nRanger\nArcane Scholar"></textarea>
                        <div class="help-text">Classes the player can pick during character creation.</div>
                    </div>

                    <div class="form-group full-width">
                        <label for="availableRaces">Available Races (one per line)</label>
                        <textarea id="availableRaces" name="availableRaces" rows="4" placeholder="Human\nElf\nClockwork Automaton"></textarea>
                        <div class="help-text">Races or species available for new characters.</div>
                    </div>

                    <div class="form-divider">Worldbuilding Notes</div>

                    <div class="form-group full-width">
                        <label for="currencyValueNotes">Currency Value Notes</label>
                        <textarea id="currencyValueNotes" name="currencyValueNotes" rows="4" placeholder="Describe how valuable different amounts of currency are, typical wages, or trade conventions..."></textarea>
                        <div class="help-text">Explain what typical amounts of money can buy or how wealth is perceived.</div>
                    </div>

                    <div class="form-group full-width">
                        <label for="writingStyleNotes">Writing Style Notes</label>
                        <textarea id="writingStyleNotes" name="writingStyleNotes" rows="4" placeholder="Provide storytelling tone, visual motifs, cultural details, or vibe notes for the Game Master..."></textarea>
                        <div class="help-text">Additional guidance for narrative voice, aesthetic, or flavor details.</div>
                    </div>

                    <div class="form-divider">Image Prompt Prefixes</div>

                    <div class="form-group full-width">
                        <label for="imagePromptPrefixCharacter">Character Image Prompt Prefix</label>
                        <textarea id="imagePromptPrefixCharacter" name="imagePromptPrefixCharacter" rows="3" placeholder="Short guidance appended before character portrait prompts..."></textarea>
                        <div class="help-text">Optional text prepended to character portrait prompts (e.g., art style, lighting, tone).</div>
                    </div>

                    <div class="form-group full-width">
                        <label for="imagePromptPrefixLocation">Location Image Prompt Prefix</label>
                        <textarea id="imagePromptPrefixLocation" name="imagePromptPrefixLocation" rows="3" placeholder="Short guidance for location images..."></textarea>
                        <div class="help-text">Optional text prepended to location art prompts.</div>
                    </div>

                    <div class="form-group full-width">
                        <label for="imagePromptPrefixItem">Item Image Prompt Prefix</label>
                        <textarea id="imagePromptPrefixItem" name="imagePromptPrefixItem" rows="3" placeholder="Short guidance for item renders..."></textarea>
                        <div class="help-text">Optional text prepended to item illustration prompts.</div>
                    </div>

                    <div class="form-group full-width">
                        <label for="imagePromptPrefixScenery">Scenery Image Prompt Prefix</label>
                        <textarea id="imagePromptPrefixScenery" name="imagePromptPrefixScenery" rows="3" placeholder="Short guidance for scenery/establishing shot art..."></textarea>
                        <div class="help-text">Optional text prepended to scenery/background prompts.</div>
                    </div>

                    <!-- Preview Section -->
                    <div id="previewSection" class="preview-section" style="display: none;">
                        <div class="preview-title">Setting Preview</div>
                        <div id="previewContent"></div>
                    </div>

                    <div class="form-actions">
                        <div class="button-group">
                            <button type="button" id="clearBtn" class="btn btn-secondary">Clear</button>
                            <button type="submit" id="submitBtn" class="btn btn-primary">Create Setting</button>
                        </div>
                        <button type="button" id="generateBtn" class="btn btn-accent">‚ú® Auto-Fill Blank Fields</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div id="autofillInstructionsModal" class="modal settings-autofill-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2>Additional Guidance</h2>
                <button type="button" class="modal__close" id="autofillInstructionsCloseBtn" aria-label="Close auto-fill instructions dialog">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body">
                <p class="help-text" style="margin-bottom: 0.75rem;">Optional notes for the AI when generating missing setting details. Leave blank to continue without extra guidance.</p>
                <textarea id="autofillInstructionsInput" rows="5" placeholder="E.g., focus on coastal cities and political intrigue..."></textarea>
                <div class="autofill-image-field">
                    <label for="autofillImageInput">Reference Image (optional)</label>
                    <input type="file" id="autofillImageInput" accept="image/*">
                    <div class="help-text">Attach an image to guide the AI when filling missing fields.</div>
                </div>
            </div>
            <footer class="modal__footer">
                <div class="button-group">
                    <button type="button" class="btn btn-secondary" id="autofillInstructionsCancelBtn">Cancel</button>
                    <button type="button" class="btn btn-primary" id="autofillInstructionsConfirmBtn">Apply Guidance</button>
                </div>
            </footer>
        </div>
    </div>

    <script>
        let currentSettings = [];
        let selectedSettingId = null;
        let isEditMode = false;
        let appliedSetting = null;
        const autofillInstructionsModal = document.getElementById('autofillInstructionsModal');
        const autofillInstructionsInput = document.getElementById('autofillInstructionsInput');
        const autofillImageInput = document.getElementById('autofillImageInput');
        const autofillInstructionsCancelBtn = document.getElementById('autofillInstructionsCancelBtn');
        const autofillInstructionsCloseBtn = document.getElementById('autofillInstructionsCloseBtn');
        const autofillInstructionsConfirmBtn = document.getElementById('autofillInstructionsConfirmBtn');
        let pendingAutofillButton = null;

        function openAutofillInstructionsModal(triggerButton) {
            if (!autofillInstructionsModal) {
                handleGenerateFill(triggerButton, '', null);
                return;
            }
            pendingAutofillButton = triggerButton || null;
            if (autofillInstructionsInput) {
                autofillInstructionsInput.value = '';
            }
            if (autofillImageInput) {
                autofillImageInput.value = '';
            }
            if (autofillInstructionsConfirmBtn) {
                autofillInstructionsConfirmBtn.disabled = false;
            }
            autofillInstructionsModal.removeAttribute('hidden');
            autofillInstructionsModal.setAttribute('aria-hidden', 'false');
            autofillInstructionsModal.classList.add('is-open');
            requestAnimationFrame(() => {
                autofillInstructionsInput?.focus();
            });
        }

        function closeAutofillInstructionsModal() {
            if (!autofillInstructionsModal) {
                return;
            }
            autofillInstructionsModal.setAttribute('hidden', '');
            autofillInstructionsModal.setAttribute('aria-hidden', 'true');
            autofillInstructionsModal.classList.remove('is-open');
            if (autofillInstructionsConfirmBtn) {
                autofillInstructionsConfirmBtn.disabled = false;
            }
            pendingAutofillButton = null;
        }

        // Load settings on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // Automatically load saved settings from files into memory on page load
            try {
                const resp = await fetch('/api/settings/load', { method: 'POST' });
                const data = await resp.json();
                if (!data.success) {
                    console.warn('Auto-load saved settings failed:', data.error);
                }
            } catch (e) {
                console.warn('Auto-load saved settings failed:', e.message);
            }

            await loadCurrentSetting();
            await refreshSettingsList();
            setupEventListeners();
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && autofillInstructionsModal && !autofillInstructionsModal.hasAttribute('hidden')) {
                event.preventDefault();
                closeAutofillInstructionsModal();
            }
        });

        async function refreshSettingsList() {
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                
                if (data.success) {
                    currentSettings = data.settings;
                    renderSettingsList();
                }
            } catch (error) {
                showMessage('Error loading settings: ' + error.message, 'error');
            }
        }

        async function loadCurrentSetting() {
            try {
                const response = await fetch('/api/settings/current');
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load current setting');
                }

                appliedSetting = data.setting || null;
                updateCurrentSettingDisplay();
                if (appliedSetting) {
                    applySettingToForm(appliedSetting, { markAsSelected: Boolean(appliedSetting.id) });
                }
            } catch (error) {
                console.error('Could not load current setting:', error);
                showMessage('Could not load current setting: ' + (error?.message || error), 'error');
            }
        }

        function updateCurrentSettingDisplay() {
            const listHeader = document.querySelector('.settings-list h2');
            if (appliedSetting) {
                listHeader.innerHTML = `üìã Saved Settings <small style="color: #4CAF50;">(${appliedSetting.name} applied)</small>`;
            } else {
                listHeader.innerHTML = 'üìã Saved Settings';
            }
        }

        function renderSettingsList() {
            const container = document.getElementById('settingsList');
            
            if (currentSettings.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>No settings created yet.<br>Create your first setting using the form ‚Üí</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = currentSettings.map(setting => `
                <div class="setting-item ${selectedSettingId === setting.id ? 'selected' : ''} ${appliedSetting && appliedSetting.id === setting.id ? 'applied' : ''}" 
                     onclick="selectSetting('${setting.id}')">
                    <div class="setting-header">
                        <div class="setting-name">
                            ${setting.name}
                            ${appliedSetting && appliedSetting.id === setting.id ? ' <span style="color: #4CAF50;">‚úì Applied</span>' : ''}
                        </div>
                    </div>
                    <div class="setting-meta">
                        ${setting.theme}/${setting.genre} ‚Ä¢ ${setting.tone} ‚Ä¢ ${setting.difficulty}
                    </div>
                    <div class="setting-actions">
                        <button class="btn-small btn-edit" onclick="editSetting('${setting.id}'); event.stopPropagation();">Edit</button>
                        <button class="btn-small btn-primary" onclick="applySetting('${setting.id}'); event.stopPropagation();">Apply</button>
                        <button class="btn-small btn-clone" onclick="cloneSetting('${setting.id}'); event.stopPropagation();">Clone</button>
                        <button class="btn-small btn-delete" onclick="deleteSetting('${setting.id}'); event.stopPropagation();">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function applySettingToForm(setting, { markAsSelected = false } = {}) {
            if (!setting || typeof setting !== 'object') {
                throw new Error('applySettingToForm requires a setting object');
            }

            const getField = (id) => {
                const field = document.getElementById(id);
                if (!field) {
                    throw new Error(`Form field "${id}" is missing`);
                }
                return field;
            };

            const assignValue = (id, value = '') => {
                const field = getField(id);
                field.value = value ?? '';
            };

            assignValue('settingId', setting.id || '');
            assignValue('name', setting.name || '');
            assignValue('description', setting.description || '');
            assignValue('theme', setting.theme || '');
            assignValue('genre', setting.genre || '');
            assignValue('startingLocationType', setting.startingLocationType || '');
            assignValue('magicLevel', setting.magicLevel || '');
            assignValue('techLevel', setting.techLevel || '');
            assignValue('tone', setting.tone || '');
            assignValue('difficulty', setting.difficulty || '');
            assignValue('currencyName', setting.currencyName || '');
            assignValue('currencyNamePlural', setting.currencyNamePlural || '');

            const startingLevelParsed = Number.parseInt(setting.playerStartingLevel, 10);
            assignValue(
                'playerStartingLevel',
                Number.isFinite(startingLevelParsed) ? String(startingLevelParsed) : '1'
            );

            const defaultCurrencyParsed = Number.parseInt(setting.defaultStartingCurrency, 10);
            assignValue(
                'defaultStartingCurrency',
                Number.isFinite(defaultCurrencyParsed) ? String(defaultCurrencyParsed) : '0'
            );

            assignValue('defaultPlayerName', setting.defaultPlayerName || '');
            assignValue('defaultPlayerDescription', setting.defaultPlayerDescription || '');
            assignValue('defaultStartingLocation', setting.defaultStartingLocation || '');

            const defaultNumSkillsParsed = Number.parseInt(setting.defaultNumSkills, 10);
            assignValue(
                'defaultNumSkills',
                Number.isFinite(defaultNumSkillsParsed) ? String(defaultNumSkillsParsed) : '20'
            );

            const joinLines = (value) => {
                if (Array.isArray(value)) {
                    return value.join('\n');
                }
                if (typeof value === 'string') {
                    return value;
                }
                return '';
            };

            assignValue('defaultExistingSkills', joinLines(setting.defaultExistingSkills));
            assignValue('availableClasses', joinLines(setting.availableClasses));
            assignValue('availableRaces', joinLines(setting.availableRaces));
            assignValue('currencyValueNotes', setting.currencyValueNotes || '');
            assignValue('writingStyleNotes', setting.writingStyleNotes || '');
            assignValue('imagePromptPrefixCharacter', setting.imagePromptPrefixCharacter || '');
            assignValue('imagePromptPrefixLocation', setting.imagePromptPrefixLocation || '');
            assignValue('imagePromptPrefixItem', setting.imagePromptPrefixItem || '');
            assignValue('imagePromptPrefixScenery', setting.imagePromptPrefixScenery || '');

            if (markAsSelected && setting.id) {
                selectedSettingId = setting.id;
            }

            isEditMode = Boolean(setting.id);
            const titleEl = document.getElementById('formTitle');
            if (titleEl) {
                const safeName = typeof setting.name === 'string' ? setting.name.trim() : '';
                titleEl.textContent = safeName ? `‚úèÔ∏è Edit Setting: ${safeName}` : '‚úèÔ∏è Edit Setting';
            }
            const submitBtn = document.getElementById('submitBtn');
            if (submitBtn) {
                submitBtn.textContent = 'Update Setting';
            }

            renderSettingsList();
            updatePreview();
        }

        function selectSetting(settingId) {
            selectedSettingId = settingId;
            renderSettingsList();
            updatePreview();
        }

        function editSetting(settingId) {
            if (!settingId) {
                throw new Error('editSetting requires a settingId');
            }
            const setting = currentSettings.find(s => s.id === settingId);
            if (!setting) {
                throw new Error(`Setting with id "${settingId}" not found`);
            }

            applySettingToForm(setting, { markAsSelected: true });
        }

        async function cloneSetting(settingId) {
            try {
                const newName = prompt('Enter name for cloned setting:');
                if (!newName) return;

                const response = await fetch(`/api/settings/${settingId}/clone`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ newName })
                });

                const data = await response.json();
                
                if (data.success) {
                    // Auto-save the new clone to file
                    if (data.setting && data.setting.id) {
                        try {
                            const saveResp = await fetch(`/api/settings/${data.setting.id}/save`, { method: 'POST' });
                            const saveData = await saveResp.json();
                            if (!saveData.success) {
                                console.warn('Auto-save of cloned setting failed:', saveData.error);
                            }
                        } catch (e) {
                            console.warn('Auto-save of cloned setting failed:', e.message);
                        }
                    }

                    showMessage('Setting cloned successfully!', 'success');
                    await refreshSettingsList();
                } else {
                    showMessage('Error cloning setting: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('Error cloning setting: ' + error.message, 'error');
            }
        }

        async function deleteSetting(settingId) {
            if (!confirm('Are you sure you want to delete this setting?')) return;

            try {
                const response = await fetch(`/api/settings/${settingId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                
                if (data.success) {
                    showMessage('Setting deleted successfully!', 'success');
                    
                    // Clear form if we were editing this setting
                    if (selectedSettingId === settingId) {
                        clearForm();
                    }
                    
                    await refreshSettingsList();
                } else {
                    showMessage('Error deleting setting: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('Error deleting setting: ' + error.message, 'error');
            }
        }

        async function applySetting(settingId) {
            try {
                const response = await fetch(`/api/settings/${settingId}/apply`, {
                    method: 'POST'
                });

                const data = await response.json();
                
                if (data.success) {
                    showMessage('Setting applied successfully! Game Master will now use this setting.', 'success');
                    appliedSetting = data.setting;
                    console.log('Applied Setting:', appliedSetting);
                    updateCurrentSettingDisplay();
                    if (appliedSetting) {
                        applySettingToForm(appliedSetting, { markAsSelected: Boolean(appliedSetting.id) });
                    }
                    renderSettingsList();
                } else {
                    showMessage('Error applying setting: ' + data.error, 'error');
                }

                // Get /api/settings/current to confirm
                const response2 = await fetch('/api/settings/current');
                const data2 = await response2.json();

                // Log current setting to console
                console.log('Current Setting after apply:', data2);
                if (!data2.success) {
                    console.error('Failed to confirm current setting:', data2.error);
                    showMessage('Failed to confirm current setting: ' + (data2.error || 'unknown error'), 'error');
                }
            } catch (error) {
                showMessage('Error applying setting: ' + error.message, 'error');
            }
        }

        function clearForm() {
            document.getElementById('settingForm').reset();
            document.getElementById('settingId').value = '';
            document.getElementById('formTitle').textContent = '‚ú® Create New Setting';
            document.getElementById('submitBtn').textContent = 'Create Setting';
            
            isEditMode = false;
            selectedSettingId = null;
            
            // Clear all inputs to blank
            const inputs = document.querySelectorAll('#settingForm input, #settingForm select');
            inputs.forEach(input => {
                input.value = '';
            });
            const textareas = document.querySelectorAll('#settingForm textarea');
            textareas.forEach(area => {
                area.value = '';
            });

            document.getElementById('playerStartingLevel').value = '1';
            const defaultNumSkillsField = document.getElementById('defaultNumSkills');
            if (defaultNumSkillsField) {
                defaultNumSkillsField.value = '20';
            }
            const defaultExistingSkillsField = document.getElementById('defaultExistingSkills');
            if (defaultExistingSkillsField) {
                defaultExistingSkillsField.value = '';
            }
            const availableClassesField = document.getElementById('availableClasses');
            if (availableClassesField) {
                availableClassesField.value = '';
            }
            const availableRacesField = document.getElementById('availableRaces');
            if (availableRacesField) {
                availableRacesField.value = '';
            }
            const defaultPlayerNameField = document.getElementById('defaultPlayerName');
            if (defaultPlayerNameField) {
                defaultPlayerNameField.value = '';
            }
            const defaultPlayerDescriptionField = document.getElementById('defaultPlayerDescription');
            if (defaultPlayerDescriptionField) {
                defaultPlayerDescriptionField.value = '';
            }
            const defaultStartingLocationField = document.getElementById('defaultStartingLocation');
            if (defaultStartingLocationField) {
                defaultStartingLocationField.value = '';
            }
            const defaultStartingCurrencyField = document.getElementById('defaultStartingCurrency');
            if (defaultStartingCurrencyField) {
                defaultStartingCurrencyField.value = '0';
            }
            renderSettingsList();
            updatePreview();
        }

        function updatePreview() {
            const form = document.getElementById('settingForm');
            const formData = new FormData(form);
            
            const preview = document.getElementById('previewSection');
            const content = document.getElementById('previewContent');
            
            const name = formData.get('name');
            if (!name) {
                preview.style.display = 'none';
                return;
            }
            
            preview.style.display = 'block';
            
            const theme = formData.get('theme') || 'Not set';
            const genre = formData.get('genre') || 'Not set';
            const tone = formData.get('tone') || 'Not set';
            const difficulty = formData.get('difficulty') || 'Not set';
            const magicLevel = formData.get('magicLevel') || 'Not set';
            const techLevel = formData.get('techLevel') || 'Not set';
            const classesText = formData.get('availableClasses') || '';
            const racesText = formData.get('availableRaces') || '';

            const classesCount = splitLines(classesText).length;
            const racesCount = splitLines(racesText).length;
            const extraLines = [];
            if (classesCount > 0) {
                extraLines.push(`Classes: ${classesCount}`);
            }
            if (racesCount > 0) {
                extraLines.push(`Races: ${racesCount}`);
            }
            
            content.innerHTML = `
                <strong>${name}</strong><br>
                <small>${theme}/${genre} setting with ${tone} tone and ${difficulty} difficulty</small><br>
                Magic: ${magicLevel} ‚Ä¢ Tech: ${techLevel}${extraLines.length ? `<br>${extraLines.join(' ‚Ä¢ ')}` : ''}
            `;
        }

        function splitLines(value) {
            return (value || '')
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(line => line.length > 0);
        }

        function setupEventListeners() {
            // Form submission
            document.getElementById('settingForm').addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const formData = new FormData(e.target);
                const settingData = Object.fromEntries(formData.entries());

                // Convert playerStartingLevel to number
                settingData.playerStartingLevel = parseInt(settingData.playerStartingLevel) || 1;
                const parsedDefaultNumSkills = Number.parseInt(settingData.defaultNumSkills, 10);
                settingData.defaultNumSkills = Number.isFinite(parsedDefaultNumSkills)
                    ? Math.max(0, Math.min(100, parsedDefaultNumSkills))
                    : 20;
                const parsedDefaultCurrency = parseInt(settingData.defaultStartingCurrency, 10);
                settingData.defaultStartingCurrency = Number.isFinite(parsedDefaultCurrency) ? Math.max(0, parsedDefaultCurrency) : 0;
                const defaultExistingSkillsText = settingData.defaultExistingSkills || '';
                settingData.defaultExistingSkills = splitLines(defaultExistingSkillsText);
                settingData.availableClasses = splitLines(settingData.availableClasses);
                settingData.availableRaces = splitLines(settingData.availableRaces);
                
                try {
                    let response;
                    let savedId = null;
                    if (isEditMode) {
                        const settingId = settingData.id;
                        delete settingData.id;
                        response = await fetch(`/api/settings/${settingId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settingData)
                        });
                        savedId = settingId;
                    } else {
                        response = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settingData)
                        });
                    }

                    const data = await response.json();
                    
                    if (data.success) {
                        // Determine the ID to persist
                        if (!savedId && data.setting && data.setting.id) {
                            savedId = data.setting.id;
                        }

                        let appliedSuccessfully = false;

                        // Auto-save the created/updated setting to file
                        if (savedId) {
                            try {
                                const saveResp = await fetch(`/api/settings/${savedId}/save`, { method: 'POST' });
                                const saveData = await saveResp.json();
                                if (!saveData.success) {
                                    console.warn('Auto-save failed:', saveData.error);
                                }
                            } catch (saveErr) {
                                console.warn('Auto-save failed:', saveErr.message);
                            }

                            // Apply the setting immediately so the game uses the latest version
                            try {
                                const applyResp = await fetch(`/api/settings/${savedId}/apply`, { method: 'POST' });
                                const applyData = await applyResp.json();
                                if (applyData.success) {
                                    appliedSuccessfully = true;
                                    appliedSetting = applyData.setting;
                                    updateCurrentSettingDisplay();
                                } else {
                                    console.warn('Auto-apply failed:', applyData.error);
                                }
                            } catch (applyErr) {
                                console.warn('Auto-apply failed:', applyErr.message);
                            }
                        }

                        const successMessage = `Setting ${isEditMode ? 'updated' : 'created'} successfully${appliedSuccessfully ? ' and applied to the game world' : ''}!`;
                        showMessage(successMessage, 'success');
                        clearForm();
                        await refreshSettingsList();
                        await loadCurrentSetting();
                    } else {
                        showMessage(`Error ${isEditMode ? 'updating' : 'creating'} setting: ` + data.error, 'error');
                    }
                } catch (error) {
                    showMessage(`Error ${isEditMode ? 'updating' : 'creating'} setting: ` + error.message, 'error');
                }
            });

            // Clear button
            document.getElementById('clearBtn').addEventListener('click', clearForm);

            // Form change detection for preview
            document.getElementById('settingForm').addEventListener('input', updatePreview);
            document.getElementById('settingForm').addEventListener('change', updatePreview);

            const generateBtn = document.getElementById('generateBtn');
            if (generateBtn) {
                generateBtn.addEventListener('click', () => openAutofillInstructionsModal(generateBtn));
            }

            if (autofillInstructionsCancelBtn) {
                autofillInstructionsCancelBtn.addEventListener('click', () => closeAutofillInstructionsModal());
            }
            if (autofillInstructionsCloseBtn) {
                autofillInstructionsCloseBtn.addEventListener('click', () => closeAutofillInstructionsModal());
            }
            if (autofillInstructionsConfirmBtn) {
                autofillInstructionsConfirmBtn.addEventListener('click', async () => {
                    const instructions = autofillInstructionsInput?.value?.trim() || '';
                    const imageFile = autofillImageInput?.files?.[0] || null;
                    if (imageFile && !imageFile.type.startsWith('image/')) {
                        showMessage('Autofill image must be an image file.', 'error');
                        return;
                    }
                    const targetButton = pendingAutofillButton || generateBtn;
                    closeAutofillInstructionsModal();
                    if (targetButton) {
                        handleGenerateFill(targetButton, instructions, imageFile);
                    }
                });
            }

            // Save/Load buttons removed; auto behaviors implemented
        }

        async function downscaleImageDataUrl(dataUrl, outputType) {
            const maxPixels = 2000000;
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => {
                    const width = image.naturalWidth || image.width;
                    const height = image.naturalHeight || image.height;
                    if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
                        reject(new Error('Autofill image dimensions are invalid.'));
                        return;
                    }

                    const pixelCount = width * height;
                    if (pixelCount <= maxPixels) {
                        resolve(dataUrl);
                        return;
                    }

                    const scale = Math.sqrt(maxPixels / pixelCount);
                    const targetWidth = Math.max(1, Math.round(width * scale));
                    const targetHeight = Math.max(1, Math.round(height * scale));
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        reject(new Error('Autofill image resizing failed to initialize.'));
                        return;
                    }
                    ctx.drawImage(image, 0, 0, targetWidth, targetHeight);

                    const normalizedType = outputType && outputType.startsWith('image/')
                        ? outputType
                        : 'image/jpeg';
                    const supportsQuality = normalizedType === 'image/jpeg' || normalizedType === 'image/webp';
                    const resizedDataUrl = supportsQuality
                        ? canvas.toDataURL(normalizedType, 0.9)
                        : canvas.toDataURL(normalizedType);
                    resolve(resizedDataUrl);
                };
                image.onerror = () => reject(new Error('Autofill image could not be loaded.'));
                image.src = dataUrl;
            });
        }

        async function readAutofillImageData(file) {
            if (!file) {
                return '';
            }
            if (!file.type || !file.type.startsWith('image/')) {
                throw new Error('Autofill image must be an image file.');
            }
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof reader.result === 'string') {
                        resolve(reader.result);
                        return;
                    }
                    reject(new Error('Autofill image could not be read.'));
                };
                reader.onerror = () => reject(new Error('Autofill image could not be read.'));
                reader.readAsDataURL(file);
            });
            return downscaleImageDataUrl(dataUrl, file.type);
        }

        async function handleGenerateFill(buttonEl, instructions = '', imageFile = null) {
            if (!buttonEl || buttonEl.disabled) {
                return;
            }

            buttonEl.disabled = true;
            const originalText = buttonEl.textContent;
            buttonEl.textContent = '‚ú® Generating...';

            try {
                const instructionsText = typeof instructions === 'string' ? instructions.trim() : '';
                const imageDataUrl = await readAutofillImageData(imageFile);
                const form = document.getElementById('settingForm');
                const formData = new FormData(form);
                const settingPayload = Object.fromEntries(formData.entries());
                settingPayload.playerStartingLevel = settingPayload.playerStartingLevel || '';
                const parsedPayloadNumSkills = Number.parseInt(settingPayload.defaultNumSkills, 10);
                settingPayload.defaultNumSkills = Number.isFinite(parsedPayloadNumSkills)
                    ? Math.max(0, Math.min(100, parsedPayloadNumSkills))
                    : '';
                settingPayload.defaultExistingSkills = splitLines(settingPayload.defaultExistingSkills);
                settingPayload.availableClasses = splitLines(settingPayload.availableClasses);
                settingPayload.availableRaces = splitLines(settingPayload.availableRaces);
                const parsedDefaultCurrency = parseInt(settingPayload.defaultStartingCurrency, 10);
                settingPayload.defaultStartingCurrency = Number.isFinite(parsedDefaultCurrency)
                    ? Math.max(0, parsedDefaultCurrency)
                    : '';

                const requestBody = {
                    setting: settingPayload,
                    instructions: instructionsText
                };
                if (imageDataUrl) {
                    requestBody.imageDataUrl = imageDataUrl;
                }

                const response = await fetch('/api/settings/fill-missing', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok || !data?.success) {
                    const errorMessage = data?.error || `Unexpected error (${response.status})`;
                    showMessage('Generation failed: ' + errorMessage, 'error');
                    return;
                }

                const filled = data.setting || {};
                const applyText = (fieldId, value) => {
                    const field = document.getElementById(fieldId);
                    if (!field || value === undefined || value === null) {
                        return;
                    }
                    if (Array.isArray(value)) {
                        field.value = value.join('\n');
                    } else {
                        field.value = value;
                    }
                };

                Object.entries({
                    name: filled.name,
                    description: filled.description,
                    theme: filled.theme,
                    genre: filled.genre,
                    startingLocationType: filled.startingLocationType,
                    magicLevel: filled.magicLevel,
                    techLevel: filled.techLevel,
                    tone: filled.tone,
                    difficulty: filled.difficulty,
                    currencyName: filled.currencyName,
                    currencyNamePlural: filled.currencyNamePlural,
                    playerStartingLevel: filled.playerStartingLevel,
                    defaultPlayerName: filled.defaultPlayerName,
                    defaultPlayerDescription: filled.defaultPlayerDescription,
                    defaultStartingLocation: filled.defaultStartingLocation,
                    defaultStartingCurrency: filled.defaultStartingCurrency,
                    defaultNumSkills: filled.defaultNumSkills,
                    defaultExistingSkills: filled.defaultExistingSkills,
                    availableClasses: filled.availableClasses,
                    availableRaces: filled.availableRaces,
                    currencyValueNotes: filled.currencyValueNotes,
                    writingStyleNotes: filled.writingStyleNotes,
                    imagePromptPrefixCharacter: filled.imagePromptPrefixCharacter,
                    imagePromptPrefixLocation: filled.imagePromptPrefixLocation,
                    imagePromptPrefixItem: filled.imagePromptPrefixItem,
                    imagePromptPrefixScenery: filled.imagePromptPrefixScenery
                }).forEach(([fieldId, value]) => applyText(fieldId, value));

                showMessage('Blank fields populated successfully.', 'success');
                updatePreview();
            } catch (error) {
                showMessage('Generation failed: ' + (error?.message || error), 'error');
            } finally {
                buttonEl.disabled = false;
                buttonEl.textContent = originalText;
            }
        }

        function showMessage(message, type) {
            const messageEl = document.getElementById('statusMessage');
            messageEl.textContent = message;
            messageEl.className = `status-message status-${type}`;
            messageEl.style.display = 'block';
            
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>
